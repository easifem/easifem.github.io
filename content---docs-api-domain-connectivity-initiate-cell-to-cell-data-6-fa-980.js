"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkeasifem_docs"] = globalThis["webpackChunkeasifem_docs"] || []).push([["content---docs-api-domain-connectivity-initiate-cell-to-cell-data-6-fa-980"],{

/***/ "./docs/docs-api/DomainConnectivity/InitiateCellToCellData.md":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  assets: () => (/* binding */ assets),\n  contentTitle: () => (/* binding */ InitiateCellToCellData_contentTitle),\n  \"default\": () => (/* binding */ InitiateCellToCellData_MDXContent),\n  frontMatter: () => (/* binding */ InitiateCellToCellData_frontMatter),\n  metadata: () => (/* reexport */ site_docs_docs_api_domain_connectivity_initiate_cell_to_cell_data_md_6fa_namespaceObject),\n  toc: () => (/* binding */ InitiateCellToCellData_toc)\n});\n\n;// ./.docusaurus/docusaurus-plugin-content-docs/docs-api/site-docs-docs-api-domain-connectivity-initiate-cell-to-cell-data-md-6fa.json\nconst site_docs_docs_api_domain_connectivity_initiate_cell_to_cell_data_md_6fa_namespaceObject = /*#__PURE__*/JSON.parse('{\"id\":\"DomainConnectivity/InitiateCellToCellData\",\"title\":\"InitiateCellToCellData\",\"description\":\"This routine initiates cellToCell data (mapping) between two Domain or Mesh.\",\"source\":\"@site/docs/docs-api/DomainConnectivity/InitiateCellToCellData.md\",\"sourceDirName\":\"DomainConnectivity\",\"slug\":\"/DomainConnectivity/InitiateCellToCellData\",\"permalink\":\"/docs-api/DomainConnectivity/InitiateCellToCellData\",\"draft\":false,\"unlisted\":false,\"editUrl\":\"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/DomainConnectivity/InitiateCellToCellData.md\",\"tags\":[],\"version\":\"current\",\"lastUpdatedAt\":1539502055000,\"frontMatter\":{},\"sidebar\":\"tutorialSidebar\",\"previous\":{\"title\":\"GlobalFacetID\",\"permalink\":\"/docs-api/DomainConnectivity/GlobalFacetID\"},\"next\":{\"title\":\"InitiateFacetToCellData\",\"permalink\":\"/docs-api/DomainConnectivity/InitiateFacetToCellData\"}}');\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(\"./node_modules/react/jsx-runtime.js\");\n// EXTERNAL MODULE: ./node_modules/@mdx-js/react/lib/index.js\nvar lib = __webpack_require__(\"./node_modules/@mdx-js/react/lib/index.js\");\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Tabs/index.js + 2 modules\nvar Tabs = __webpack_require__(\"./node_modules/@docusaurus/theme-classic/lib/theme/Tabs/index.js\");\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/TabItem/index.js + 1 modules\nvar TabItem = __webpack_require__(\"./node_modules/@docusaurus/theme-classic/lib/theme/TabItem/index.js\");\n;// ./docs/docs-api/DomainConnectivity/_DomainConnectivity_test_11.md\n\n\nconst frontMatter = {};\nconst contentTitle = undefined;\n\n\n\n\n\nconst toc = [];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.p, {\n      children: \"In this example we will generate cell to cell connectivity information between part of pressure-domain and part of pressure-Domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"dim1=2, entity=1\"\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"dim2=2, entity=1\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Pressure domain consists Triangle3 elements as shown below.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n  USE easifemBase\\n  USE easifemClasses\\n  IMPLICIT NONE\\n  TYPE(DomainConnectivity_) :: obj\\n  TYPE( Domain_ ) :: pressureDomain\\n  TYPE( HDF5File_ ) :: pressureMeshFile\\n  CLASS( Mesh_ ), POINTER :: pressureMesh => NULL()\\n  INTEGER( I4B ), POINTER :: cellToCell( : ) => NULL()\\n  INTEGER( I4B ) :: ii\\n  INTEGER(i4b) :: dim1=2, dim2=2, entity1=1, entity2=1\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Create domain for pressure variables, READ the mesh file, and initiates the domain for pressure\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL pressureMeshFile%Initiate( FileName=\\\"./mesh_tri3.h5\\\", MODE=\\\"READ\\\" )\\nCALL pressureMeshFile%Open()\\nCALL pressureDomain%Initiate( pressureMeshFile, \\\"\\\")\\nCALL pressureMeshFile%Deallocate()\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateNodeToNodeData( domain1=pressureDomain, &\\n  & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2).\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now we can initiate cell-to-cell DATA between the above mentioned meshes.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateCellToCellData( domain1=pressureDomain, &\\n  & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\nCALL Display(\\\"Success!!\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"cellToCell => obj%getCellToCellPointer()\\npressureMesh => pressureDomain%getMeshPointer(dim=dim1, &\\n  & entityNum=entity1)\\nDO ii = pressureMesh%minElemNum, pressureMesh%maxElemNum\\n  IF (.NOT. pressureMesh%isElementPresent(ii)) CYCLE\\n  IF (cellToCell(ii) .NE. ii) THEN\\n    CALL FAIL(\\\"DomainConnectivity-test has failed\\\")\\n    STOP\\n  END IF\\nEND DO\\nCALL PASS(\\\"DomainConnectivity-test-11 has passed\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Cleaning up.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"  CALL pressureDomain%Deallocate()\\n  CALL obj%Deallocate()\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/DomainConnectivity/_DomainConnectivity_test_12.md\n\n\nconst _DomainConnectivity_test_12_frontMatter = {};\nconst _DomainConnectivity_test_12_contentTitle = undefined;\n\n\n\n\n\nconst _DomainConnectivity_test_12_toc = [];\nfunction _DomainConnectivity_test_12_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    pre: \"pre\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.p, {\n      children: \"In this example we will generate cell to cell connectivity information between part of velocity-domain and part of velocity-Domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Velocity domain consists Triangle6 elements as shown below.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n  USE easifemBase\\n  USE easifemClasses\\n  IMPLICIT NONE\\n  TYPE(DomainConnectivity_) :: obj\\n  TYPE( Domain_ ) :: velocityDomain\\n  TYPE( HDF5File_ ) :: velocityMeshFile\\n  CLASS( Mesh_ ), POINTER :: velocityMesh => NULL()\\n  INTEGER( I4B ), POINTER :: cellToCell( : ) => NULL()\\n  INTEGER( I4B ) :: ii\\n  INTEGER(i4b) :: dim1=2, dim2=2, entity1=1, entity2=1\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Create domain for velocity variables, READ the mesh file, and initiates the domain for pressure\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL velocityMeshFile%Initiate( FileName=\\\"./mesh_tri6.h5\\\", MODE=\\\"READ\\\" )\\nCALL velocityMeshFile%Open()\\nCALL velocityDomain%Initiate( velocityMeshFile, \\\"\\\")\\nCALL velocityMeshFile%Deallocate()\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateNodeToNodeData( domain1=velocityDomain, &\\n  & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2).\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now we can initiate cell-to-cell DATA between the above mentioned meshes.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateCellToCellData( domain1=velocityDomain, &\\n  & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"cellToCell => obj%getCellToCellPointer()\\nvelocityMesh => velocityDomain%getMeshPointer(dim=dim1, &\\n  & entityNum=entity1)\\nDO ii = velocityMesh%minElemNum, velocityMesh%maxElemNum\\n  IF (.NOT. velocityMesh%isElementPresent(ii)) CYCLE\\n  IF (cellToCell(ii) .NE. ii) THEN\\n    CALL FAIL(\\\"DomainConnectivity-test has failed\\\")\\n    STOP\\n  END IF\\nEND DO\\nCALL PASS(\\\"DomainConnectivity-test has passed\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Cleaning up.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"  CALL velocityDomain%Deallocate()\\n  CALL obj%Deallocate()\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _DomainConnectivity_test_12_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_12_createMdxContent, {\n      ...props\n    })\n  }) : _DomainConnectivity_test_12_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/DomainConnectivity/_DomainConnectivity_test_13.md\n\n\nconst _DomainConnectivity_test_13_frontMatter = {};\nconst _DomainConnectivity_test_13_contentTitle = undefined;\n\n\n\n\n\nconst _DomainConnectivity_test_13_toc = [];\nfunction _DomainConnectivity_test_13_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.p, {\n      children: \"In this example we will generate cell to cell connectivity information between part of pressure-domain and part of pressure-Domain. We will map boundary of a domain with the boundary of the other domain\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Pressure domain consists Triangle3 elements as shown below.\"\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Velocity domain consists Triangle6 elements as shown below.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Importing modules and variables\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n  USE easifemBase\\n  USE easifemClasses\\n  IMPLICIT NONE\\n  TYPE(DomainConnectivity_) :: obj\\n  TYPE( Domain_ ) :: pressureDomain\\n  TYPE( HDF5File_ ) :: pressureMeshFile\\n  CLASS( Mesh_ ), POINTER :: pressureMesh => NULL()\\n  INTEGER( I4B ), POINTER :: cellToCell( : ) => NULL()\\n  INTEGER( I4B ) :: ii\\n  INTEGER(i4b) :: dim1=1, dim2=1, entity1=1, entity2=1\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Create domain for pressure variables, READ the mesh file, and initiates the domain for pressure\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL pressureMeshFile%Initiate( FileName=\\\"./mesh_tri3.h5\\\", MODE=\\\"READ\\\" )\\nCALL pressureMeshFile%Open()\\nCALL pressureDomain%Initiate( pressureMeshFile, \\\"\\\")\\nCALL pressureMeshFile%Deallocate()\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateNodeToNodeData( domain1=pressureDomain, &\\n  & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2).\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now we can initiate cell-to-cell DATA between the above mentioned meshes.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateCellToCellData( domain1=pressureDomain, &\\n  & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\nCALL Display(\\\"Success!!\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"cellToCell => obj%getCellToCellPointer()\\npressureMesh => pressureDomain%getMeshPointer(dim=dim1, &\\n  & entityNum=entity1)\\nDO ii = pressureMesh%minElemNum, pressureMesh%maxElemNum\\n  IF (.NOT. pressureMesh%isElementPresent(ii)) CYCLE\\n  IF (cellToCell(ii) .NE. ii) THEN\\n    CALL FAIL(\\\"DomainConnectivity-test-11 has failed\\\")\\n    STOP\\n  END IF\\nEND DO\\nCALL PASS(\\\"DomainConnectivity-test has passed\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Cleaning up.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"  CALL pressureDomain%Deallocate()\\n  CALL obj%Deallocate()\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _DomainConnectivity_test_13_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_13_createMdxContent, {\n      ...props\n    })\n  }) : _DomainConnectivity_test_13_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/DomainConnectivity/_DomainConnectivity_test_14.md\n\n\nconst _DomainConnectivity_test_14_frontMatter = {};\nconst _DomainConnectivity_test_14_contentTitle = undefined;\n\n\n\n\n\nconst _DomainConnectivity_test_14_toc = [];\nfunction _DomainConnectivity_test_14_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.p, {\n      children: \"In this example we will generate cell to cell connectivity information between part of velocity-domain and part of velocity-Domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"Pressure domain consists \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"Triangle3\"\n        }), \" elements as shown below.\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"Velocity domain consists \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"Triangle6\"\n        }), \" elements as shown below.\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Importing modules and variables\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n  USE easifemBase\\n  USE easifemClasses\\n  IMPLICIT NONE\\n  TYPE(DomainConnectivity_) :: obj\\n  TYPE( Domain_ ) :: velocityDomain\\n  TYPE( HDF5File_ ) :: velocityMeshFile\\n  CLASS( Mesh_ ), POINTER :: velocityMesh => NULL()\\n  INTEGER( I4B ), POINTER :: cellToCell( : ) => NULL()\\n  INTEGER( I4B ) :: ii\\n  INTEGER(i4b) :: dim1=1, dim2=1, entity1=1, entity2=1\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Create domain for velocity variables, 🎇 READ the mesh file, and ⭕ initiates the domain for pressure\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL velocityMeshFile%Initiate( FileName=\\\"./mesh_tri6.h5\\\", MODE=\\\"READ\\\" )\\nCALL velocityMeshFile%Open()\\nCALL velocityDomain%Initiate( velocityMeshFile, \\\"\\\")\\nCALL velocityMeshFile%Deallocate()\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateNodeToNodeData( domain1=velocityDomain, &\\n  & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2).\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now we can initiate cell-to-cell DATA between the above mentioned meshes.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateCellToCellData( domain1=velocityDomain, &\\n  & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"cellToCell => obj%getCellToCellPointer()\\nvelocityMesh => velocityDomain%getMeshPointer(dim=dim1, &\\n  & entityNum=entity1)\\nDO ii = velocityMesh%minElemNum, velocityMesh%maxElemNum\\n  IF (.NOT. velocityMesh%isElementPresent(ii)) CYCLE\\n  IF (cellToCell(ii) .NE. ii) THEN\\n    CALL FAIL(\\\"DomainConnectivity-test-11 has failed\\\")\\n    STOP\\n  END IF\\nEND DO\\nCALL PASS(\\\"DomainConnectivity-test has passed\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Cleaning up.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"  CALL velocityDomain%Deallocate()\\n  CALL obj%Deallocate()\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _DomainConnectivity_test_14_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_14_createMdxContent, {\n      ...props\n    })\n  }) : _DomainConnectivity_test_14_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/DomainConnectivity/_DomainConnectivity_test_15.md\n\n\nconst _DomainConnectivity_test_15_frontMatter = {};\nconst _DomainConnectivity_test_15_contentTitle = undefined;\n\n\n\n\n\nconst _DomainConnectivity_test_15_toc = [];\nfunction _DomainConnectivity_test_15_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.p, {\n      children: \"In this example we will show how to USE [[DomainConnectivity_#InitiateCellToCell]] method to generate cell-to-cell connectivity information between part of velocity-domain and part of pressure-Domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"Pressure domain consists \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"Triangle3\"\n        }), \" elements as shown below.\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"Velocity domain consists \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"Triangle6\"\n        }), \" elements as shown below.\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"IMPORT modules and classes\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n  USE easifemBase\\n  USE easifemClasses\\n  IMPLICIT NONE\\n  TYPE(DomainConnectivity_) :: obj\\n  TYPE( Domain_ ) :: pressureDomain\\n  TYPE( Domain_ ) :: velocityDomain\\n  TYPE( HDF5File_ ) :: pressureMeshFile\\n  TYPE( HDF5File_ ) :: velocityMeshFile\\n  CLASS( Mesh_ ), POINTER :: velocityMesh\\n  CLASS( Mesh_ ), POINTER :: pressureMesh\\n  INTEGER( I4B ), POINTER :: cellToCell( : )\\n  INTEGER( I4B ) :: ii\\n  INTEGER(i4b), PARAMETER :: dim1=2, dim2=2, entity1=1, entity2=1\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"create domain for velocity variables, 🎇 READ the mesh file, and ⭕ initiates the domain for pressure\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL velocityMeshFile%Initiate( FileName=\\\"./mesh_tri6.h5\\\", MODE=\\\"READ\\\" )\\nCALL velocityMeshFile%Open()\\nCALL velocityDomain%Initiate( velocityMeshFile, \\\"\\\")\\nCALL velocityMeshFile%Deallocate()\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"create domain for pressure variables, 🎇 READ the mesh file, and ⭕ initiates the domain for pressure\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL pressureMeshFile%Initiate( FileName=\\\"./mesh_tri3.h5\\\", MODE=\\\"READ\\\" )\\nCALL pressureMeshFile%Open()\\nCALL pressureDomain%Initiate( pressureMeshFile, \\\"\\\")\\nCALL pressureMeshFile%Deallocate()\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateNodeToNodeData( domain1=velocityDomain, &\\n  & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2).\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now we can initiate cell-to-cell DATA between the above mentioned meshes.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateCellToCellData( domain1=velocityDomain, &\\n  & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"cellToCell => obj%getCellToCellPointer()\\nvelocityMesh => velocityDomain%getMeshPointer(dim=dim1, &\\n  & entityNum=entity1)\\nDO ii = velocityMesh%minElemNum, velocityMesh%maxElemNum\\n  IF (.NOT. velocityMesh%isElementPresent(ii)) CYCLE\\n  IF (cellToCell(ii) .EQ. 0) THEN\\n    CALL FAIL(\\\"DomainConnectivity-test has failed\\\")\\n    STOP\\n  END IF\\nEND DO\\nCALL PASS(\\\"DomainConnectivity-test has passed\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"  CALL pressureDomain%Deallocate()\\n  CALL velocityDomain%Deallocate()\\n  CALL obj%Deallocate()\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _DomainConnectivity_test_15_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_15_createMdxContent, {\n      ...props\n    })\n  }) : _DomainConnectivity_test_15_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/DomainConnectivity/_DomainConnectivity_test_16.md\n\n\nconst _DomainConnectivity_test_16_frontMatter = {};\nconst _DomainConnectivity_test_16_contentTitle = undefined;\n\n\n\n\n\nconst _DomainConnectivity_test_16_toc = [];\nfunction _DomainConnectivity_test_16_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.p, {\n      children: \"In this example, we will show how to USE [[DomainConnectivity_#InitiateCellToCellData]] method to generate cell-to-cell connectivity information between part of velocity-domain and part of pressure-Domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Pressure domain consists Triangle3 elements as shown below.\"\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Velocity domain consists Triangle6 elements as shown below.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n  USE easifemBase\\n  USE easifemClasses\\n  IMPLICIT NONE\\n  TYPE(DomainConnectivity_) :: obj\\n  TYPE( Domain_ ) :: pressureDomain\\n  TYPE( Domain_ ) :: velocityDomain\\n  TYPE( HDF5File_ ) :: pressureMeshFile\\n  TYPE( HDF5File_ ) :: velocityMeshFile\\n  CLASS( Mesh_ ), POINTER :: velocityMesh\\n  CLASS( Mesh_ ), POINTER :: pressureMesh\\n  INTEGER( I4B ), POINTER :: cellToCell( : )\\n  INTEGER( I4B ) :: ii\\n  INTEGER(i4b), PARAMETER :: dim1=2, dim2=2, entity1=1, entity2=1\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Create domain for velocity variables, 🎇 READ the mesh file, and ⭕ initiates the domain for pressure\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL velocityMeshFile%Initiate( FileName=\\\"./mesh_tri6.h5\\\", MODE=\\\"READ\\\" )\\nCALL velocityMeshFile%Open()\\nCALL velocityDomain%Initiate( velocityMeshFile, \\\"\\\")\\nCALL velocityMeshFile%Deallocate()\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Create domain for pressure variables, 🎇 READ the mesh file, and ⭕ initiates the domain for pressure\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL pressureMeshFile%Initiate( FileName=\\\"./mesh_tri3.h5\\\", MODE=\\\"READ\\\" )\\nCALL pressureMeshFile%Open()\\nCALL pressureDomain%Initiate( pressureMeshFile, \\\"\\\")\\nCALL pressureMeshFile%Deallocate()\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateNodeToNodeData( domain1=pressureDomain, &\\n  & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2).\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now we can initiate cell-to-cell DATA between the above mentioned meshes.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateCellToCellData( domain1=pressureDomain, &\\n  & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\\n  & entityNum2=entity2)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"cellToCell => obj%getCellToCellPointer()\\npressureMesh => pressureDomain%getMeshPointer(dim=dim1, &\\n  & entityNum=entity1)\\nDO ii = pressureMesh%minElemNum, pressureMesh%maxElemNum\\n  IF (.NOT. pressureMesh%isElementPresent(ii)) CYCLE\\n  IF (cellToCell(ii) .EQ. 0) THEN\\n    CALL FAIL(\\\"DomainConnectivity-test has failed\\\")\\n    STOP\\n  END IF\\nEND DO\\nCALL PASS(\\\"DomainConnectivity-test has passed\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"  CALL pressureDomain%Deallocate()\\n  CALL velocityDomain%Deallocate()\\n  CALL obj%Deallocate()\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _DomainConnectivity_test_16_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_16_createMdxContent, {\n      ...props\n    })\n  }) : _DomainConnectivity_test_16_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/DomainConnectivity/_DomainConnectivity_test_17.md\n\n\nconst _DomainConnectivity_test_17_frontMatter = {};\nconst _DomainConnectivity_test_17_contentTitle = undefined;\n\n\n\n\n\nconst _DomainConnectivity_test_17_toc = [];\nfunction _DomainConnectivity_test_17_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.p, {\n      children: \"In this example we will generate cell to cell connectivity information between pressure-domain and pressure-Domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"Pressure domain consists \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"Triangle3\"\n        }), \" elements as shown below.\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"Velocity domain consists \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"Triangle6\"\n        }), \" elements as shown below.\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Importing modules and variables\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n  USE easifemBase\\n  USE easifemClasses\\n  IMPLICIT NONE\\n  TYPE(DomainConnectivity_) :: obj\\n  TYPE( Domain_ ) :: pressureDomain\\n  TYPE( HDF5File_ ) :: pressureMeshFile\\n  CLASS( Mesh_ ), POINTER :: pressureMesh\\n  CLASS( ReferenceElement_ ), POINTER :: refelem\\n  INTEGER( I4B ), POINTER :: cellToCell( : )\\n  INTEGER( I4B ) :: ii, iel\\n  INTEGER(I4B), PARAMETER :: dim1=2, dim2=2, entity1=1, entity2=1\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiate domain for pressure variable.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL pressureMeshFile%Initiate( FileName=\\\"./mesh_tri3.h5\\\", MODE=\\\"READ\\\" )\\nCALL pressureMeshFile%Open()\\nCALL pressureDomain%Initiate( pressureMeshFile, \\\"\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiate node to node DATA.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateNodeToNodeData( domain1=pressureDomain, &\\n  & domain2=pressureDomain )\\nCALL PASS(\\\"InitiateNodeToNodeData()\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This will create node to node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2).\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiate cell to cell connectivity DATA.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateCellToCellData(domain1=pressureDomain, &\\n  & domain2=pressureDomain)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"now let us run some tests.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"cellToCell => obj%getCellToCellPointer()\\nDO iel = pressureDomain%minElemNum, pressureDomain%maxElemNum\\n  IF (.NOT. pressureDomain%isElementPresent(iel)) CYCLE\\n  IF (cellToCell(iel) .EQ. 0) THEN\\n    pressureMesh => pressureDomain%getMeshPointer(globalElement=iel)\\n    refelem => pressureMesh%getRefElemPointer()\\n    IF (refelem%xidimension .EQ. pressureDomain%getNSD()) &\\n      & CALL fail(\\\"CellToCell: error code 1\\\")\\n  ELSE\\n    IF (cellToCell(iel) .NE. iel) THEN\\n      CALL fail(\\\"CellToCell: error code 2\\\")\\n      STOP\\n    END IF\\n  END IF\\nEND DO\\nCALL PASS(\\\"InitiateCellToCellData()\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"  CALL pressureMeshFile%Deallocate()\\n  CALL pressureDomain%Deallocate()\\n  CALL obj%Deallocate()\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _DomainConnectivity_test_17_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_17_createMdxContent, {\n      ...props\n    })\n  }) : _DomainConnectivity_test_17_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/DomainConnectivity/_DomainConnectivity_test_18.md\n\n\nconst _DomainConnectivity_test_18_frontMatter = {};\nconst _DomainConnectivity_test_18_contentTitle = undefined;\n\n\n\n\n\nconst _DomainConnectivity_test_18_toc = [];\nfunction _DomainConnectivity_test_18_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.p, {\n      children: \"In this example we will generate cell to cell connectivity information between velocity-domain and velocity-Domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"Pressure domain consists \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"Triangle3\"\n        }), \" elements as shown below.\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"Velocity domain consists \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"Triangle6\"\n        }), \" elements as shown below.\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Importing modules and variables\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n  USE easifemBase\\n  USE easifemClasses\\n  IMPLICIT NONE\\n  TYPE(DomainConnectivity_) :: obj\\n  TYPE( Domain_ ) :: velocityDomain\\n  TYPE( HDF5File_ ) :: velocityMeshFile\\n  CLASS( Mesh_ ), POINTER :: velocityMesh\\n  CLASS( ReferenceElement_ ), POINTER :: refelem\\n  INTEGER( I4B ), POINTER :: cellToCell( : )\\n  INTEGER( I4B ) :: ii, iel\\n  INTEGER(I4B), PARAMETER :: dim1=2, dim2=2, entity1=1, entity2=1\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiate domain for velocity variable.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL velocityMeshFile%Initiate( FileName=\\\"./mesh_tri6.h5\\\", MODE=\\\"READ\\\" )\\nCALL velocityMeshFile%Open()\\nCALL velocityDomain%Initiate( velocityMeshFile, \\\"\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiate node to node DATA.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateNodeToNodeData( domain1=velocityDomain, &\\n  & domain2=velocityDomain )\\nCALL PASS(\\\"InitiateNodeToNodeData()\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This will create node to node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2).\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiate cell to cell connectivity DATA.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateCellToCellData(domain1=velocityDomain, &\\n  & domain2=velocityDomain)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"now let us run some tests, this is only for testing purpose, so you can ignore the forthcoming section.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"cellToCell => obj%getCellToCellPointer()\\nDO iel = velocityDomain%minElemNum, velocityDomain%maxElemNum\\n  IF (.NOT. velocityDomain%isElementPresent(iel)) CYCLE\\n  IF (cellToCell(iel) .EQ. 0) THEN\\n    velocityMesh => velocityDomain%getMeshPointer(globalElement=iel)\\n    refelem => velocityMesh%getRefElemPointer()\\n    IF (refelem%xidimension .EQ. velocityDomain%getNSD()) &\\n      & CALL fail(\\\"CellToCell: error code 1\\\")\\n  ELSE\\n    IF (cellToCell(iel) .NE. iel) THEN\\n      CALL fail(\\\"CellToCell: error code 2\\\")\\n      STOP\\n    END IF\\n  END IF\\nEND DO\\nCALL PASS(\\\"InitiateCellToCellData()\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"  CALL velocityMeshFile%Deallocate()\\n  CALL velocityDomain%Deallocate()\\n  CALL obj%Deallocate()\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _DomainConnectivity_test_18_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_18_createMdxContent, {\n      ...props\n    })\n  }) : _DomainConnectivity_test_18_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/DomainConnectivity/_DomainConnectivity_test_19.md\n\n\nconst _DomainConnectivity_test_19_frontMatter = {};\nconst _DomainConnectivity_test_19_contentTitle = undefined;\n\n\n\n\n\nconst _DomainConnectivity_test_19_toc = [];\nfunction _DomainConnectivity_test_19_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.p, {\n      children: \"In this example we will generate cell to cell connectivity information between velocity-domain and pressure-Domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Pressure domain consists Triangle3 elements as shown below.\"\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Velocity domain consists Triangle6 elements as shown below.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Importing modules and variables\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n  USE easifemBase\\n  USE easifemClasses\\n  IMPLICIT NONE\\n  TYPE(DomainConnectivity_) :: obj\\n  TYPE( Domain_ ) :: pressureDomain\\n  TYPE( Domain_ ) :: velocityDomain\\n  TYPE( HDF5File_ ) :: pressureMeshFile\\n  TYPE( HDF5File_ ) :: velocityMeshFile\\n  CLASS( Mesh_ ), POINTER :: velocityMesh\\n  CLASS( Mesh_ ), POINTER :: pressureMesh\\n  CLASS( ReferenceElement_ ), POINTER :: velocityRefelem\\n  CLASS( ReferenceElement_ ), POINTER :: pressureRefelem\\n  CLASS( ReferenceElement_ ), POINTER :: refelem\\n  INTEGER( I4B ), POINTER :: cellToCell( : )\\n  INTEGER( I4B ) :: ii, iel\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Open the mesh file for pressure and velocity domain\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL velocityMeshFile%Initiate( FileName=\\\"./mesh_tri6.h5\\\", MODE=\\\"READ\\\" )\\nCALL velocityMeshFile%Open()\\nCALL pressureMeshFile%Initiate( FileName=\\\"./mesh_tri3.h5\\\", MODE=\\\"READ\\\" )\\nCALL pressureMeshFile%Open()\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiate the domain for pressure and velocity\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL velocityDomain%Initiate( velocityMeshFile, \\\"\\\")\\nCALL pressureDomain%Initiate( pressureMeshFile, \\\"\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiate node to node data between velocity domain and pressure domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateNodeToNodeData( domain1=velocityDomain, &\\n  & domain2=pressureDomain )\\nCALL PASS(\\\"InitiateNodeToNodeData()\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now that node-to-node data is ready, let us initiate cell to cell data from velocity domain to pressure domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateCellToCellData( domain1=velocityDomain, &\\n  & domain2=pressureDomain )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"now let us run some tests to check the validity of the data. This is only for testing purpose, so you can ignore the forthcoming section.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"cellToCell => obj%getCellToCellPointer()\\nDO iel = velocityDomain%minElemNum, velocityDomain%maxElemNum\\n  IF (.NOT. velocityDomain%isElementPresent(iel)) CYCLE\\n  IF (cellToCell(iel) .EQ. 0) THEN\\n    velocityMesh => velocityDomain%getMeshPointer(globalElement=iel)\\n    refelem => velocityMesh%getRefElemPointer()\\n    IF (refelem%xidimension .EQ. velocityDomain%getNSD()) THEN\\n      CALL fail(\\\"CellToCell: error code 1\\\")\\n      STOP\\n    END IF\\n  ELSE\\n    !! here i am checking if the cellToCell(iel) is present in\\n    !! in the pressure domain or not.\\n    !! If it is present then it should be a cell element.\\n    ii = cellToCell(iel)\\n    IF (.NOT. pressureDomain%isElementPresent(ii)) THEN\\n      CALL fail(\\\"CellToCell: error code 2\\\")\\n      STOP\\n    ELSE\\n      velocityMesh => velocityDomain%getMeshPointer(globalElement=iel)\\n      velocityRefelem => velocityMesh%getRefElemPointer()\\n      pressureMesh => pressureDomain%getMeshPointer(globalElement=ii)\\n      pressureRefelem => pressureMesh%getRefElemPointer()\\n      IF (pressureRefelem%xidimension .NE. velocityRefelem%xidimension) THEN\\n        CALL fail(\\\"CellToCell: error code 3\\\")\\n        STOP\\n      END IF\\n    END IF\\n  END IF\\nEND DO\\nCALL PASS(\\\"InitiateCellToCellData()\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"  CALL pressureMeshFile%Deallocate()\\n  CALL velocityMeshFile%Deallocate()\\n  CALL pressureDomain%Deallocate()\\n  CALL velocityDomain%Deallocate()\\n  CALL obj%Deallocate()\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _DomainConnectivity_test_19_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_19_createMdxContent, {\n      ...props\n    })\n  }) : _DomainConnectivity_test_19_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/DomainConnectivity/_DomainConnectivity_test_20.md\n\n\nconst _DomainConnectivity_test_20_frontMatter = {};\nconst _DomainConnectivity_test_20_contentTitle = undefined;\n\n\n\n\n\nconst _DomainConnectivity_test_20_toc = [];\nfunction _DomainConnectivity_test_20_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.p, {\n      children: \"In this example we will generate cell to cell connectivity information between pressure-domain and velocity-Domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"Pressure domain consists \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"Triangle3\"\n        }), \" elements as shown below.\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"Velocity domain consists \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"Triangle6\"\n        }), \" elements as shown below.\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Importing modules and variables\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n  USE easifemBase\\n  USE easifemClasses\\n  IMPLICIT NONE\\n  TYPE(DomainConnectivity_) :: obj\\n  TYPE( Domain_ ) :: pressureDomain\\n  TYPE( Domain_ ) :: velocityDomain\\n  TYPE( HDF5File_ ) :: pressureMeshFile\\n  TYPE( HDF5File_ ) :: velocityMeshFile\\n  CLASS( Mesh_ ), POINTER :: velocityMesh\\n  CLASS( Mesh_ ), POINTER :: pressureMesh\\n  CLASS( ReferenceElement_ ), POINTER :: refelem\\n  CLASS( ReferenceElement_ ), POINTER :: velocityRefelem\\n  CLASS( ReferenceElement_ ), POINTER :: pressureRefelem\\n  INTEGER( I4B ), POINTER :: cellToCell( : )\\n  INTEGER( I4B ) :: ii, iel\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Open the mesh file for pressure and velocity domain\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL velocityMeshFile%Initiate( FileName=\\\"./mesh_tri6.h5\\\", MODE=\\\"READ\\\" )\\nCALL velocityMeshFile%Open()\\nCALL pressureMeshFile%Initiate( FileName=\\\"./mesh_tri3.h5\\\", MODE=\\\"READ\\\" )\\nCALL pressureMeshFile%Open()\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiate the domain for pressure and velocity\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL velocityDomain%Initiate( velocityMeshFile, \\\"\\\")\\nCALL pressureDomain%Initiate( pressureMeshFile, \\\"\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Initiate node to node data between velocity domain and pressure domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateNodeToNodeData( domain1=pressureDomain, &\\n  & domain2=velocityDomain )\\nCALL PASS(\\\"InitiateNodeToNodeData()\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now that node-to-node data is ready, let us initiate cell to cell data from pressure domain to velocity domain.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL obj%InitiateCellToCellData( domain1=pressureDomain, &\\n  & domain2=velocityDomain )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"now let us run some tests to check the validity of the data. This is only for testing purpose, so you can ignore the forthcoming section.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"cellToCell => obj%getCellToCellPointer()\\nDO iel = pressureDomain%minElemNum, pressureDomain%maxElemNum\\n  IF (.NOT. pressureDomain%isElementPresent(iel)) CYCLE\\n  IF (cellToCell(iel) .EQ. 0) THEN\\n    pressureMesh => pressureDomain%getMeshPointer(globalElement=iel)\\n    refelem => pressureMesh%getRefElemPointer()\\n    IF (refelem%xidimension .EQ. pressureDomain%getNSD()) THEN\\n      CALL fail(\\\"CellToCell: error code 1\\\")\\n      STOP\\n    END IF\\n  ELSE\\n    !! here i am checking if the cellToCell(iel) is present in\\n    !! in the pressure domain or not.\\n    !! If it is present then it should be a cell element.\\n    ii = cellToCell(iel)\\n    IF (.NOT. velocityDomain%isElementPresent(ii)) THEN\\n      CALL fail(\\\"CellToCell: error code 2\\\")\\n      STOP\\n    ELSE\\n      velocityMesh => velocityDomain%getMeshPointer(globalElement=ii)\\n      velocityRefelem => velocityMesh%getRefElemPointer()\\n      pressureMesh => pressureDomain%getMeshPointer(globalElement=iel)\\n      pressureRefelem => pressureMesh%getRefElemPointer()\\n      IF (pressureRefelem%xidimension .NE. velocityRefelem%xidimension) THEN\\n        CALL fail(\\\"CellToCell: error code 3\\\")\\n        STOP\\n      END IF\\n    END IF\\n  END IF\\nEND DO\\nCALL PASS(\\\"InitiateCellToCellData()\\\")\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"  CALL pressureMeshFile%Deallocate()\\n  CALL velocityMeshFile%Deallocate()\\n  CALL pressureDomain%Deallocate()\\n  CALL velocityDomain%Deallocate()\\n  CALL obj%Deallocate()\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _DomainConnectivity_test_20_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_20_createMdxContent, {\n      ...props\n    })\n  }) : _DomainConnectivity_test_20_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/DomainConnectivity/InitiateCellToCellData.md\n\n\nconst InitiateCellToCellData_frontMatter = {};\nconst InitiateCellToCellData_contentTitle = 'InitiateCellToCellData';\n\nconst assets = {\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst InitiateCellToCellData_toc = [{\n  \"value\": \"Interface1\",\n  \"id\": \"interface1\",\n  \"level\": 2\n}, ...toc, ..._DomainConnectivity_test_12_toc, ..._DomainConnectivity_test_13_toc, ..._DomainConnectivity_test_14_toc, ..._DomainConnectivity_test_15_toc, ..._DomainConnectivity_test_16_toc, ..._DomainConnectivity_test_17_toc, ..._DomainConnectivity_test_18_toc, {\n  \"value\": \"Interface2\",\n  \"id\": \"interface2\",\n  \"level\": 2\n}, ..._DomainConnectivity_test_19_toc, ..._DomainConnectivity_test_20_toc];\nfunction InitiateCellToCellData_createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    admonition: \"admonition\",\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    header: \"header\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.header, {\n      children: (0,jsx_runtime.jsx)(_components.h1, {\n        id: \"initiatecelltocelldata\",\n        children: \"InitiateCellToCellData\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [\"This routine initiates cellToCell data (mapping) between two \", (0,jsx_runtime.jsx)(_components.a, {\n        href: \"/docs-api/Domain/Domain_\",\n        children: \"Domain_\"\n      }), \" or \", (0,jsx_runtime.jsx)(_components.a, {\n        href: \"/docs-api/Mesh/Mesh_\",\n        children: \"Mesh_\"\n      }), \".\"]\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"The topology of elements in both meshes should be the same, this means that if one mesh is made of triangles then other mesh should be made of triangles.\"\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"The \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"xidim\"\n        }), \" of the elements in both meshes should be the same, this means that if the \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"mesh1\"\n        }), \" is surface mesh then \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"mesh2\"\n        }), \" should be a surface mesh.\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"This routine needs \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"nodeToNode\"\n        }), \" information, so make sure it is initiated before calling this routine.\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"interface1\",\n      children: \"Interface1\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"INTERFACE\\n  MODULE SUBROUTINE dc_initiateCellToCellData1(obj, domain1, domain2, &\\n    & dim1, dim2, entityNum1, entityNum2)\\n    CLASS(DomainConnectivity_), INTENT(INOUT) :: obj\\n    !! Domain connectivity object,\\n    !! [[DomainConnectivity:cellToCell]] will be initiated\\n    CLASS(Domain_), INTENT(IN) :: domain1\\n    !! Primary domain, in cellToCell(i), i denotes the\\n    !! global element number in domain1 domain.\\n    CLASS(Domain_), INTENT(IN) :: domain2\\n    !! secondary domain, => cellToCell(i) denotes the\\n    !! global cell number in `domain2` domain.\\n    INTEGER(I4B), INTENT(IN) :: dim1\\n    !! dimension of mesh in domain1\\n    INTEGER(I4B), INTENT(IN) :: dim2\\n    !! dimension of mesh in domain2\\n    INTEGER(I4B), INTENT(IN) :: entityNum1\\n    !! entity num of mesh in domain1\\n    INTEGER(I4B), INTENT(IN) :: entityNum2\\n    !! entity num of mesh in domain2\\n  END SUBROUTINE dc_initiateCellToCellData1\\nEND INTERFACE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine generates the cell to cell connectivity between two meshes.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"obj%cellToCell\"\n        }), \" will be initiated\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"domain1\"\n        }), \" main domain\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"domain2\"\n        }), \" secondary domain\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"dim1, entitynum1\"\n        }), \" dimension and entity number of mesh in \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"domain1\"\n        })]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"dim2, entitynum2\"\n        }), \" dimension and entity number of mesh in \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"domain2\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Following points should be noted\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"The topology of elements in both meshes should be the same, this means that if one mesh is triangle then other mesh should be a triangle.\"\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"The xidim of the elements in both meshes should be the same, this means that if the mesh1 is surface mesh then mesh2 should be a surface mesh.\"\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"This routine needs \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"nodeToNode\"\n        }), \" information, so make sure it is initiated before calling this routine.\"]\n      }), \"\\n\"]\n    }), \"\\n\", \"\\n\", (0,jsx_runtime.jsxs)(Tabs[\"default\"], {\n      children: [(0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"1\",\n        label: \"️܀ Example 1\",\n        children: (0,jsx_runtime.jsx)(MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"2\",\n        label: \"️܀ Example 2\",\n        children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_12_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"3\",\n        label: \"️܀ Example 3\",\n        children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_13_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"4\",\n        label: \"️܀ Example 4\",\n        children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_14_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"5\",\n        label: \"️܀ Example 5\",\n        children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_15_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"close\",\n        label: \"↢\",\n        default: true\n      })]\n    }), \"\\n\", (0,jsx_runtime.jsxs)(Tabs[\"default\"], {\n      children: [(0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"6\",\n        label: \"️܀ Example 6\",\n        children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_16_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"7\",\n        label: \"️܀ Example 7\",\n        children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_17_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"8\",\n        label: \"️܀ Example 8\",\n        children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_18_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"close\",\n        label: \"↢\",\n        default: true\n      })]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"interface2\",\n      children: \"Interface2\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"INTERFACE\\n  MODULE SUBROUTINE dc_InitiateCellToCellData2(obj, domain1, domain2)\\n    CLASS(DomainConnectivity_), INTENT(INOUT) :: obj\\n    !! Domain connectivity object\\n    CLASS(Domain_), INTENT(IN) :: domain1\\n    !! Primary domain, in CellToCell(i), i denotes the\\n    !! global element number in domain1 domain.\\n    CLASS(Domain_), INTENT(IN) :: domain2\\n    !! Secondary domain => CellToCell(i) denotes the\\n    !! global element number in domain2 domain.\\n  END SUBROUTINE dc_InitiateCellToCellData2\\nEND INTERFACE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine generates the cell to cell connectivity between\\ntwo domains.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"obj%cellToCell\"\n        }), \" will be initiated\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"domain1\"\n        }), \" main domain\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"domain2\"\n        }), \" secondary domain\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.admonition, {\n      type: \"note\",\n      children: (0,jsx_runtime.jsxs)(_components.p, {\n        children: [\"All \", (0,jsx_runtime.jsx)(_components.strong, {\n          children: \"CELL\"\n        }), \" elements in domain-1 will be mapped to \", (0,jsx_runtime.jsx)(_components.strong, {\n          children: \"CELL\"\n        }), \" elements in domain-2.\"]\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.admonition, {\n      type: \"info\",\n      children: (0,jsx_runtime.jsxs)(_components.p, {\n        children: [\"If \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"cellToCell(iel)\"\n        }), \" is equal to zero then it means there is no element found in domain-2 corresponding to element number iel in domain-1.\"]\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.admonition, {\n      type: \"note\",\n      children: (0,jsx_runtime.jsxs)(_components.p, {\n        children: [\"The size of \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"cellToCell\"\n        }), \" is the largest element number present in domain1.\"]\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.admonition, {\n      title: \"TODO\",\n      type: \"info\",\n      children: (0,jsx_runtime.jsx)(_components.p, {\n        children: \"Currently, lowerbound and upper bound of cellToCell is 1 and domain1%maxElemNumber. In the future, the lower bound will be domain1%minElemNumber.\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Following points should be noted before calling this routine\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"This routine provides map between cell elements of one domain to cell elements of another domain.\"\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"The topology of the both elements should be the same\"\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"There is one to one mapping between elements of domain 1 and elements of domain2\"\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"This routine works well for two domains of same region with same/different order. For example, domain of tri3 and domain of tri6 elements.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsxs)(Tabs[\"default\"], {\n      children: [(0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"1\",\n        label: \"️܀ Example 1\",\n        children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_19_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"2\",\n        label: \"️܀ Example 2\",\n        children: (0,jsx_runtime.jsx)(_DomainConnectivity_test_20_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"close\",\n        label: \"↢\",\n        default: true\n      })]\n    })]\n  });\n}\nfunction InitiateCellToCellData_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(InitiateCellToCellData_createMdxContent, {\n      ...props\n    })\n  }) : InitiateCellToCellData_createMdxContent(props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9kb2NzL2RvY3MtYXBpL0RvbWFpbkNvbm5lY3Rpdml0eS9Jbml0aWF0ZUNlbGxUb0NlbGxEYXRhLm1kIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzExLm1kP2VlYjMiLCJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzEyLm1kPzg2NzkiLCJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzEzLm1kPzM3Y2QiLCJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzE0Lm1kPzkyOTQiLCJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzE1Lm1kP2QxNGMiLCJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzE2Lm1kPzdjMjciLCJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzE3Lm1kP2MzMjMiLCJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzE4Lm1kPzVmZGEiLCJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzE5Lm1kP2U0ODQiLCJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzIwLm1kPzZjMmUiLCJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9Eb21haW5Db25uZWN0aXZpdHkvSW5pdGlhdGVDZWxsVG9DZWxsRGF0YS5tZD80ZDZhIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG5leHBvcnQgY29uc3QgZnJvbnRNYXR0ZXIgPSB7fTtcbmV4cG9ydCBjb25zdCBjb250ZW50VGl0bGUgPSB1bmRlZmluZWQ7XG5cblxuXG5pbXBvcnQge0ZyYWdtZW50IGFzIF9GcmFnbWVudCwganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHN9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHt1c2VNRFhDb21wb25lbnRzIGFzIF9wcm92aWRlQ29tcG9uZW50c30gZnJvbSBcIkBtZHgtanMvcmVhY3RcIjtcbmV4cG9ydCBjb25zdCB0b2MgPSBbXTtcbmZ1bmN0aW9uIF9jcmVhdGVNZHhDb250ZW50KHByb3BzKSB7XG4gIGNvbnN0IF9jb21wb25lbnRzID0ge1xuICAgIGNvZGU6IFwiY29kZVwiLFxuICAgIGxpOiBcImxpXCIsXG4gICAgcDogXCJwXCIsXG4gICAgcHJlOiBcInByZVwiLFxuICAgIHVsOiBcInVsXCIsXG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkluIHRoaXMgZXhhbXBsZSB3ZSB3aWxsIGdlbmVyYXRlIGNlbGwgdG8gY2VsbCBjb25uZWN0aXZpdHkgaW5mb3JtYXRpb24gYmV0d2VlbiBwYXJ0IG9mIHByZXNzdXJlLWRvbWFpbiBhbmQgcGFydCBvZiBwcmVzc3VyZS1Eb21haW4uXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJkaW0xPTIsIGVudGl0eT0xXCJcbiAgICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImRpbTI9MiwgZW50aXR5PTFcIlxuICAgICAgfSksIFwiXFxuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiUHJlc3N1cmUgZG9tYWluIGNvbnNpc3RzIFRyaWFuZ2xlMyBlbGVtZW50cyBhcyBzaG93biBiZWxvdy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQUk9HUkFNIG1haW5cXG4gIFVTRSBlYXNpZmVtQmFzZVxcbiAgVVNFIGVhc2lmZW1DbGFzc2VzXFxuICBJTVBMSUNJVCBOT05FXFxuICBUWVBFKERvbWFpbkNvbm5lY3Rpdml0eV8pIDo6IG9ialxcbiAgVFlQRSggRG9tYWluXyApIDo6IHByZXNzdXJlRG9tYWluXFxuICBUWVBFKCBIREY1RmlsZV8gKSA6OiBwcmVzc3VyZU1lc2hGaWxlXFxuICBDTEFTUyggTWVzaF8gKSwgUE9JTlRFUiA6OiBwcmVzc3VyZU1lc2ggPT4gTlVMTCgpXFxuICBJTlRFR0VSKCBJNEIgKSwgUE9JTlRFUiA6OiBjZWxsVG9DZWxsKCA6ICkgPT4gTlVMTCgpXFxuICBJTlRFR0VSKCBJNEIgKSA6OiBpaVxcbiAgSU5URUdFUihpNGIpIDo6IGRpbTE9MiwgZGltMj0yLCBlbnRpdHkxPTEsIGVudGl0eTI9MVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkNyZWF0ZSBkb21haW4gZm9yIHByZXNzdXJlIHZhcmlhYmxlcywgUkVBRCB0aGUgbWVzaCBmaWxlLCBhbmQgaW5pdGlhdGVzIHRoZSBkb21haW4gZm9yIHByZXNzdXJlXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBwcmVzc3VyZU1lc2hGaWxlJUluaXRpYXRlKCBGaWxlTmFtZT1cXFwiLi9tZXNoX3RyaTMuaDVcXFwiLCBNT0RFPVxcXCJSRUFEXFxcIiApXFxuQ0FMTCBwcmVzc3VyZU1lc2hGaWxlJU9wZW4oKVxcbkNBTEwgcHJlc3N1cmVEb21haW4lSW5pdGlhdGUoIHByZXNzdXJlTWVzaEZpbGUsIFxcXCJcXFwiKVxcbkNBTEwgcHJlc3N1cmVNZXNoRmlsZSVEZWFsbG9jYXRlKClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbml0aWF0ZXMgdGhlIG5vZGUgdG8gbm9kZSBjb25uZWN0aXZpdHkgREFUQS4gSXQgaXMgaW1wb3J0YW50IHRoYXQgd2UgaW5pdGlhdGUgdGhlIG5vZGUgdG8gbm9kZSBEQVRBIGJlZm9yZSBpbml0aWF0aW5nIGNlbGwgdG8gY2VsbCBEQVRBLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgb2JqJUluaXRpYXRlTm9kZVRvTm9kZURhdGEoIGRvbWFpbjE9cHJlc3N1cmVEb21haW4sICZcXG4gICYgZG9tYWluMj1wcmVzc3VyZURvbWFpbiwgZGltMT1kaW0xLCBlbnRpdHlOdW0xPWVudGl0eTEsIGRpbTI9ZGltMiwgJlxcbiAgJiBlbnRpdHlOdW0yPWVudGl0eTIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyB3aWxsIGNyZWF0ZSBub2RlLXRvLW5vZGUgY29ubmVjdGl2aXR5IERBVEEgZnJvbSBkb21haW4xIChkaW09MiwgZW50aXR5TnVtPTEpIHRvIGRvbWFpbjIgKGRpbT0yLCBlbnRpdHlOdW09MikuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJOb3cgd2UgY2FuIGluaXRpYXRlIGNlbGwtdG8tY2VsbCBEQVRBIGJldHdlZW4gdGhlIGFib3ZlIG1lbnRpb25lZCBtZXNoZXMuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBvYmolSW5pdGlhdGVDZWxsVG9DZWxsRGF0YSggZG9tYWluMT1wcmVzc3VyZURvbWFpbiwgJlxcbiAgJiBkb21haW4yPXByZXNzdXJlRG9tYWluLCBkaW0xPWRpbTEsIGVudGl0eU51bTE9ZW50aXR5MSwgZGltMj1kaW0yLCAmXFxuICAmIGVudGl0eU51bTI9ZW50aXR5MilcXG5DQUxMIERpc3BsYXkoXFxcIlN1Y2Nlc3MhIVxcXCIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiTm93IGxldCB1cyBydW4gc29tZSBjaGVja3Mgb24gdGhlIHJlc3VsdHMuIFRoaXMgaXMgT05MWSBmb3IgdGhlIHRlc3RpbmcgcHVycG9zZS4gSUYgeW91IHdhbnQsIHlvdSBjYW4gc2tpcCB0aGlzIHBhcnQsIGFuZCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGV4YW1wbGVzLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcImNlbGxUb0NlbGwgPT4gb2JqJWdldENlbGxUb0NlbGxQb2ludGVyKClcXG5wcmVzc3VyZU1lc2ggPT4gcHJlc3N1cmVEb21haW4lZ2V0TWVzaFBvaW50ZXIoZGltPWRpbTEsICZcXG4gICYgZW50aXR5TnVtPWVudGl0eTEpXFxuRE8gaWkgPSBwcmVzc3VyZU1lc2glbWluRWxlbU51bSwgcHJlc3N1cmVNZXNoJW1heEVsZW1OdW1cXG4gIElGICguTk9ULiBwcmVzc3VyZU1lc2glaXNFbGVtZW50UHJlc2VudChpaSkpIENZQ0xFXFxuICBJRiAoY2VsbFRvQ2VsbChpaSkgLk5FLiBpaSkgVEhFTlxcbiAgICBDQUxMIEZBSUwoXFxcIkRvbWFpbkNvbm5lY3Rpdml0eS10ZXN0IGhhcyBmYWlsZWRcXFwiKVxcbiAgICBTVE9QXFxuICBFTkQgSUZcXG5FTkQgRE9cXG5DQUxMIFBBU1MoXFxcIkRvbWFpbkNvbm5lY3Rpdml0eS10ZXN0LTExIGhhcyBwYXNzZWRcXFwiKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkNsZWFuaW5nIHVwLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIiAgQ0FMTCBwcmVzc3VyZURvbWFpbiVEZWFsbG9jYXRlKClcXG4gIENBTEwgb2JqJURlYWxsb2NhdGUoKVxcbkVORCBQUk9HUkFNIG1haW5cXG5cIlxuICAgICAgfSlcbiAgICB9KV1cbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzID0ge30pIHtcbiAgY29uc3Qge3dyYXBwZXI6IE1EWExheW91dH0gPSB7XG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gTURYTGF5b3V0ID8gX2pzeChNRFhMYXlvdXQsIHtcbiAgICAuLi5wcm9wcyxcbiAgICBjaGlsZHJlbjogX2pzeChfY3JlYXRlTWR4Q29udGVudCwge1xuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICB9KSA6IF9jcmVhdGVNZHhDb250ZW50KHByb3BzKTtcbn1cblxuIiwiXG5cbmV4cG9ydCBjb25zdCBmcm9udE1hdHRlciA9IHt9O1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUaXRsZSA9IHVuZGVmaW5lZDtcblxuXG5cbmltcG9ydCB7RnJhZ21lbnQgYXMgX0ZyYWdtZW50LCBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4c30gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQge3VzZU1EWENvbXBvbmVudHMgYXMgX3Byb3ZpZGVDb21wb25lbnRzfSBmcm9tIFwiQG1keC1qcy9yZWFjdFwiO1xuZXhwb3J0IGNvbnN0IHRvYyA9IFtdO1xuZnVuY3Rpb24gX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpIHtcbiAgY29uc3QgX2NvbXBvbmVudHMgPSB7XG4gICAgY29kZTogXCJjb2RlXCIsXG4gICAgcDogXCJwXCIsXG4gICAgcHJlOiBcInByZVwiLFxuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIF9qc3hzKF9GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbiB0aGlzIGV4YW1wbGUgd2Ugd2lsbCBnZW5lcmF0ZSBjZWxsIHRvIGNlbGwgY29ubmVjdGl2aXR5IGluZm9ybWF0aW9uIGJldHdlZW4gcGFydCBvZiB2ZWxvY2l0eS1kb21haW4gYW5kIHBhcnQgb2YgdmVsb2NpdHktRG9tYWluLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVmVsb2NpdHkgZG9tYWluIGNvbnNpc3RzIFRyaWFuZ2xlNiBlbGVtZW50cyBhcyBzaG93biBiZWxvdy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQUk9HUkFNIG1haW5cXG4gIFVTRSBlYXNpZmVtQmFzZVxcbiAgVVNFIGVhc2lmZW1DbGFzc2VzXFxuICBJTVBMSUNJVCBOT05FXFxuICBUWVBFKERvbWFpbkNvbm5lY3Rpdml0eV8pIDo6IG9ialxcbiAgVFlQRSggRG9tYWluXyApIDo6IHZlbG9jaXR5RG9tYWluXFxuICBUWVBFKCBIREY1RmlsZV8gKSA6OiB2ZWxvY2l0eU1lc2hGaWxlXFxuICBDTEFTUyggTWVzaF8gKSwgUE9JTlRFUiA6OiB2ZWxvY2l0eU1lc2ggPT4gTlVMTCgpXFxuICBJTlRFR0VSKCBJNEIgKSwgUE9JTlRFUiA6OiBjZWxsVG9DZWxsKCA6ICkgPT4gTlVMTCgpXFxuICBJTlRFR0VSKCBJNEIgKSA6OiBpaVxcbiAgSU5URUdFUihpNGIpIDo6IGRpbTE9MiwgZGltMj0yLCBlbnRpdHkxPTEsIGVudGl0eTI9MVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkNyZWF0ZSBkb21haW4gZm9yIHZlbG9jaXR5IHZhcmlhYmxlcywgUkVBRCB0aGUgbWVzaCBmaWxlLCBhbmQgaW5pdGlhdGVzIHRoZSBkb21haW4gZm9yIHByZXNzdXJlXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCB2ZWxvY2l0eU1lc2hGaWxlJUluaXRpYXRlKCBGaWxlTmFtZT1cXFwiLi9tZXNoX3RyaTYuaDVcXFwiLCBNT0RFPVxcXCJSRUFEXFxcIiApXFxuQ0FMTCB2ZWxvY2l0eU1lc2hGaWxlJU9wZW4oKVxcbkNBTEwgdmVsb2NpdHlEb21haW4lSW5pdGlhdGUoIHZlbG9jaXR5TWVzaEZpbGUsIFxcXCJcXFwiKVxcbkNBTEwgdmVsb2NpdHlNZXNoRmlsZSVEZWFsbG9jYXRlKClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbml0aWF0ZXMgdGhlIG5vZGUgdG8gbm9kZSBjb25uZWN0aXZpdHkgREFUQS4gSXQgaXMgaW1wb3J0YW50IHRoYXQgd2UgaW5pdGlhdGUgdGhlIG5vZGUgdG8gbm9kZSBEQVRBIGJlZm9yZSBpbml0aWF0aW5nIGNlbGwgdG8gY2VsbCBEQVRBLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgb2JqJUluaXRpYXRlTm9kZVRvTm9kZURhdGEoIGRvbWFpbjE9dmVsb2NpdHlEb21haW4sICZcXG4gICYgZG9tYWluMj12ZWxvY2l0eURvbWFpbiwgZGltMT1kaW0xLCBlbnRpdHlOdW0xPWVudGl0eTEsIGRpbTI9ZGltMiwgJlxcbiAgJiBlbnRpdHlOdW0yPWVudGl0eTIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyB3aWxsIGNyZWF0ZSBub2RlLXRvLW5vZGUgY29ubmVjdGl2aXR5IERBVEEgZnJvbSBkb21haW4xIChkaW09MiwgZW50aXR5TnVtPTEpIHRvIGRvbWFpbjIgKGRpbT0yLCBlbnRpdHlOdW09MikuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJOb3cgd2UgY2FuIGluaXRpYXRlIGNlbGwtdG8tY2VsbCBEQVRBIGJldHdlZW4gdGhlIGFib3ZlIG1lbnRpb25lZCBtZXNoZXMuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBvYmolSW5pdGlhdGVDZWxsVG9DZWxsRGF0YSggZG9tYWluMT12ZWxvY2l0eURvbWFpbiwgJlxcbiAgJiBkb21haW4yPXZlbG9jaXR5RG9tYWluLCBkaW0xPWRpbTEsIGVudGl0eU51bTE9ZW50aXR5MSwgZGltMj1kaW0yLCAmXFxuICAmIGVudGl0eU51bTI9ZW50aXR5MilcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJOb3cgbGV0IHVzIHJ1biBzb21lIGNoZWNrcyBvbiB0aGUgcmVzdWx0cy4gVGhpcyBpcyBPTkxZIGZvciB0aGUgdGVzdGluZyBwdXJwb3NlLiBJRiB5b3Ugd2FudCwgeW91IGNhbiBza2lwIHRoaXMgcGFydCwgYW5kIG1vdmUgb24gdG8gdGhlIG5leHQgZXhhbXBsZXMuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiY2VsbFRvQ2VsbCA9PiBvYmolZ2V0Q2VsbFRvQ2VsbFBvaW50ZXIoKVxcbnZlbG9jaXR5TWVzaCA9PiB2ZWxvY2l0eURvbWFpbiVnZXRNZXNoUG9pbnRlcihkaW09ZGltMSwgJlxcbiAgJiBlbnRpdHlOdW09ZW50aXR5MSlcXG5ETyBpaSA9IHZlbG9jaXR5TWVzaCVtaW5FbGVtTnVtLCB2ZWxvY2l0eU1lc2glbWF4RWxlbU51bVxcbiAgSUYgKC5OT1QuIHZlbG9jaXR5TWVzaCVpc0VsZW1lbnRQcmVzZW50KGlpKSkgQ1lDTEVcXG4gIElGIChjZWxsVG9DZWxsKGlpKSAuTkUuIGlpKSBUSEVOXFxuICAgIENBTEwgRkFJTChcXFwiRG9tYWluQ29ubmVjdGl2aXR5LXRlc3QgaGFzIGZhaWxlZFxcXCIpXFxuICAgIFNUT1BcXG4gIEVORCBJRlxcbkVORCBET1xcbkNBTEwgUEFTUyhcXFwiRG9tYWluQ29ubmVjdGl2aXR5LXRlc3QgaGFzIHBhc3NlZFxcXCIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiQ2xlYW5pbmcgdXAuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiICBDQUxMIHZlbG9jaXR5RG9tYWluJURlYWxsb2NhdGUoKVxcbiAgQ0FMTCBvYmolRGVhbGxvY2F0ZSgpXFxuRU5EIFBST0dSQU0gbWFpblxcblwiXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMgPSB7fSkge1xuICBjb25zdCB7d3JhcHBlcjogTURYTGF5b3V0fSA9IHtcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBNRFhMYXlvdXQgPyBfanN4KE1EWExheW91dCwge1xuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiBfanN4KF9jcmVhdGVNZHhDb250ZW50LCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gIH0pIDogX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpO1xufVxuXG4iLCJcblxuZXhwb3J0IGNvbnN0IGZyb250TWF0dGVyID0ge307XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gdW5kZWZpbmVkO1xuXG5cblxuaW1wb3J0IHtGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7dXNlTURYQ29tcG9uZW50cyBhcyBfcHJvdmlkZUNvbXBvbmVudHN9IGZyb20gXCJAbWR4LWpzL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgdG9jID0gW107XG5mdW5jdGlvbiBfY3JlYXRlTWR4Q29udGVudChwcm9wcykge1xuICBjb25zdCBfY29tcG9uZW50cyA9IHtcbiAgICBjb2RlOiBcImNvZGVcIixcbiAgICBsaTogXCJsaVwiLFxuICAgIHA6IFwicFwiLFxuICAgIHByZTogXCJwcmVcIixcbiAgICB1bDogXCJ1bFwiLFxuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIF9qc3hzKF9GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbiB0aGlzIGV4YW1wbGUgd2Ugd2lsbCBnZW5lcmF0ZSBjZWxsIHRvIGNlbGwgY29ubmVjdGl2aXR5IGluZm9ybWF0aW9uIGJldHdlZW4gcGFydCBvZiBwcmVzc3VyZS1kb21haW4gYW5kIHBhcnQgb2YgcHJlc3N1cmUtRG9tYWluLiBXZSB3aWxsIG1hcCBib3VuZGFyeSBvZiBhIGRvbWFpbiB3aXRoIHRoZSBib3VuZGFyeSBvZiB0aGUgb3RoZXIgZG9tYWluXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJQcmVzc3VyZSBkb21haW4gY29uc2lzdHMgVHJpYW5nbGUzIGVsZW1lbnRzIGFzIHNob3duIGJlbG93LlwiXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJWZWxvY2l0eSBkb21haW4gY29uc2lzdHMgVHJpYW5nbGU2IGVsZW1lbnRzIGFzIHNob3duIGJlbG93LlwiXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbXBvcnRpbmcgbW9kdWxlcyBhbmQgdmFyaWFibGVzXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFJPR1JBTSBtYWluXFxuICBVU0UgZWFzaWZlbUJhc2VcXG4gIFVTRSBlYXNpZmVtQ2xhc3Nlc1xcbiAgSU1QTElDSVQgTk9ORVxcbiAgVFlQRShEb21haW5Db25uZWN0aXZpdHlfKSA6OiBvYmpcXG4gIFRZUEUoIERvbWFpbl8gKSA6OiBwcmVzc3VyZURvbWFpblxcbiAgVFlQRSggSERGNUZpbGVfICkgOjogcHJlc3N1cmVNZXNoRmlsZVxcbiAgQ0xBU1MoIE1lc2hfICksIFBPSU5URVIgOjogcHJlc3N1cmVNZXNoID0+IE5VTEwoKVxcbiAgSU5URUdFUiggSTRCICksIFBPSU5URVIgOjogY2VsbFRvQ2VsbCggOiApID0+IE5VTEwoKVxcbiAgSU5URUdFUiggSTRCICkgOjogaWlcXG4gIElOVEVHRVIoaTRiKSA6OiBkaW0xPTEsIGRpbTI9MSwgZW50aXR5MT0xLCBlbnRpdHkyPTFcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJDcmVhdGUgZG9tYWluIGZvciBwcmVzc3VyZSB2YXJpYWJsZXMsIFJFQUQgdGhlIG1lc2ggZmlsZSwgYW5kIGluaXRpYXRlcyB0aGUgZG9tYWluIGZvciBwcmVzc3VyZVwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgcHJlc3N1cmVNZXNoRmlsZSVJbml0aWF0ZSggRmlsZU5hbWU9XFxcIi4vbWVzaF90cmkzLmg1XFxcIiwgTU9ERT1cXFwiUkVBRFxcXCIgKVxcbkNBTEwgcHJlc3N1cmVNZXNoRmlsZSVPcGVuKClcXG5DQUxMIHByZXNzdXJlRG9tYWluJUluaXRpYXRlKCBwcmVzc3VyZU1lc2hGaWxlLCBcXFwiXFxcIilcXG5DQUxMIHByZXNzdXJlTWVzaEZpbGUlRGVhbGxvY2F0ZSgpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSW5pdGlhdGVzIHRoZSBub2RlIHRvIG5vZGUgY29ubmVjdGl2aXR5IERBVEEuIEl0IGlzIGltcG9ydGFudCB0aGF0IHdlIGluaXRpYXRlIHRoZSBub2RlIHRvIG5vZGUgREFUQSBiZWZvcmUgaW5pdGlhdGluZyBjZWxsIHRvIGNlbGwgREFUQS5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIG9iaiVJbml0aWF0ZU5vZGVUb05vZGVEYXRhKCBkb21haW4xPXByZXNzdXJlRG9tYWluLCAmXFxuICAmIGRvbWFpbjI9cHJlc3N1cmVEb21haW4sIGRpbTE9ZGltMSwgZW50aXR5TnVtMT1lbnRpdHkxLCBkaW0yPWRpbTIsICZcXG4gICYgZW50aXR5TnVtMj1lbnRpdHkyKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgd2lsbCBjcmVhdGUgbm9kZS10by1ub2RlIGNvbm5lY3Rpdml0eSBEQVRBIGZyb20gZG9tYWluMSAoZGltPTIsIGVudGl0eU51bT0xKSB0byBkb21haW4yIChkaW09MiwgZW50aXR5TnVtPTIpLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiTm93IHdlIGNhbiBpbml0aWF0ZSBjZWxsLXRvLWNlbGwgREFUQSBiZXR3ZWVuIHRoZSBhYm92ZSBtZW50aW9uZWQgbWVzaGVzLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgb2JqJUluaXRpYXRlQ2VsbFRvQ2VsbERhdGEoIGRvbWFpbjE9cHJlc3N1cmVEb21haW4sICZcXG4gICYgZG9tYWluMj1wcmVzc3VyZURvbWFpbiwgZGltMT1kaW0xLCBlbnRpdHlOdW0xPWVudGl0eTEsIGRpbTI9ZGltMiwgJlxcbiAgJiBlbnRpdHlOdW0yPWVudGl0eTIpXFxuQ0FMTCBEaXNwbGF5KFxcXCJTdWNjZXNzISFcXFwiKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk5vdyBsZXQgdXMgcnVuIHNvbWUgY2hlY2tzIG9uIHRoZSByZXN1bHRzLiBUaGlzIGlzIE9OTFkgZm9yIHRoZSB0ZXN0aW5nIHB1cnBvc2UuIElGIHlvdSB3YW50LCB5b3UgY2FuIHNraXAgdGhpcyBwYXJ0LCBhbmQgbW92ZSBvbiB0byB0aGUgbmV4dCBleGFtcGxlcy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJjZWxsVG9DZWxsID0+IG9iaiVnZXRDZWxsVG9DZWxsUG9pbnRlcigpXFxucHJlc3N1cmVNZXNoID0+IHByZXNzdXJlRG9tYWluJWdldE1lc2hQb2ludGVyKGRpbT1kaW0xLCAmXFxuICAmIGVudGl0eU51bT1lbnRpdHkxKVxcbkRPIGlpID0gcHJlc3N1cmVNZXNoJW1pbkVsZW1OdW0sIHByZXNzdXJlTWVzaCVtYXhFbGVtTnVtXFxuICBJRiAoLk5PVC4gcHJlc3N1cmVNZXNoJWlzRWxlbWVudFByZXNlbnQoaWkpKSBDWUNMRVxcbiAgSUYgKGNlbGxUb0NlbGwoaWkpIC5ORS4gaWkpIFRIRU5cXG4gICAgQ0FMTCBGQUlMKFxcXCJEb21haW5Db25uZWN0aXZpdHktdGVzdC0xMSBoYXMgZmFpbGVkXFxcIilcXG4gICAgU1RPUFxcbiAgRU5EIElGXFxuRU5EIERPXFxuQ0FMTCBQQVNTKFxcXCJEb21haW5Db25uZWN0aXZpdHktdGVzdCBoYXMgcGFzc2VkXFxcIilcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJDbGVhbmluZyB1cC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCIgIENBTEwgcHJlc3N1cmVEb21haW4lRGVhbGxvY2F0ZSgpXFxuICBDQUxMIG9iaiVEZWFsbG9jYXRlKClcXG5FTkQgUFJPR1JBTSBtYWluXFxuXCJcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTURYQ29udGVudChwcm9wcyA9IHt9KSB7XG4gIGNvbnN0IHt3cmFwcGVyOiBNRFhMYXlvdXR9ID0ge1xuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIE1EWExheW91dCA/IF9qc3goTURYTGF5b3V0LCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IF9qc3goX2NyZWF0ZU1keENvbnRlbnQsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSlcbiAgfSkgOiBfY3JlYXRlTWR4Q29udGVudChwcm9wcyk7XG59XG5cbiIsIlxuXG5leHBvcnQgY29uc3QgZnJvbnRNYXR0ZXIgPSB7fTtcbmV4cG9ydCBjb25zdCBjb250ZW50VGl0bGUgPSB1bmRlZmluZWQ7XG5cblxuXG5pbXBvcnQge0ZyYWdtZW50IGFzIF9GcmFnbWVudCwganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHN9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHt1c2VNRFhDb21wb25lbnRzIGFzIF9wcm92aWRlQ29tcG9uZW50c30gZnJvbSBcIkBtZHgtanMvcmVhY3RcIjtcbmV4cG9ydCBjb25zdCB0b2MgPSBbXTtcbmZ1bmN0aW9uIF9jcmVhdGVNZHhDb250ZW50KHByb3BzKSB7XG4gIGNvbnN0IF9jb21wb25lbnRzID0ge1xuICAgIGNvZGU6IFwiY29kZVwiLFxuICAgIGxpOiBcImxpXCIsXG4gICAgcDogXCJwXCIsXG4gICAgcHJlOiBcInByZVwiLFxuICAgIHVsOiBcInVsXCIsXG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkluIHRoaXMgZXhhbXBsZSB3ZSB3aWxsIGdlbmVyYXRlIGNlbGwgdG8gY2VsbCBjb25uZWN0aXZpdHkgaW5mb3JtYXRpb24gYmV0d2VlbiBwYXJ0IG9mIHZlbG9jaXR5LWRvbWFpbiBhbmQgcGFydCBvZiB2ZWxvY2l0eS1Eb21haW4uXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtcIlByZXNzdXJlIGRvbWFpbiBjb25zaXN0cyBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiVHJpYW5nbGUzXCJcbiAgICAgICAgfSksIFwiIGVsZW1lbnRzIGFzIHNob3duIGJlbG93LlwiXVxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJWZWxvY2l0eSBkb21haW4gY29uc2lzdHMgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIlRyaWFuZ2xlNlwiXG4gICAgICAgIH0pLCBcIiBlbGVtZW50cyBhcyBzaG93biBiZWxvdy5cIl1cbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkltcG9ydGluZyBtb2R1bGVzIGFuZCB2YXJpYWJsZXNcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQUk9HUkFNIG1haW5cXG4gIFVTRSBlYXNpZmVtQmFzZVxcbiAgVVNFIGVhc2lmZW1DbGFzc2VzXFxuICBJTVBMSUNJVCBOT05FXFxuICBUWVBFKERvbWFpbkNvbm5lY3Rpdml0eV8pIDo6IG9ialxcbiAgVFlQRSggRG9tYWluXyApIDo6IHZlbG9jaXR5RG9tYWluXFxuICBUWVBFKCBIREY1RmlsZV8gKSA6OiB2ZWxvY2l0eU1lc2hGaWxlXFxuICBDTEFTUyggTWVzaF8gKSwgUE9JTlRFUiA6OiB2ZWxvY2l0eU1lc2ggPT4gTlVMTCgpXFxuICBJTlRFR0VSKCBJNEIgKSwgUE9JTlRFUiA6OiBjZWxsVG9DZWxsKCA6ICkgPT4gTlVMTCgpXFxuICBJTlRFR0VSKCBJNEIgKSA6OiBpaVxcbiAgSU5URUdFUihpNGIpIDo6IGRpbTE9MSwgZGltMj0xLCBlbnRpdHkxPTEsIGVudGl0eTI9MVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkNyZWF0ZSBkb21haW4gZm9yIHZlbG9jaXR5IHZhcmlhYmxlcywg8J+OhyBSRUFEIHRoZSBtZXNoIGZpbGUsIGFuZCDirZUgaW5pdGlhdGVzIHRoZSBkb21haW4gZm9yIHByZXNzdXJlXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCB2ZWxvY2l0eU1lc2hGaWxlJUluaXRpYXRlKCBGaWxlTmFtZT1cXFwiLi9tZXNoX3RyaTYuaDVcXFwiLCBNT0RFPVxcXCJSRUFEXFxcIiApXFxuQ0FMTCB2ZWxvY2l0eU1lc2hGaWxlJU9wZW4oKVxcbkNBTEwgdmVsb2NpdHlEb21haW4lSW5pdGlhdGUoIHZlbG9jaXR5TWVzaEZpbGUsIFxcXCJcXFwiKVxcbkNBTEwgdmVsb2NpdHlNZXNoRmlsZSVEZWFsbG9jYXRlKClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbml0aWF0ZXMgdGhlIG5vZGUgdG8gbm9kZSBjb25uZWN0aXZpdHkgREFUQS4gSXQgaXMgaW1wb3J0YW50IHRoYXQgd2UgaW5pdGlhdGUgdGhlIG5vZGUgdG8gbm9kZSBEQVRBIGJlZm9yZSBpbml0aWF0aW5nIGNlbGwgdG8gY2VsbCBEQVRBLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgb2JqJUluaXRpYXRlTm9kZVRvTm9kZURhdGEoIGRvbWFpbjE9dmVsb2NpdHlEb21haW4sICZcXG4gICYgZG9tYWluMj12ZWxvY2l0eURvbWFpbiwgZGltMT1kaW0xLCBlbnRpdHlOdW0xPWVudGl0eTEsIGRpbTI9ZGltMiwgJlxcbiAgJiBlbnRpdHlOdW0yPWVudGl0eTIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyB3aWxsIGNyZWF0ZSBub2RlLXRvLW5vZGUgY29ubmVjdGl2aXR5IERBVEEgZnJvbSBkb21haW4xIChkaW09MiwgZW50aXR5TnVtPTEpIHRvIGRvbWFpbjIgKGRpbT0yLCBlbnRpdHlOdW09MikuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJOb3cgd2UgY2FuIGluaXRpYXRlIGNlbGwtdG8tY2VsbCBEQVRBIGJldHdlZW4gdGhlIGFib3ZlIG1lbnRpb25lZCBtZXNoZXMuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBvYmolSW5pdGlhdGVDZWxsVG9DZWxsRGF0YSggZG9tYWluMT12ZWxvY2l0eURvbWFpbiwgJlxcbiAgJiBkb21haW4yPXZlbG9jaXR5RG9tYWluLCBkaW0xPWRpbTEsIGVudGl0eU51bTE9ZW50aXR5MSwgZGltMj1kaW0yLCAmXFxuICAmIGVudGl0eU51bTI9ZW50aXR5MilcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJOb3cgbGV0IHVzIHJ1biBzb21lIGNoZWNrcyBvbiB0aGUgcmVzdWx0cy4gVGhpcyBpcyBPTkxZIGZvciB0aGUgdGVzdGluZyBwdXJwb3NlLiBJRiB5b3Ugd2FudCwgeW91IGNhbiBza2lwIHRoaXMgcGFydCwgYW5kIG1vdmUgb24gdG8gdGhlIG5leHQgZXhhbXBsZXMuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiY2VsbFRvQ2VsbCA9PiBvYmolZ2V0Q2VsbFRvQ2VsbFBvaW50ZXIoKVxcbnZlbG9jaXR5TWVzaCA9PiB2ZWxvY2l0eURvbWFpbiVnZXRNZXNoUG9pbnRlcihkaW09ZGltMSwgJlxcbiAgJiBlbnRpdHlOdW09ZW50aXR5MSlcXG5ETyBpaSA9IHZlbG9jaXR5TWVzaCVtaW5FbGVtTnVtLCB2ZWxvY2l0eU1lc2glbWF4RWxlbU51bVxcbiAgSUYgKC5OT1QuIHZlbG9jaXR5TWVzaCVpc0VsZW1lbnRQcmVzZW50KGlpKSkgQ1lDTEVcXG4gIElGIChjZWxsVG9DZWxsKGlpKSAuTkUuIGlpKSBUSEVOXFxuICAgIENBTEwgRkFJTChcXFwiRG9tYWluQ29ubmVjdGl2aXR5LXRlc3QtMTEgaGFzIGZhaWxlZFxcXCIpXFxuICAgIFNUT1BcXG4gIEVORCBJRlxcbkVORCBET1xcbkNBTEwgUEFTUyhcXFwiRG9tYWluQ29ubmVjdGl2aXR5LXRlc3QgaGFzIHBhc3NlZFxcXCIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiQ2xlYW5pbmcgdXAuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiICBDQUxMIHZlbG9jaXR5RG9tYWluJURlYWxsb2NhdGUoKVxcbiAgQ0FMTCBvYmolRGVhbGxvY2F0ZSgpXFxuRU5EIFBST0dSQU0gbWFpblxcblwiXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMgPSB7fSkge1xuICBjb25zdCB7d3JhcHBlcjogTURYTGF5b3V0fSA9IHtcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBNRFhMYXlvdXQgPyBfanN4KE1EWExheW91dCwge1xuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiBfanN4KF9jcmVhdGVNZHhDb250ZW50LCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gIH0pIDogX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpO1xufVxuXG4iLCJcblxuZXhwb3J0IGNvbnN0IGZyb250TWF0dGVyID0ge307XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gdW5kZWZpbmVkO1xuXG5cblxuaW1wb3J0IHtGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7dXNlTURYQ29tcG9uZW50cyBhcyBfcHJvdmlkZUNvbXBvbmVudHN9IGZyb20gXCJAbWR4LWpzL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgdG9jID0gW107XG5mdW5jdGlvbiBfY3JlYXRlTWR4Q29udGVudChwcm9wcykge1xuICBjb25zdCBfY29tcG9uZW50cyA9IHtcbiAgICBjb2RlOiBcImNvZGVcIixcbiAgICBsaTogXCJsaVwiLFxuICAgIHA6IFwicFwiLFxuICAgIHByZTogXCJwcmVcIixcbiAgICB1bDogXCJ1bFwiLFxuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIF9qc3hzKF9GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbiB0aGlzIGV4YW1wbGUgd2Ugd2lsbCBzaG93IGhvdyB0byBVU0UgW1tEb21haW5Db25uZWN0aXZpdHlfI0luaXRpYXRlQ2VsbFRvQ2VsbF1dIG1ldGhvZCB0byBnZW5lcmF0ZSBjZWxsLXRvLWNlbGwgY29ubmVjdGl2aXR5IGluZm9ybWF0aW9uIGJldHdlZW4gcGFydCBvZiB2ZWxvY2l0eS1kb21haW4gYW5kIHBhcnQgb2YgcHJlc3N1cmUtRG9tYWluLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJQcmVzc3VyZSBkb21haW4gY29uc2lzdHMgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIlRyaWFuZ2xlM1wiXG4gICAgICAgIH0pLCBcIiBlbGVtZW50cyBhcyBzaG93biBiZWxvdy5cIl1cbiAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW1wiVmVsb2NpdHkgZG9tYWluIGNvbnNpc3RzIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJUcmlhbmdsZTZcIlxuICAgICAgICB9KSwgXCIgZWxlbWVudHMgYXMgc2hvd24gYmVsb3cuXCJdXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJTVBPUlQgbW9kdWxlcyBhbmQgY2xhc3Nlc1wiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlBST0dSQU0gbWFpblxcbiAgVVNFIGVhc2lmZW1CYXNlXFxuICBVU0UgZWFzaWZlbUNsYXNzZXNcXG4gIElNUExJQ0lUIE5PTkVcXG4gIFRZUEUoRG9tYWluQ29ubmVjdGl2aXR5XykgOjogb2JqXFxuICBUWVBFKCBEb21haW5fICkgOjogcHJlc3N1cmVEb21haW5cXG4gIFRZUEUoIERvbWFpbl8gKSA6OiB2ZWxvY2l0eURvbWFpblxcbiAgVFlQRSggSERGNUZpbGVfICkgOjogcHJlc3N1cmVNZXNoRmlsZVxcbiAgVFlQRSggSERGNUZpbGVfICkgOjogdmVsb2NpdHlNZXNoRmlsZVxcbiAgQ0xBU1MoIE1lc2hfICksIFBPSU5URVIgOjogdmVsb2NpdHlNZXNoXFxuICBDTEFTUyggTWVzaF8gKSwgUE9JTlRFUiA6OiBwcmVzc3VyZU1lc2hcXG4gIElOVEVHRVIoIEk0QiApLCBQT0lOVEVSIDo6IGNlbGxUb0NlbGwoIDogKVxcbiAgSU5URUdFUiggSTRCICkgOjogaWlcXG4gIElOVEVHRVIoaTRiKSwgUEFSQU1FVEVSIDo6IGRpbTE9MiwgZGltMj0yLCBlbnRpdHkxPTEsIGVudGl0eTI9MVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcImNyZWF0ZSBkb21haW4gZm9yIHZlbG9jaXR5IHZhcmlhYmxlcywg8J+OhyBSRUFEIHRoZSBtZXNoIGZpbGUsIGFuZCDirZUgaW5pdGlhdGVzIHRoZSBkb21haW4gZm9yIHByZXNzdXJlXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCB2ZWxvY2l0eU1lc2hGaWxlJUluaXRpYXRlKCBGaWxlTmFtZT1cXFwiLi9tZXNoX3RyaTYuaDVcXFwiLCBNT0RFPVxcXCJSRUFEXFxcIiApXFxuQ0FMTCB2ZWxvY2l0eU1lc2hGaWxlJU9wZW4oKVxcbkNBTEwgdmVsb2NpdHlEb21haW4lSW5pdGlhdGUoIHZlbG9jaXR5TWVzaEZpbGUsIFxcXCJcXFwiKVxcbkNBTEwgdmVsb2NpdHlNZXNoRmlsZSVEZWFsbG9jYXRlKClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJjcmVhdGUgZG9tYWluIGZvciBwcmVzc3VyZSB2YXJpYWJsZXMsIPCfjocgUkVBRCB0aGUgbWVzaCBmaWxlLCBhbmQg4q2VIGluaXRpYXRlcyB0aGUgZG9tYWluIGZvciBwcmVzc3VyZVwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgcHJlc3N1cmVNZXNoRmlsZSVJbml0aWF0ZSggRmlsZU5hbWU9XFxcIi4vbWVzaF90cmkzLmg1XFxcIiwgTU9ERT1cXFwiUkVBRFxcXCIgKVxcbkNBTEwgcHJlc3N1cmVNZXNoRmlsZSVPcGVuKClcXG5DQUxMIHByZXNzdXJlRG9tYWluJUluaXRpYXRlKCBwcmVzc3VyZU1lc2hGaWxlLCBcXFwiXFxcIilcXG5DQUxMIHByZXNzdXJlTWVzaEZpbGUlRGVhbGxvY2F0ZSgpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSW5pdGlhdGVzIHRoZSBub2RlIHRvIG5vZGUgY29ubmVjdGl2aXR5IERBVEEuIEl0IGlzIGltcG9ydGFudCB0aGF0IHdlIGluaXRpYXRlIHRoZSBub2RlIHRvIG5vZGUgREFUQSBiZWZvcmUgaW5pdGlhdGluZyBjZWxsIHRvIGNlbGwgREFUQS5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIG9iaiVJbml0aWF0ZU5vZGVUb05vZGVEYXRhKCBkb21haW4xPXZlbG9jaXR5RG9tYWluLCAmXFxuICAmIGRvbWFpbjI9cHJlc3N1cmVEb21haW4sIGRpbTE9ZGltMSwgZW50aXR5TnVtMT1lbnRpdHkxLCBkaW0yPWRpbTIsICZcXG4gICYgZW50aXR5TnVtMj1lbnRpdHkyKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgd2lsbCBjcmVhdGUgbm9kZS10by1ub2RlIGNvbm5lY3Rpdml0eSBEQVRBIGZyb20gZG9tYWluMSAoZGltPTIsIGVudGl0eU51bT0xKSB0byBkb21haW4yIChkaW09MiwgZW50aXR5TnVtPTIpLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiTm93IHdlIGNhbiBpbml0aWF0ZSBjZWxsLXRvLWNlbGwgREFUQSBiZXR3ZWVuIHRoZSBhYm92ZSBtZW50aW9uZWQgbWVzaGVzLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgb2JqJUluaXRpYXRlQ2VsbFRvQ2VsbERhdGEoIGRvbWFpbjE9dmVsb2NpdHlEb21haW4sICZcXG4gICYgZG9tYWluMj1wcmVzc3VyZURvbWFpbiwgZGltMT1kaW0xLCBlbnRpdHlOdW0xPWVudGl0eTEsIGRpbTI9ZGltMiwgJlxcbiAgJiBlbnRpdHlOdW0yPWVudGl0eTIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiTm93IGxldCB1cyBydW4gc29tZSBjaGVja3Mgb24gdGhlIHJlc3VsdHMuIFRoaXMgaXMgT05MWSBmb3IgdGhlIHRlc3RpbmcgcHVycG9zZS4gSUYgeW91IHdhbnQsIHlvdSBjYW4gc2tpcCB0aGlzIHBhcnQsIGFuZCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGV4YW1wbGVzLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcImNlbGxUb0NlbGwgPT4gb2JqJWdldENlbGxUb0NlbGxQb2ludGVyKClcXG52ZWxvY2l0eU1lc2ggPT4gdmVsb2NpdHlEb21haW4lZ2V0TWVzaFBvaW50ZXIoZGltPWRpbTEsICZcXG4gICYgZW50aXR5TnVtPWVudGl0eTEpXFxuRE8gaWkgPSB2ZWxvY2l0eU1lc2glbWluRWxlbU51bSwgdmVsb2NpdHlNZXNoJW1heEVsZW1OdW1cXG4gIElGICguTk9ULiB2ZWxvY2l0eU1lc2glaXNFbGVtZW50UHJlc2VudChpaSkpIENZQ0xFXFxuICBJRiAoY2VsbFRvQ2VsbChpaSkgLkVRLiAwKSBUSEVOXFxuICAgIENBTEwgRkFJTChcXFwiRG9tYWluQ29ubmVjdGl2aXR5LXRlc3QgaGFzIGZhaWxlZFxcXCIpXFxuICAgIFNUT1BcXG4gIEVORCBJRlxcbkVORCBET1xcbkNBTEwgUEFTUyhcXFwiRG9tYWluQ29ubmVjdGl2aXR5LXRlc3QgaGFzIHBhc3NlZFxcXCIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIiAgQ0FMTCBwcmVzc3VyZURvbWFpbiVEZWFsbG9jYXRlKClcXG4gIENBTEwgdmVsb2NpdHlEb21haW4lRGVhbGxvY2F0ZSgpXFxuICBDQUxMIG9iaiVEZWFsbG9jYXRlKClcXG5FTkQgUFJPR1JBTSBtYWluXFxuXCJcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTURYQ29udGVudChwcm9wcyA9IHt9KSB7XG4gIGNvbnN0IHt3cmFwcGVyOiBNRFhMYXlvdXR9ID0ge1xuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIE1EWExheW91dCA/IF9qc3goTURYTGF5b3V0LCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IF9qc3goX2NyZWF0ZU1keENvbnRlbnQsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSlcbiAgfSkgOiBfY3JlYXRlTWR4Q29udGVudChwcm9wcyk7XG59XG5cbiIsIlxuXG5leHBvcnQgY29uc3QgZnJvbnRNYXR0ZXIgPSB7fTtcbmV4cG9ydCBjb25zdCBjb250ZW50VGl0bGUgPSB1bmRlZmluZWQ7XG5cblxuXG5pbXBvcnQge0ZyYWdtZW50IGFzIF9GcmFnbWVudCwganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHN9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHt1c2VNRFhDb21wb25lbnRzIGFzIF9wcm92aWRlQ29tcG9uZW50c30gZnJvbSBcIkBtZHgtanMvcmVhY3RcIjtcbmV4cG9ydCBjb25zdCB0b2MgPSBbXTtcbmZ1bmN0aW9uIF9jcmVhdGVNZHhDb250ZW50KHByb3BzKSB7XG4gIGNvbnN0IF9jb21wb25lbnRzID0ge1xuICAgIGNvZGU6IFwiY29kZVwiLFxuICAgIGxpOiBcImxpXCIsXG4gICAgcDogXCJwXCIsXG4gICAgcHJlOiBcInByZVwiLFxuICAgIHVsOiBcInVsXCIsXG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkluIHRoaXMgZXhhbXBsZSwgd2Ugd2lsbCBzaG93IGhvdyB0byBVU0UgW1tEb21haW5Db25uZWN0aXZpdHlfI0luaXRpYXRlQ2VsbFRvQ2VsbERhdGFdXSBtZXRob2QgdG8gZ2VuZXJhdGUgY2VsbC10by1jZWxsIGNvbm5lY3Rpdml0eSBpbmZvcm1hdGlvbiBiZXR3ZWVuIHBhcnQgb2YgdmVsb2NpdHktZG9tYWluIGFuZCBwYXJ0IG9mIHByZXNzdXJlLURvbWFpbi5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy51bCwge1xuICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIlByZXNzdXJlIGRvbWFpbiBjb25zaXN0cyBUcmlhbmdsZTMgZWxlbWVudHMgYXMgc2hvd24gYmVsb3cuXCJcbiAgICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIlZlbG9jaXR5IGRvbWFpbiBjb25zaXN0cyBUcmlhbmdsZTYgZWxlbWVudHMgYXMgc2hvd24gYmVsb3cuXCJcbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQUk9HUkFNIG1haW5cXG4gIFVTRSBlYXNpZmVtQmFzZVxcbiAgVVNFIGVhc2lmZW1DbGFzc2VzXFxuICBJTVBMSUNJVCBOT05FXFxuICBUWVBFKERvbWFpbkNvbm5lY3Rpdml0eV8pIDo6IG9ialxcbiAgVFlQRSggRG9tYWluXyApIDo6IHByZXNzdXJlRG9tYWluXFxuICBUWVBFKCBEb21haW5fICkgOjogdmVsb2NpdHlEb21haW5cXG4gIFRZUEUoIEhERjVGaWxlXyApIDo6IHByZXNzdXJlTWVzaEZpbGVcXG4gIFRZUEUoIEhERjVGaWxlXyApIDo6IHZlbG9jaXR5TWVzaEZpbGVcXG4gIENMQVNTKCBNZXNoXyApLCBQT0lOVEVSIDo6IHZlbG9jaXR5TWVzaFxcbiAgQ0xBU1MoIE1lc2hfICksIFBPSU5URVIgOjogcHJlc3N1cmVNZXNoXFxuICBJTlRFR0VSKCBJNEIgKSwgUE9JTlRFUiA6OiBjZWxsVG9DZWxsKCA6IClcXG4gIElOVEVHRVIoIEk0QiApIDo6IGlpXFxuICBJTlRFR0VSKGk0YiksIFBBUkFNRVRFUiA6OiBkaW0xPTIsIGRpbTI9MiwgZW50aXR5MT0xLCBlbnRpdHkyPTFcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJDcmVhdGUgZG9tYWluIGZvciB2ZWxvY2l0eSB2YXJpYWJsZXMsIPCfjocgUkVBRCB0aGUgbWVzaCBmaWxlLCBhbmQg4q2VIGluaXRpYXRlcyB0aGUgZG9tYWluIGZvciBwcmVzc3VyZVwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgdmVsb2NpdHlNZXNoRmlsZSVJbml0aWF0ZSggRmlsZU5hbWU9XFxcIi4vbWVzaF90cmk2Lmg1XFxcIiwgTU9ERT1cXFwiUkVBRFxcXCIgKVxcbkNBTEwgdmVsb2NpdHlNZXNoRmlsZSVPcGVuKClcXG5DQUxMIHZlbG9jaXR5RG9tYWluJUluaXRpYXRlKCB2ZWxvY2l0eU1lc2hGaWxlLCBcXFwiXFxcIilcXG5DQUxMIHZlbG9jaXR5TWVzaEZpbGUlRGVhbGxvY2F0ZSgpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiQ3JlYXRlIGRvbWFpbiBmb3IgcHJlc3N1cmUgdmFyaWFibGVzLCDwn46HIFJFQUQgdGhlIG1lc2ggZmlsZSwgYW5kIOKtlSBpbml0aWF0ZXMgdGhlIGRvbWFpbiBmb3IgcHJlc3N1cmVcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIHByZXNzdXJlTWVzaEZpbGUlSW5pdGlhdGUoIEZpbGVOYW1lPVxcXCIuL21lc2hfdHJpMy5oNVxcXCIsIE1PREU9XFxcIlJFQURcXFwiIClcXG5DQUxMIHByZXNzdXJlTWVzaEZpbGUlT3BlbigpXFxuQ0FMTCBwcmVzc3VyZURvbWFpbiVJbml0aWF0ZSggcHJlc3N1cmVNZXNoRmlsZSwgXFxcIlxcXCIpXFxuQ0FMTCBwcmVzc3VyZU1lc2hGaWxlJURlYWxsb2NhdGUoKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkluaXRpYXRlcyB0aGUgbm9kZSB0byBub2RlIGNvbm5lY3Rpdml0eSBEQVRBLiBJdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBpbml0aWF0ZSB0aGUgbm9kZSB0byBub2RlIERBVEEgYmVmb3JlIGluaXRpYXRpbmcgY2VsbCB0byBjZWxsIERBVEEuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBvYmolSW5pdGlhdGVOb2RlVG9Ob2RlRGF0YSggZG9tYWluMT1wcmVzc3VyZURvbWFpbiwgJlxcbiAgJiBkb21haW4yPXZlbG9jaXR5RG9tYWluLCBkaW0xPWRpbTEsIGVudGl0eU51bTE9ZW50aXR5MSwgZGltMj1kaW0yLCAmXFxuICAmIGVudGl0eU51bTI9ZW50aXR5MilcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIHdpbGwgY3JlYXRlIG5vZGUtdG8tbm9kZSBjb25uZWN0aXZpdHkgREFUQSBmcm9tIGRvbWFpbjEgKGRpbT0yLCBlbnRpdHlOdW09MSkgdG8gZG9tYWluMiAoZGltPTIsIGVudGl0eU51bT0yKS5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk5vdyB3ZSBjYW4gaW5pdGlhdGUgY2VsbC10by1jZWxsIERBVEEgYmV0d2VlbiB0aGUgYWJvdmUgbWVudGlvbmVkIG1lc2hlcy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIG9iaiVJbml0aWF0ZUNlbGxUb0NlbGxEYXRhKCBkb21haW4xPXByZXNzdXJlRG9tYWluLCAmXFxuICAmIGRvbWFpbjI9dmVsb2NpdHlEb21haW4sIGRpbTE9ZGltMSwgZW50aXR5TnVtMT1lbnRpdHkxLCBkaW0yPWRpbTIsICZcXG4gICYgZW50aXR5TnVtMj1lbnRpdHkyKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk5vdyBsZXQgdXMgcnVuIHNvbWUgY2hlY2tzIG9uIHRoZSByZXN1bHRzLiBUaGlzIGlzIE9OTFkgZm9yIHRoZSB0ZXN0aW5nIHB1cnBvc2UuIElGIHlvdSB3YW50LCB5b3UgY2FuIHNraXAgdGhpcyBwYXJ0LCBhbmQgbW92ZSBvbiB0byB0aGUgbmV4dCBleGFtcGxlcy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJjZWxsVG9DZWxsID0+IG9iaiVnZXRDZWxsVG9DZWxsUG9pbnRlcigpXFxucHJlc3N1cmVNZXNoID0+IHByZXNzdXJlRG9tYWluJWdldE1lc2hQb2ludGVyKGRpbT1kaW0xLCAmXFxuICAmIGVudGl0eU51bT1lbnRpdHkxKVxcbkRPIGlpID0gcHJlc3N1cmVNZXNoJW1pbkVsZW1OdW0sIHByZXNzdXJlTWVzaCVtYXhFbGVtTnVtXFxuICBJRiAoLk5PVC4gcHJlc3N1cmVNZXNoJWlzRWxlbWVudFByZXNlbnQoaWkpKSBDWUNMRVxcbiAgSUYgKGNlbGxUb0NlbGwoaWkpIC5FUS4gMCkgVEhFTlxcbiAgICBDQUxMIEZBSUwoXFxcIkRvbWFpbkNvbm5lY3Rpdml0eS10ZXN0IGhhcyBmYWlsZWRcXFwiKVxcbiAgICBTVE9QXFxuICBFTkQgSUZcXG5FTkQgRE9cXG5DQUxMIFBBU1MoXFxcIkRvbWFpbkNvbm5lY3Rpdml0eS10ZXN0IGhhcyBwYXNzZWRcXFwiKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCIgIENBTEwgcHJlc3N1cmVEb21haW4lRGVhbGxvY2F0ZSgpXFxuICBDQUxMIHZlbG9jaXR5RG9tYWluJURlYWxsb2NhdGUoKVxcbiAgQ0FMTCBvYmolRGVhbGxvY2F0ZSgpXFxuRU5EIFBST0dSQU0gbWFpblxcblwiXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMgPSB7fSkge1xuICBjb25zdCB7d3JhcHBlcjogTURYTGF5b3V0fSA9IHtcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBNRFhMYXlvdXQgPyBfanN4KE1EWExheW91dCwge1xuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiBfanN4KF9jcmVhdGVNZHhDb250ZW50LCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gIH0pIDogX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpO1xufVxuXG4iLCJcblxuZXhwb3J0IGNvbnN0IGZyb250TWF0dGVyID0ge307XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gdW5kZWZpbmVkO1xuXG5cblxuaW1wb3J0IHtGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7dXNlTURYQ29tcG9uZW50cyBhcyBfcHJvdmlkZUNvbXBvbmVudHN9IGZyb20gXCJAbWR4LWpzL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgdG9jID0gW107XG5mdW5jdGlvbiBfY3JlYXRlTWR4Q29udGVudChwcm9wcykge1xuICBjb25zdCBfY29tcG9uZW50cyA9IHtcbiAgICBjb2RlOiBcImNvZGVcIixcbiAgICBsaTogXCJsaVwiLFxuICAgIHA6IFwicFwiLFxuICAgIHByZTogXCJwcmVcIixcbiAgICB1bDogXCJ1bFwiLFxuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIF9qc3hzKF9GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbiB0aGlzIGV4YW1wbGUgd2Ugd2lsbCBnZW5lcmF0ZSBjZWxsIHRvIGNlbGwgY29ubmVjdGl2aXR5IGluZm9ybWF0aW9uIGJldHdlZW4gcHJlc3N1cmUtZG9tYWluIGFuZCBwcmVzc3VyZS1Eb21haW4uXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtcIlByZXNzdXJlIGRvbWFpbiBjb25zaXN0cyBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiVHJpYW5nbGUzXCJcbiAgICAgICAgfSksIFwiIGVsZW1lbnRzIGFzIHNob3duIGJlbG93LlwiXVxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJWZWxvY2l0eSBkb21haW4gY29uc2lzdHMgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIlRyaWFuZ2xlNlwiXG4gICAgICAgIH0pLCBcIiBlbGVtZW50cyBhcyBzaG93biBiZWxvdy5cIl1cbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkltcG9ydGluZyBtb2R1bGVzIGFuZCB2YXJpYWJsZXNcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQUk9HUkFNIG1haW5cXG4gIFVTRSBlYXNpZmVtQmFzZVxcbiAgVVNFIGVhc2lmZW1DbGFzc2VzXFxuICBJTVBMSUNJVCBOT05FXFxuICBUWVBFKERvbWFpbkNvbm5lY3Rpdml0eV8pIDo6IG9ialxcbiAgVFlQRSggRG9tYWluXyApIDo6IHByZXNzdXJlRG9tYWluXFxuICBUWVBFKCBIREY1RmlsZV8gKSA6OiBwcmVzc3VyZU1lc2hGaWxlXFxuICBDTEFTUyggTWVzaF8gKSwgUE9JTlRFUiA6OiBwcmVzc3VyZU1lc2hcXG4gIENMQVNTKCBSZWZlcmVuY2VFbGVtZW50XyApLCBQT0lOVEVSIDo6IHJlZmVsZW1cXG4gIElOVEVHRVIoIEk0QiApLCBQT0lOVEVSIDo6IGNlbGxUb0NlbGwoIDogKVxcbiAgSU5URUdFUiggSTRCICkgOjogaWksIGllbFxcbiAgSU5URUdFUihJNEIpLCBQQVJBTUVURVIgOjogZGltMT0yLCBkaW0yPTIsIGVudGl0eTE9MSwgZW50aXR5Mj0xXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSW5pdGlhdGUgZG9tYWluIGZvciBwcmVzc3VyZSB2YXJpYWJsZS5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIHByZXNzdXJlTWVzaEZpbGUlSW5pdGlhdGUoIEZpbGVOYW1lPVxcXCIuL21lc2hfdHJpMy5oNVxcXCIsIE1PREU9XFxcIlJFQURcXFwiIClcXG5DQUxMIHByZXNzdXJlTWVzaEZpbGUlT3BlbigpXFxuQ0FMTCBwcmVzc3VyZURvbWFpbiVJbml0aWF0ZSggcHJlc3N1cmVNZXNoRmlsZSwgXFxcIlxcXCIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSW5pdGlhdGUgbm9kZSB0byBub2RlIERBVEEuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBvYmolSW5pdGlhdGVOb2RlVG9Ob2RlRGF0YSggZG9tYWluMT1wcmVzc3VyZURvbWFpbiwgJlxcbiAgJiBkb21haW4yPXByZXNzdXJlRG9tYWluIClcXG5DQUxMIFBBU1MoXFxcIkluaXRpYXRlTm9kZVRvTm9kZURhdGEoKVxcXCIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyB3aWxsIGNyZWF0ZSBub2RlIHRvIG5vZGUgY29ubmVjdGl2aXR5IERBVEEgZnJvbSBkb21haW4xIChkaW09MiwgZW50aXR5TnVtPTEpIHRvIGRvbWFpbjIgKGRpbT0yLCBlbnRpdHlOdW09MikuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbml0aWF0ZSBjZWxsIHRvIGNlbGwgY29ubmVjdGl2aXR5IERBVEEuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBvYmolSW5pdGlhdGVDZWxsVG9DZWxsRGF0YShkb21haW4xPXByZXNzdXJlRG9tYWluLCAmXFxuICAmIGRvbWFpbjI9cHJlc3N1cmVEb21haW4pXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwibm93IGxldCB1cyBydW4gc29tZSB0ZXN0cy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJjZWxsVG9DZWxsID0+IG9iaiVnZXRDZWxsVG9DZWxsUG9pbnRlcigpXFxuRE8gaWVsID0gcHJlc3N1cmVEb21haW4lbWluRWxlbU51bSwgcHJlc3N1cmVEb21haW4lbWF4RWxlbU51bVxcbiAgSUYgKC5OT1QuIHByZXNzdXJlRG9tYWluJWlzRWxlbWVudFByZXNlbnQoaWVsKSkgQ1lDTEVcXG4gIElGIChjZWxsVG9DZWxsKGllbCkgLkVRLiAwKSBUSEVOXFxuICAgIHByZXNzdXJlTWVzaCA9PiBwcmVzc3VyZURvbWFpbiVnZXRNZXNoUG9pbnRlcihnbG9iYWxFbGVtZW50PWllbClcXG4gICAgcmVmZWxlbSA9PiBwcmVzc3VyZU1lc2glZ2V0UmVmRWxlbVBvaW50ZXIoKVxcbiAgICBJRiAocmVmZWxlbSV4aWRpbWVuc2lvbiAuRVEuIHByZXNzdXJlRG9tYWluJWdldE5TRCgpKSAmXFxuICAgICAgJiBDQUxMIGZhaWwoXFxcIkNlbGxUb0NlbGw6IGVycm9yIGNvZGUgMVxcXCIpXFxuICBFTFNFXFxuICAgIElGIChjZWxsVG9DZWxsKGllbCkgLk5FLiBpZWwpIFRIRU5cXG4gICAgICBDQUxMIGZhaWwoXFxcIkNlbGxUb0NlbGw6IGVycm9yIGNvZGUgMlxcXCIpXFxuICAgICAgU1RPUFxcbiAgICBFTkQgSUZcXG4gIEVORCBJRlxcbkVORCBET1xcbkNBTEwgUEFTUyhcXFwiSW5pdGlhdGVDZWxsVG9DZWxsRGF0YSgpXFxcIilcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiICBDQUxMIHByZXNzdXJlTWVzaEZpbGUlRGVhbGxvY2F0ZSgpXFxuICBDQUxMIHByZXNzdXJlRG9tYWluJURlYWxsb2NhdGUoKVxcbiAgQ0FMTCBvYmolRGVhbGxvY2F0ZSgpXFxuRU5EIFBST0dSQU0gbWFpblxcblwiXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMgPSB7fSkge1xuICBjb25zdCB7d3JhcHBlcjogTURYTGF5b3V0fSA9IHtcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBNRFhMYXlvdXQgPyBfanN4KE1EWExheW91dCwge1xuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiBfanN4KF9jcmVhdGVNZHhDb250ZW50LCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gIH0pIDogX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpO1xufVxuXG4iLCJcblxuZXhwb3J0IGNvbnN0IGZyb250TWF0dGVyID0ge307XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gdW5kZWZpbmVkO1xuXG5cblxuaW1wb3J0IHtGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7dXNlTURYQ29tcG9uZW50cyBhcyBfcHJvdmlkZUNvbXBvbmVudHN9IGZyb20gXCJAbWR4LWpzL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgdG9jID0gW107XG5mdW5jdGlvbiBfY3JlYXRlTWR4Q29udGVudChwcm9wcykge1xuICBjb25zdCBfY29tcG9uZW50cyA9IHtcbiAgICBjb2RlOiBcImNvZGVcIixcbiAgICBsaTogXCJsaVwiLFxuICAgIHA6IFwicFwiLFxuICAgIHByZTogXCJwcmVcIixcbiAgICB1bDogXCJ1bFwiLFxuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIF9qc3hzKF9GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbiB0aGlzIGV4YW1wbGUgd2Ugd2lsbCBnZW5lcmF0ZSBjZWxsIHRvIGNlbGwgY29ubmVjdGl2aXR5IGluZm9ybWF0aW9uIGJldHdlZW4gdmVsb2NpdHktZG9tYWluIGFuZCB2ZWxvY2l0eS1Eb21haW4uXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtcIlByZXNzdXJlIGRvbWFpbiBjb25zaXN0cyBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiVHJpYW5nbGUzXCJcbiAgICAgICAgfSksIFwiIGVsZW1lbnRzIGFzIHNob3duIGJlbG93LlwiXVxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJWZWxvY2l0eSBkb21haW4gY29uc2lzdHMgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIlRyaWFuZ2xlNlwiXG4gICAgICAgIH0pLCBcIiBlbGVtZW50cyBhcyBzaG93biBiZWxvdy5cIl1cbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkltcG9ydGluZyBtb2R1bGVzIGFuZCB2YXJpYWJsZXNcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQUk9HUkFNIG1haW5cXG4gIFVTRSBlYXNpZmVtQmFzZVxcbiAgVVNFIGVhc2lmZW1DbGFzc2VzXFxuICBJTVBMSUNJVCBOT05FXFxuICBUWVBFKERvbWFpbkNvbm5lY3Rpdml0eV8pIDo6IG9ialxcbiAgVFlQRSggRG9tYWluXyApIDo6IHZlbG9jaXR5RG9tYWluXFxuICBUWVBFKCBIREY1RmlsZV8gKSA6OiB2ZWxvY2l0eU1lc2hGaWxlXFxuICBDTEFTUyggTWVzaF8gKSwgUE9JTlRFUiA6OiB2ZWxvY2l0eU1lc2hcXG4gIENMQVNTKCBSZWZlcmVuY2VFbGVtZW50XyApLCBQT0lOVEVSIDo6IHJlZmVsZW1cXG4gIElOVEVHRVIoIEk0QiApLCBQT0lOVEVSIDo6IGNlbGxUb0NlbGwoIDogKVxcbiAgSU5URUdFUiggSTRCICkgOjogaWksIGllbFxcbiAgSU5URUdFUihJNEIpLCBQQVJBTUVURVIgOjogZGltMT0yLCBkaW0yPTIsIGVudGl0eTE9MSwgZW50aXR5Mj0xXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSW5pdGlhdGUgZG9tYWluIGZvciB2ZWxvY2l0eSB2YXJpYWJsZS5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIHZlbG9jaXR5TWVzaEZpbGUlSW5pdGlhdGUoIEZpbGVOYW1lPVxcXCIuL21lc2hfdHJpNi5oNVxcXCIsIE1PREU9XFxcIlJFQURcXFwiIClcXG5DQUxMIHZlbG9jaXR5TWVzaEZpbGUlT3BlbigpXFxuQ0FMTCB2ZWxvY2l0eURvbWFpbiVJbml0aWF0ZSggdmVsb2NpdHlNZXNoRmlsZSwgXFxcIlxcXCIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSW5pdGlhdGUgbm9kZSB0byBub2RlIERBVEEuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBvYmolSW5pdGlhdGVOb2RlVG9Ob2RlRGF0YSggZG9tYWluMT12ZWxvY2l0eURvbWFpbiwgJlxcbiAgJiBkb21haW4yPXZlbG9jaXR5RG9tYWluIClcXG5DQUxMIFBBU1MoXFxcIkluaXRpYXRlTm9kZVRvTm9kZURhdGEoKVxcXCIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyB3aWxsIGNyZWF0ZSBub2RlIHRvIG5vZGUgY29ubmVjdGl2aXR5IERBVEEgZnJvbSBkb21haW4xIChkaW09MiwgZW50aXR5TnVtPTEpIHRvIGRvbWFpbjIgKGRpbT0yLCBlbnRpdHlOdW09MikuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbml0aWF0ZSBjZWxsIHRvIGNlbGwgY29ubmVjdGl2aXR5IERBVEEuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBvYmolSW5pdGlhdGVDZWxsVG9DZWxsRGF0YShkb21haW4xPXZlbG9jaXR5RG9tYWluLCAmXFxuICAmIGRvbWFpbjI9dmVsb2NpdHlEb21haW4pXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwibm93IGxldCB1cyBydW4gc29tZSB0ZXN0cywgdGhpcyBpcyBvbmx5IGZvciB0ZXN0aW5nIHB1cnBvc2UsIHNvIHlvdSBjYW4gaWdub3JlIHRoZSBmb3J0aGNvbWluZyBzZWN0aW9uLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcImNlbGxUb0NlbGwgPT4gb2JqJWdldENlbGxUb0NlbGxQb2ludGVyKClcXG5ETyBpZWwgPSB2ZWxvY2l0eURvbWFpbiVtaW5FbGVtTnVtLCB2ZWxvY2l0eURvbWFpbiVtYXhFbGVtTnVtXFxuICBJRiAoLk5PVC4gdmVsb2NpdHlEb21haW4laXNFbGVtZW50UHJlc2VudChpZWwpKSBDWUNMRVxcbiAgSUYgKGNlbGxUb0NlbGwoaWVsKSAuRVEuIDApIFRIRU5cXG4gICAgdmVsb2NpdHlNZXNoID0+IHZlbG9jaXR5RG9tYWluJWdldE1lc2hQb2ludGVyKGdsb2JhbEVsZW1lbnQ9aWVsKVxcbiAgICByZWZlbGVtID0+IHZlbG9jaXR5TWVzaCVnZXRSZWZFbGVtUG9pbnRlcigpXFxuICAgIElGIChyZWZlbGVtJXhpZGltZW5zaW9uIC5FUS4gdmVsb2NpdHlEb21haW4lZ2V0TlNEKCkpICZcXG4gICAgICAmIENBTEwgZmFpbChcXFwiQ2VsbFRvQ2VsbDogZXJyb3IgY29kZSAxXFxcIilcXG4gIEVMU0VcXG4gICAgSUYgKGNlbGxUb0NlbGwoaWVsKSAuTkUuIGllbCkgVEhFTlxcbiAgICAgIENBTEwgZmFpbChcXFwiQ2VsbFRvQ2VsbDogZXJyb3IgY29kZSAyXFxcIilcXG4gICAgICBTVE9QXFxuICAgIEVORCBJRlxcbiAgRU5EIElGXFxuRU5EIERPXFxuQ0FMTCBQQVNTKFxcXCJJbml0aWF0ZUNlbGxUb0NlbGxEYXRhKClcXFwiKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCIgIENBTEwgdmVsb2NpdHlNZXNoRmlsZSVEZWFsbG9jYXRlKClcXG4gIENBTEwgdmVsb2NpdHlEb21haW4lRGVhbGxvY2F0ZSgpXFxuICBDQUxMIG9iaiVEZWFsbG9jYXRlKClcXG5FTkQgUFJPR1JBTSBtYWluXFxuXCJcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTURYQ29udGVudChwcm9wcyA9IHt9KSB7XG4gIGNvbnN0IHt3cmFwcGVyOiBNRFhMYXlvdXR9ID0ge1xuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIE1EWExheW91dCA/IF9qc3goTURYTGF5b3V0LCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IF9qc3goX2NyZWF0ZU1keENvbnRlbnQsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSlcbiAgfSkgOiBfY3JlYXRlTWR4Q29udGVudChwcm9wcyk7XG59XG5cbiIsIlxuXG5leHBvcnQgY29uc3QgZnJvbnRNYXR0ZXIgPSB7fTtcbmV4cG9ydCBjb25zdCBjb250ZW50VGl0bGUgPSB1bmRlZmluZWQ7XG5cblxuXG5pbXBvcnQge0ZyYWdtZW50IGFzIF9GcmFnbWVudCwganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHN9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHt1c2VNRFhDb21wb25lbnRzIGFzIF9wcm92aWRlQ29tcG9uZW50c30gZnJvbSBcIkBtZHgtanMvcmVhY3RcIjtcbmV4cG9ydCBjb25zdCB0b2MgPSBbXTtcbmZ1bmN0aW9uIF9jcmVhdGVNZHhDb250ZW50KHByb3BzKSB7XG4gIGNvbnN0IF9jb21wb25lbnRzID0ge1xuICAgIGNvZGU6IFwiY29kZVwiLFxuICAgIGxpOiBcImxpXCIsXG4gICAgcDogXCJwXCIsXG4gICAgcHJlOiBcInByZVwiLFxuICAgIHVsOiBcInVsXCIsXG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkluIHRoaXMgZXhhbXBsZSB3ZSB3aWxsIGdlbmVyYXRlIGNlbGwgdG8gY2VsbCBjb25uZWN0aXZpdHkgaW5mb3JtYXRpb24gYmV0d2VlbiB2ZWxvY2l0eS1kb21haW4gYW5kIHByZXNzdXJlLURvbWFpbi5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy51bCwge1xuICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIlByZXNzdXJlIGRvbWFpbiBjb25zaXN0cyBUcmlhbmdsZTMgZWxlbWVudHMgYXMgc2hvd24gYmVsb3cuXCJcbiAgICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIlZlbG9jaXR5IGRvbWFpbiBjb25zaXN0cyBUcmlhbmdsZTYgZWxlbWVudHMgYXMgc2hvd24gYmVsb3cuXCJcbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkltcG9ydGluZyBtb2R1bGVzIGFuZCB2YXJpYWJsZXNcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQUk9HUkFNIG1haW5cXG4gIFVTRSBlYXNpZmVtQmFzZVxcbiAgVVNFIGVhc2lmZW1DbGFzc2VzXFxuICBJTVBMSUNJVCBOT05FXFxuICBUWVBFKERvbWFpbkNvbm5lY3Rpdml0eV8pIDo6IG9ialxcbiAgVFlQRSggRG9tYWluXyApIDo6IHByZXNzdXJlRG9tYWluXFxuICBUWVBFKCBEb21haW5fICkgOjogdmVsb2NpdHlEb21haW5cXG4gIFRZUEUoIEhERjVGaWxlXyApIDo6IHByZXNzdXJlTWVzaEZpbGVcXG4gIFRZUEUoIEhERjVGaWxlXyApIDo6IHZlbG9jaXR5TWVzaEZpbGVcXG4gIENMQVNTKCBNZXNoXyApLCBQT0lOVEVSIDo6IHZlbG9jaXR5TWVzaFxcbiAgQ0xBU1MoIE1lc2hfICksIFBPSU5URVIgOjogcHJlc3N1cmVNZXNoXFxuICBDTEFTUyggUmVmZXJlbmNlRWxlbWVudF8gKSwgUE9JTlRFUiA6OiB2ZWxvY2l0eVJlZmVsZW1cXG4gIENMQVNTKCBSZWZlcmVuY2VFbGVtZW50XyApLCBQT0lOVEVSIDo6IHByZXNzdXJlUmVmZWxlbVxcbiAgQ0xBU1MoIFJlZmVyZW5jZUVsZW1lbnRfICksIFBPSU5URVIgOjogcmVmZWxlbVxcbiAgSU5URUdFUiggSTRCICksIFBPSU5URVIgOjogY2VsbFRvQ2VsbCggOiApXFxuICBJTlRFR0VSKCBJNEIgKSA6OiBpaSwgaWVsXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiT3BlbiB0aGUgbWVzaCBmaWxlIGZvciBwcmVzc3VyZSBhbmQgdmVsb2NpdHkgZG9tYWluXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCB2ZWxvY2l0eU1lc2hGaWxlJUluaXRpYXRlKCBGaWxlTmFtZT1cXFwiLi9tZXNoX3RyaTYuaDVcXFwiLCBNT0RFPVxcXCJSRUFEXFxcIiApXFxuQ0FMTCB2ZWxvY2l0eU1lc2hGaWxlJU9wZW4oKVxcbkNBTEwgcHJlc3N1cmVNZXNoRmlsZSVJbml0aWF0ZSggRmlsZU5hbWU9XFxcIi4vbWVzaF90cmkzLmg1XFxcIiwgTU9ERT1cXFwiUkVBRFxcXCIgKVxcbkNBTEwgcHJlc3N1cmVNZXNoRmlsZSVPcGVuKClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbml0aWF0ZSB0aGUgZG9tYWluIGZvciBwcmVzc3VyZSBhbmQgdmVsb2NpdHlcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIHZlbG9jaXR5RG9tYWluJUluaXRpYXRlKCB2ZWxvY2l0eU1lc2hGaWxlLCBcXFwiXFxcIilcXG5DQUxMIHByZXNzdXJlRG9tYWluJUluaXRpYXRlKCBwcmVzc3VyZU1lc2hGaWxlLCBcXFwiXFxcIilcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbml0aWF0ZSBub2RlIHRvIG5vZGUgZGF0YSBiZXR3ZWVuIHZlbG9jaXR5IGRvbWFpbiBhbmQgcHJlc3N1cmUgZG9tYWluLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgb2JqJUluaXRpYXRlTm9kZVRvTm9kZURhdGEoIGRvbWFpbjE9dmVsb2NpdHlEb21haW4sICZcXG4gICYgZG9tYWluMj1wcmVzc3VyZURvbWFpbiApXFxuQ0FMTCBQQVNTKFxcXCJJbml0aWF0ZU5vZGVUb05vZGVEYXRhKClcXFwiKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk5vdyB0aGF0IG5vZGUtdG8tbm9kZSBkYXRhIGlzIHJlYWR5LCBsZXQgdXMgaW5pdGlhdGUgY2VsbCB0byBjZWxsIGRhdGEgZnJvbSB2ZWxvY2l0eSBkb21haW4gdG8gcHJlc3N1cmUgZG9tYWluLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgb2JqJUluaXRpYXRlQ2VsbFRvQ2VsbERhdGEoIGRvbWFpbjE9dmVsb2NpdHlEb21haW4sICZcXG4gICYgZG9tYWluMj1wcmVzc3VyZURvbWFpbiApXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwibm93IGxldCB1cyBydW4gc29tZSB0ZXN0cyB0byBjaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhlIGRhdGEuIFRoaXMgaXMgb25seSBmb3IgdGVzdGluZyBwdXJwb3NlLCBzbyB5b3UgY2FuIGlnbm9yZSB0aGUgZm9ydGhjb21pbmcgc2VjdGlvbi5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJjZWxsVG9DZWxsID0+IG9iaiVnZXRDZWxsVG9DZWxsUG9pbnRlcigpXFxuRE8gaWVsID0gdmVsb2NpdHlEb21haW4lbWluRWxlbU51bSwgdmVsb2NpdHlEb21haW4lbWF4RWxlbU51bVxcbiAgSUYgKC5OT1QuIHZlbG9jaXR5RG9tYWluJWlzRWxlbWVudFByZXNlbnQoaWVsKSkgQ1lDTEVcXG4gIElGIChjZWxsVG9DZWxsKGllbCkgLkVRLiAwKSBUSEVOXFxuICAgIHZlbG9jaXR5TWVzaCA9PiB2ZWxvY2l0eURvbWFpbiVnZXRNZXNoUG9pbnRlcihnbG9iYWxFbGVtZW50PWllbClcXG4gICAgcmVmZWxlbSA9PiB2ZWxvY2l0eU1lc2glZ2V0UmVmRWxlbVBvaW50ZXIoKVxcbiAgICBJRiAocmVmZWxlbSV4aWRpbWVuc2lvbiAuRVEuIHZlbG9jaXR5RG9tYWluJWdldE5TRCgpKSBUSEVOXFxuICAgICAgQ0FMTCBmYWlsKFxcXCJDZWxsVG9DZWxsOiBlcnJvciBjb2RlIDFcXFwiKVxcbiAgICAgIFNUT1BcXG4gICAgRU5EIElGXFxuICBFTFNFXFxuICAgICEhIGhlcmUgaSBhbSBjaGVja2luZyBpZiB0aGUgY2VsbFRvQ2VsbChpZWwpIGlzIHByZXNlbnQgaW5cXG4gICAgISEgaW4gdGhlIHByZXNzdXJlIGRvbWFpbiBvciBub3QuXFxuICAgICEhIElmIGl0IGlzIHByZXNlbnQgdGhlbiBpdCBzaG91bGQgYmUgYSBjZWxsIGVsZW1lbnQuXFxuICAgIGlpID0gY2VsbFRvQ2VsbChpZWwpXFxuICAgIElGICguTk9ULiBwcmVzc3VyZURvbWFpbiVpc0VsZW1lbnRQcmVzZW50KGlpKSkgVEhFTlxcbiAgICAgIENBTEwgZmFpbChcXFwiQ2VsbFRvQ2VsbDogZXJyb3IgY29kZSAyXFxcIilcXG4gICAgICBTVE9QXFxuICAgIEVMU0VcXG4gICAgICB2ZWxvY2l0eU1lc2ggPT4gdmVsb2NpdHlEb21haW4lZ2V0TWVzaFBvaW50ZXIoZ2xvYmFsRWxlbWVudD1pZWwpXFxuICAgICAgdmVsb2NpdHlSZWZlbGVtID0+IHZlbG9jaXR5TWVzaCVnZXRSZWZFbGVtUG9pbnRlcigpXFxuICAgICAgcHJlc3N1cmVNZXNoID0+IHByZXNzdXJlRG9tYWluJWdldE1lc2hQb2ludGVyKGdsb2JhbEVsZW1lbnQ9aWkpXFxuICAgICAgcHJlc3N1cmVSZWZlbGVtID0+IHByZXNzdXJlTWVzaCVnZXRSZWZFbGVtUG9pbnRlcigpXFxuICAgICAgSUYgKHByZXNzdXJlUmVmZWxlbSV4aWRpbWVuc2lvbiAuTkUuIHZlbG9jaXR5UmVmZWxlbSV4aWRpbWVuc2lvbikgVEhFTlxcbiAgICAgICAgQ0FMTCBmYWlsKFxcXCJDZWxsVG9DZWxsOiBlcnJvciBjb2RlIDNcXFwiKVxcbiAgICAgICAgU1RPUFxcbiAgICAgIEVORCBJRlxcbiAgICBFTkQgSUZcXG4gIEVORCBJRlxcbkVORCBET1xcbkNBTEwgUEFTUyhcXFwiSW5pdGlhdGVDZWxsVG9DZWxsRGF0YSgpXFxcIilcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiICBDQUxMIHByZXNzdXJlTWVzaEZpbGUlRGVhbGxvY2F0ZSgpXFxuICBDQUxMIHZlbG9jaXR5TWVzaEZpbGUlRGVhbGxvY2F0ZSgpXFxuICBDQUxMIHByZXNzdXJlRG9tYWluJURlYWxsb2NhdGUoKVxcbiAgQ0FMTCB2ZWxvY2l0eURvbWFpbiVEZWFsbG9jYXRlKClcXG4gIENBTEwgb2JqJURlYWxsb2NhdGUoKVxcbkVORCBQUk9HUkFNIG1haW5cXG5cIlxuICAgICAgfSlcbiAgICB9KV1cbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzID0ge30pIHtcbiAgY29uc3Qge3dyYXBwZXI6IE1EWExheW91dH0gPSB7XG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gTURYTGF5b3V0ID8gX2pzeChNRFhMYXlvdXQsIHtcbiAgICAuLi5wcm9wcyxcbiAgICBjaGlsZHJlbjogX2pzeChfY3JlYXRlTWR4Q29udGVudCwge1xuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICB9KSA6IF9jcmVhdGVNZHhDb250ZW50KHByb3BzKTtcbn1cblxuIiwiXG5cbmV4cG9ydCBjb25zdCBmcm9udE1hdHRlciA9IHt9O1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUaXRsZSA9IHVuZGVmaW5lZDtcblxuXG5cbmltcG9ydCB7RnJhZ21lbnQgYXMgX0ZyYWdtZW50LCBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4c30gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQge3VzZU1EWENvbXBvbmVudHMgYXMgX3Byb3ZpZGVDb21wb25lbnRzfSBmcm9tIFwiQG1keC1qcy9yZWFjdFwiO1xuZXhwb3J0IGNvbnN0IHRvYyA9IFtdO1xuZnVuY3Rpb24gX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpIHtcbiAgY29uc3QgX2NvbXBvbmVudHMgPSB7XG4gICAgY29kZTogXCJjb2RlXCIsXG4gICAgbGk6IFwibGlcIixcbiAgICBwOiBcInBcIixcbiAgICBwcmU6IFwicHJlXCIsXG4gICAgdWw6IFwidWxcIixcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBfanN4cyhfRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSW4gdGhpcyBleGFtcGxlIHdlIHdpbGwgZ2VuZXJhdGUgY2VsbCB0byBjZWxsIGNvbm5lY3Rpdml0eSBpbmZvcm1hdGlvbiBiZXR3ZWVuIHByZXNzdXJlLWRvbWFpbiBhbmQgdmVsb2NpdHktRG9tYWluLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJQcmVzc3VyZSBkb21haW4gY29uc2lzdHMgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIlRyaWFuZ2xlM1wiXG4gICAgICAgIH0pLCBcIiBlbGVtZW50cyBhcyBzaG93biBiZWxvdy5cIl1cbiAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW1wiVmVsb2NpdHkgZG9tYWluIGNvbnNpc3RzIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJUcmlhbmdsZTZcIlxuICAgICAgICB9KSwgXCIgZWxlbWVudHMgYXMgc2hvd24gYmVsb3cuXCJdXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJbXBvcnRpbmcgbW9kdWxlcyBhbmQgdmFyaWFibGVzXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFJPR1JBTSBtYWluXFxuICBVU0UgZWFzaWZlbUJhc2VcXG4gIFVTRSBlYXNpZmVtQ2xhc3Nlc1xcbiAgSU1QTElDSVQgTk9ORVxcbiAgVFlQRShEb21haW5Db25uZWN0aXZpdHlfKSA6OiBvYmpcXG4gIFRZUEUoIERvbWFpbl8gKSA6OiBwcmVzc3VyZURvbWFpblxcbiAgVFlQRSggRG9tYWluXyApIDo6IHZlbG9jaXR5RG9tYWluXFxuICBUWVBFKCBIREY1RmlsZV8gKSA6OiBwcmVzc3VyZU1lc2hGaWxlXFxuICBUWVBFKCBIREY1RmlsZV8gKSA6OiB2ZWxvY2l0eU1lc2hGaWxlXFxuICBDTEFTUyggTWVzaF8gKSwgUE9JTlRFUiA6OiB2ZWxvY2l0eU1lc2hcXG4gIENMQVNTKCBNZXNoXyApLCBQT0lOVEVSIDo6IHByZXNzdXJlTWVzaFxcbiAgQ0xBU1MoIFJlZmVyZW5jZUVsZW1lbnRfICksIFBPSU5URVIgOjogcmVmZWxlbVxcbiAgQ0xBU1MoIFJlZmVyZW5jZUVsZW1lbnRfICksIFBPSU5URVIgOjogdmVsb2NpdHlSZWZlbGVtXFxuICBDTEFTUyggUmVmZXJlbmNlRWxlbWVudF8gKSwgUE9JTlRFUiA6OiBwcmVzc3VyZVJlZmVsZW1cXG4gIElOVEVHRVIoIEk0QiApLCBQT0lOVEVSIDo6IGNlbGxUb0NlbGwoIDogKVxcbiAgSU5URUdFUiggSTRCICkgOjogaWksIGllbFxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk9wZW4gdGhlIG1lc2ggZmlsZSBmb3IgcHJlc3N1cmUgYW5kIHZlbG9jaXR5IGRvbWFpblwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgdmVsb2NpdHlNZXNoRmlsZSVJbml0aWF0ZSggRmlsZU5hbWU9XFxcIi4vbWVzaF90cmk2Lmg1XFxcIiwgTU9ERT1cXFwiUkVBRFxcXCIgKVxcbkNBTEwgdmVsb2NpdHlNZXNoRmlsZSVPcGVuKClcXG5DQUxMIHByZXNzdXJlTWVzaEZpbGUlSW5pdGlhdGUoIEZpbGVOYW1lPVxcXCIuL21lc2hfdHJpMy5oNVxcXCIsIE1PREU9XFxcIlJFQURcXFwiIClcXG5DQUxMIHByZXNzdXJlTWVzaEZpbGUlT3BlbigpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSW5pdGlhdGUgdGhlIGRvbWFpbiBmb3IgcHJlc3N1cmUgYW5kIHZlbG9jaXR5XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCB2ZWxvY2l0eURvbWFpbiVJbml0aWF0ZSggdmVsb2NpdHlNZXNoRmlsZSwgXFxcIlxcXCIpXFxuQ0FMTCBwcmVzc3VyZURvbWFpbiVJbml0aWF0ZSggcHJlc3N1cmVNZXNoRmlsZSwgXFxcIlxcXCIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSW5pdGlhdGUgbm9kZSB0byBub2RlIGRhdGEgYmV0d2VlbiB2ZWxvY2l0eSBkb21haW4gYW5kIHByZXNzdXJlIGRvbWFpbi5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIG9iaiVJbml0aWF0ZU5vZGVUb05vZGVEYXRhKCBkb21haW4xPXByZXNzdXJlRG9tYWluLCAmXFxuICAmIGRvbWFpbjI9dmVsb2NpdHlEb21haW4gKVxcbkNBTEwgUEFTUyhcXFwiSW5pdGlhdGVOb2RlVG9Ob2RlRGF0YSgpXFxcIilcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJOb3cgdGhhdCBub2RlLXRvLW5vZGUgZGF0YSBpcyByZWFkeSwgbGV0IHVzIGluaXRpYXRlIGNlbGwgdG8gY2VsbCBkYXRhIGZyb20gcHJlc3N1cmUgZG9tYWluIHRvIHZlbG9jaXR5IGRvbWFpbi5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIG9iaiVJbml0aWF0ZUNlbGxUb0NlbGxEYXRhKCBkb21haW4xPXByZXNzdXJlRG9tYWluLCAmXFxuICAmIGRvbWFpbjI9dmVsb2NpdHlEb21haW4gKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIm5vdyBsZXQgdXMgcnVuIHNvbWUgdGVzdHMgdG8gY2hlY2sgdGhlIHZhbGlkaXR5IG9mIHRoZSBkYXRhLiBUaGlzIGlzIG9ubHkgZm9yIHRlc3RpbmcgcHVycG9zZSwgc28geW91IGNhbiBpZ25vcmUgdGhlIGZvcnRoY29taW5nIHNlY3Rpb24uXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiY2VsbFRvQ2VsbCA9PiBvYmolZ2V0Q2VsbFRvQ2VsbFBvaW50ZXIoKVxcbkRPIGllbCA9IHByZXNzdXJlRG9tYWluJW1pbkVsZW1OdW0sIHByZXNzdXJlRG9tYWluJW1heEVsZW1OdW1cXG4gIElGICguTk9ULiBwcmVzc3VyZURvbWFpbiVpc0VsZW1lbnRQcmVzZW50KGllbCkpIENZQ0xFXFxuICBJRiAoY2VsbFRvQ2VsbChpZWwpIC5FUS4gMCkgVEhFTlxcbiAgICBwcmVzc3VyZU1lc2ggPT4gcHJlc3N1cmVEb21haW4lZ2V0TWVzaFBvaW50ZXIoZ2xvYmFsRWxlbWVudD1pZWwpXFxuICAgIHJlZmVsZW0gPT4gcHJlc3N1cmVNZXNoJWdldFJlZkVsZW1Qb2ludGVyKClcXG4gICAgSUYgKHJlZmVsZW0leGlkaW1lbnNpb24gLkVRLiBwcmVzc3VyZURvbWFpbiVnZXROU0QoKSkgVEhFTlxcbiAgICAgIENBTEwgZmFpbChcXFwiQ2VsbFRvQ2VsbDogZXJyb3IgY29kZSAxXFxcIilcXG4gICAgICBTVE9QXFxuICAgIEVORCBJRlxcbiAgRUxTRVxcbiAgICAhISBoZXJlIGkgYW0gY2hlY2tpbmcgaWYgdGhlIGNlbGxUb0NlbGwoaWVsKSBpcyBwcmVzZW50IGluXFxuICAgICEhIGluIHRoZSBwcmVzc3VyZSBkb21haW4gb3Igbm90LlxcbiAgICAhISBJZiBpdCBpcyBwcmVzZW50IHRoZW4gaXQgc2hvdWxkIGJlIGEgY2VsbCBlbGVtZW50LlxcbiAgICBpaSA9IGNlbGxUb0NlbGwoaWVsKVxcbiAgICBJRiAoLk5PVC4gdmVsb2NpdHlEb21haW4laXNFbGVtZW50UHJlc2VudChpaSkpIFRIRU5cXG4gICAgICBDQUxMIGZhaWwoXFxcIkNlbGxUb0NlbGw6IGVycm9yIGNvZGUgMlxcXCIpXFxuICAgICAgU1RPUFxcbiAgICBFTFNFXFxuICAgICAgdmVsb2NpdHlNZXNoID0+IHZlbG9jaXR5RG9tYWluJWdldE1lc2hQb2ludGVyKGdsb2JhbEVsZW1lbnQ9aWkpXFxuICAgICAgdmVsb2NpdHlSZWZlbGVtID0+IHZlbG9jaXR5TWVzaCVnZXRSZWZFbGVtUG9pbnRlcigpXFxuICAgICAgcHJlc3N1cmVNZXNoID0+IHByZXNzdXJlRG9tYWluJWdldE1lc2hQb2ludGVyKGdsb2JhbEVsZW1lbnQ9aWVsKVxcbiAgICAgIHByZXNzdXJlUmVmZWxlbSA9PiBwcmVzc3VyZU1lc2glZ2V0UmVmRWxlbVBvaW50ZXIoKVxcbiAgICAgIElGIChwcmVzc3VyZVJlZmVsZW0leGlkaW1lbnNpb24gLk5FLiB2ZWxvY2l0eVJlZmVsZW0leGlkaW1lbnNpb24pIFRIRU5cXG4gICAgICAgIENBTEwgZmFpbChcXFwiQ2VsbFRvQ2VsbDogZXJyb3IgY29kZSAzXFxcIilcXG4gICAgICAgIFNUT1BcXG4gICAgICBFTkQgSUZcXG4gICAgRU5EIElGXFxuICBFTkQgSUZcXG5FTkQgRE9cXG5DQUxMIFBBU1MoXFxcIkluaXRpYXRlQ2VsbFRvQ2VsbERhdGEoKVxcXCIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIiAgQ0FMTCBwcmVzc3VyZU1lc2hGaWxlJURlYWxsb2NhdGUoKVxcbiAgQ0FMTCB2ZWxvY2l0eU1lc2hGaWxlJURlYWxsb2NhdGUoKVxcbiAgQ0FMTCBwcmVzc3VyZURvbWFpbiVEZWFsbG9jYXRlKClcXG4gIENBTEwgdmVsb2NpdHlEb21haW4lRGVhbGxvY2F0ZSgpXFxuICBDQUxMIG9iaiVEZWFsbG9jYXRlKClcXG5FTkQgUFJPR1JBTSBtYWluXFxuXCJcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTURYQ29udGVudChwcm9wcyA9IHt9KSB7XG4gIGNvbnN0IHt3cmFwcGVyOiBNRFhMYXlvdXR9ID0ge1xuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIE1EWExheW91dCA/IF9qc3goTURYTGF5b3V0LCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IF9qc3goX2NyZWF0ZU1keENvbnRlbnQsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSlcbiAgfSkgOiBfY3JlYXRlTWR4Q29udGVudChwcm9wcyk7XG59XG5cbiIsIlxuXG5leHBvcnQgY29uc3QgZnJvbnRNYXR0ZXIgPSB7fTtcbmV4cG9ydCBjb25zdCBjb250ZW50VGl0bGUgPSAnSW5pdGlhdGVDZWxsVG9DZWxsRGF0YSc7XG5leHBvcnQge2RlZmF1bHQgYXMgbWV0YWRhdGF9IGZyb20gJ0BzaXRlLy5kb2N1c2F1cnVzL2RvY3VzYXVydXMtcGx1Z2luLWNvbnRlbnQtZG9jcy9kb2NzLWFwaS9zaXRlLWRvY3MtZG9jcy1hcGktZG9tYWluLWNvbm5lY3Rpdml0eS1pbml0aWF0ZS1jZWxsLXRvLWNlbGwtZGF0YS1tZC02ZmEuanNvbidcbmV4cG9ydCBjb25zdCBhc3NldHMgPSB7XG5cbn07XG5cbmltcG9ydCB7RnJhZ21lbnQgYXMgX0ZyYWdtZW50LCBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4c30gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQge3VzZU1EWENvbXBvbmVudHMgYXMgX3Byb3ZpZGVDb21wb25lbnRzfSBmcm9tIFwiQG1keC1qcy9yZWFjdFwiO1xuaW1wb3J0IFRhYnMgZnJvbSAnQHRoZW1lL1RhYnMnO1xuaW1wb3J0IFRhYkl0ZW0gZnJvbSAnQHRoZW1lL1RhYkl0ZW0nO1xuaW1wb3J0IEVYQU1QTEU0Niwge3RvYyBhcyBfX3RvY0VYQU1QTEU0Nn0gZnJvbSBcIi4vX0RvbWFpbkNvbm5lY3Rpdml0eV90ZXN0XzExLm1kXCI7XG5pbXBvcnQgRVhBTVBMRTQ3LCB7dG9jIGFzIF9fdG9jRVhBTVBMRTQ3fSBmcm9tIFwiLi9fRG9tYWluQ29ubmVjdGl2aXR5X3Rlc3RfMTIubWRcIjtcbmltcG9ydCBFWEFNUExFMywge3RvYyBhcyBfX3RvY0VYQU1QTEUzfSBmcm9tIFwiLi9fRG9tYWluQ29ubmVjdGl2aXR5X3Rlc3RfMTMubWRcIjtcbmltcG9ydCBFWEFNUExFNCwge3RvYyBhcyBfX3RvY0VYQU1QTEU0fSBmcm9tIFwiLi9fRG9tYWluQ29ubmVjdGl2aXR5X3Rlc3RfMTQubWRcIjtcbmltcG9ydCBFWEFNUExFNSwge3RvYyBhcyBfX3RvY0VYQU1QTEU1fSBmcm9tIFwiLi9fRG9tYWluQ29ubmVjdGl2aXR5X3Rlc3RfMTUubWRcIjtcbmltcG9ydCBFWEFNUExFNiwge3RvYyBhcyBfX3RvY0VYQU1QTEU2fSBmcm9tIFwiLi9fRG9tYWluQ29ubmVjdGl2aXR5X3Rlc3RfMTYubWRcIjtcbmltcG9ydCBFWEFNUExFNywge3RvYyBhcyBfX3RvY0VYQU1QTEU3fSBmcm9tIFwiLi9fRG9tYWluQ29ubmVjdGl2aXR5X3Rlc3RfMTcubWRcIjtcbmltcG9ydCBFWEFNUExFOCwge3RvYyBhcyBfX3RvY0VYQU1QTEU4fSBmcm9tIFwiLi9fRG9tYWluQ29ubmVjdGl2aXR5X3Rlc3RfMTgubWRcIjtcbmltcG9ydCBFWEFNUExFOSwge3RvYyBhcyBfX3RvY0VYQU1QTEU5fSBmcm9tIFwiLi9fRG9tYWluQ29ubmVjdGl2aXR5X3Rlc3RfMTkubWRcIjtcbmltcG9ydCBFWEFNUExFMTAsIHt0b2MgYXMgX190b2NFWEFNUExFMTB9IGZyb20gXCIuL19Eb21haW5Db25uZWN0aXZpdHlfdGVzdF8yMC5tZFwiO1xuZXhwb3J0IGNvbnN0IHRvYyA9IFt7XG4gIFwidmFsdWVcIjogXCJJbnRlcmZhY2UxXCIsXG4gIFwiaWRcIjogXCJpbnRlcmZhY2UxXCIsXG4gIFwibGV2ZWxcIjogMlxufSwgLi4uX190b2NFWEFNUExFNDYsIC4uLl9fdG9jRVhBTVBMRTQ3LCAuLi5fX3RvY0VYQU1QTEUzLCAuLi5fX3RvY0VYQU1QTEU0LCAuLi5fX3RvY0VYQU1QTEU1LCAuLi5fX3RvY0VYQU1QTEU2LCAuLi5fX3RvY0VYQU1QTEU3LCAuLi5fX3RvY0VYQU1QTEU4LCB7XG4gIFwidmFsdWVcIjogXCJJbnRlcmZhY2UyXCIsXG4gIFwiaWRcIjogXCJpbnRlcmZhY2UyXCIsXG4gIFwibGV2ZWxcIjogMlxufSwgLi4uX190b2NFWEFNUExFOSwgLi4uX190b2NFWEFNUExFMTBdO1xuZnVuY3Rpb24gX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpIHtcbiAgY29uc3QgX2NvbXBvbmVudHMgPSB7XG4gICAgYTogXCJhXCIsXG4gICAgYWRtb25pdGlvbjogXCJhZG1vbml0aW9uXCIsXG4gICAgY29kZTogXCJjb2RlXCIsXG4gICAgaDE6IFwiaDFcIixcbiAgICBoMjogXCJoMlwiLFxuICAgIGhlYWRlcjogXCJoZWFkZXJcIixcbiAgICBsaTogXCJsaVwiLFxuICAgIHA6IFwicFwiLFxuICAgIHByZTogXCJwcmVcIixcbiAgICBzdHJvbmc6IFwic3Ryb25nXCIsXG4gICAgdWw6IFwidWxcIixcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBfanN4cyhfRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuaGVhZGVyLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5oMSwge1xuICAgICAgICBpZDogXCJpbml0aWF0ZWNlbGx0b2NlbGxkYXRhXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkluaXRpYXRlQ2VsbFRvQ2VsbERhdGFcIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIlRoaXMgcm91dGluZSBpbml0aWF0ZXMgY2VsbFRvQ2VsbCBkYXRhIChtYXBwaW5nKSBiZXR3ZWVuIHR3byBcIiwgX2pzeChfY29tcG9uZW50cy5hLCB7XG4gICAgICAgIGhyZWY6IFwiL2RvY3MtYXBpL0RvbWFpbi9Eb21haW5fXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkRvbWFpbl9cIlxuICAgICAgfSksIFwiIG9yIFwiLCBfanN4KF9jb21wb25lbnRzLmEsIHtcbiAgICAgICAgaHJlZjogXCIvZG9jcy1hcGkvTWVzaC9NZXNoX1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJNZXNoX1wiXG4gICAgICB9KSwgXCIuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFwiVGhlIHRvcG9sb2d5IG9mIGVsZW1lbnRzIGluIGJvdGggbWVzaGVzIHNob3VsZCBiZSB0aGUgc2FtZSwgdGhpcyBtZWFucyB0aGF0IGlmIG9uZSBtZXNoIGlzIG1hZGUgb2YgdHJpYW5nbGVzIHRoZW4gb3RoZXIgbWVzaCBzaG91bGQgYmUgbWFkZSBvZiB0cmlhbmdsZXMuXCJcbiAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW1wiVGhlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJ4aWRpbVwiXG4gICAgICAgIH0pLCBcIiBvZiB0aGUgZWxlbWVudHMgaW4gYm90aCBtZXNoZXMgc2hvdWxkIGJlIHRoZSBzYW1lLCB0aGlzIG1lYW5zIHRoYXQgaWYgdGhlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJtZXNoMVwiXG4gICAgICAgIH0pLCBcIiBpcyBzdXJmYWNlIG1lc2ggdGhlbiBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwibWVzaDJcIlxuICAgICAgICB9KSwgXCIgc2hvdWxkIGJlIGEgc3VyZmFjZSBtZXNoLlwiXVxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJUaGlzIHJvdXRpbmUgbmVlZHMgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIm5vZGVUb05vZGVcIlxuICAgICAgICB9KSwgXCIgaW5mb3JtYXRpb24sIHNvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWF0ZWQgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0aW5lLlwiXVxuICAgICAgfSksIFwiXFxuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImludGVyZmFjZTFcIixcbiAgICAgIGNoaWxkcmVuOiBcIkludGVyZmFjZTFcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJJTlRFUkZBQ0VcXG4gIE1PRFVMRSBTVUJST1VUSU5FIGRjX2luaXRpYXRlQ2VsbFRvQ2VsbERhdGExKG9iaiwgZG9tYWluMSwgZG9tYWluMiwgJlxcbiAgICAmIGRpbTEsIGRpbTIsIGVudGl0eU51bTEsIGVudGl0eU51bTIpXFxuICAgIENMQVNTKERvbWFpbkNvbm5lY3Rpdml0eV8pLCBJTlRFTlQoSU5PVVQpIDo6IG9ialxcbiAgICAhISBEb21haW4gY29ubmVjdGl2aXR5IG9iamVjdCxcXG4gICAgISEgW1tEb21haW5Db25uZWN0aXZpdHk6Y2VsbFRvQ2VsbF1dIHdpbGwgYmUgaW5pdGlhdGVkXFxuICAgIENMQVNTKERvbWFpbl8pLCBJTlRFTlQoSU4pIDo6IGRvbWFpbjFcXG4gICAgISEgUHJpbWFyeSBkb21haW4sIGluIGNlbGxUb0NlbGwoaSksIGkgZGVub3RlcyB0aGVcXG4gICAgISEgZ2xvYmFsIGVsZW1lbnQgbnVtYmVyIGluIGRvbWFpbjEgZG9tYWluLlxcbiAgICBDTEFTUyhEb21haW5fKSwgSU5URU5UKElOKSA6OiBkb21haW4yXFxuICAgICEhIHNlY29uZGFyeSBkb21haW4sID0+IGNlbGxUb0NlbGwoaSkgZGVub3RlcyB0aGVcXG4gICAgISEgZ2xvYmFsIGNlbGwgbnVtYmVyIGluIGBkb21haW4yYCBkb21haW4uXFxuICAgIElOVEVHRVIoSTRCKSwgSU5URU5UKElOKSA6OiBkaW0xXFxuICAgICEhIGRpbWVuc2lvbiBvZiBtZXNoIGluIGRvbWFpbjFcXG4gICAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU4pIDo6IGRpbTJcXG4gICAgISEgZGltZW5zaW9uIG9mIG1lc2ggaW4gZG9tYWluMlxcbiAgICBJTlRFR0VSKEk0QiksIElOVEVOVChJTikgOjogZW50aXR5TnVtMVxcbiAgICAhISBlbnRpdHkgbnVtIG9mIG1lc2ggaW4gZG9tYWluMVxcbiAgICBJTlRFR0VSKEk0QiksIElOVEVOVChJTikgOjogZW50aXR5TnVtMlxcbiAgICAhISBlbnRpdHkgbnVtIG9mIG1lc2ggaW4gZG9tYWluMlxcbiAgRU5EIFNVQlJPVVRJTkUgZGNfaW5pdGlhdGVDZWxsVG9DZWxsRGF0YTFcXG5FTkQgSU5URVJGQUNFXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBzdWJyb3V0aW5lIGdlbmVyYXRlcyB0aGUgY2VsbCB0byBjZWxsIGNvbm5lY3Rpdml0eSBiZXR3ZWVuIHR3byBtZXNoZXMuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJvYmolY2VsbFRvQ2VsbFwiXG4gICAgICAgIH0pLCBcIiB3aWxsIGJlIGluaXRpYXRlZFwiXVxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiZG9tYWluMVwiXG4gICAgICAgIH0pLCBcIiBtYWluIGRvbWFpblwiXVxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiZG9tYWluMlwiXG4gICAgICAgIH0pLCBcIiBzZWNvbmRhcnkgZG9tYWluXCJdXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJkaW0xLCBlbnRpdHludW0xXCJcbiAgICAgICAgfSksIFwiIGRpbWVuc2lvbiBhbmQgZW50aXR5IG51bWJlciBvZiBtZXNoIGluIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJkb21haW4xXCJcbiAgICAgICAgfSldXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJkaW0yLCBlbnRpdHludW0yXCJcbiAgICAgICAgfSksIFwiIGRpbWVuc2lvbiBhbmQgZW50aXR5IG51bWJlciBvZiBtZXNoIGluIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJkb21haW4yXCJcbiAgICAgICAgfSldXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJGb2xsb3dpbmcgcG9pbnRzIHNob3VsZCBiZSBub3RlZFwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFwiVGhlIHRvcG9sb2d5IG9mIGVsZW1lbnRzIGluIGJvdGggbWVzaGVzIHNob3VsZCBiZSB0aGUgc2FtZSwgdGhpcyBtZWFucyB0aGF0IGlmIG9uZSBtZXNoIGlzIHRyaWFuZ2xlIHRoZW4gb3RoZXIgbWVzaCBzaG91bGQgYmUgYSB0cmlhbmdsZS5cIlxuICAgICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFwiVGhlIHhpZGltIG9mIHRoZSBlbGVtZW50cyBpbiBib3RoIG1lc2hlcyBzaG91bGQgYmUgdGhlIHNhbWUsIHRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgbWVzaDEgaXMgc3VyZmFjZSBtZXNoIHRoZW4gbWVzaDIgc2hvdWxkIGJlIGEgc3VyZmFjZSBtZXNoLlwiXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtcIlRoaXMgcm91dGluZSBuZWVkcyBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwibm9kZVRvTm9kZVwiXG4gICAgICAgIH0pLCBcIiBpbmZvcm1hdGlvbiwgc28gbWFrZSBzdXJlIGl0IGlzIGluaXRpYXRlZCBiZWZvcmUgY2FsbGluZyB0aGlzIHJvdXRpbmUuXCJdXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgXCJcXG5cIiwgX2pzeHMoVGFicywge1xuICAgICAgY2hpbGRyZW46IFtfanN4KFRhYkl0ZW0sIHtcbiAgICAgICAgdmFsdWU6IFwiMVwiLFxuICAgICAgICBsYWJlbDogXCLvuI/cgCBFeGFtcGxlIDFcIixcbiAgICAgICAgY2hpbGRyZW46IF9qc3goRVhBTVBMRTQ2LCB7fSlcbiAgICAgIH0pLCBfanN4KFRhYkl0ZW0sIHtcbiAgICAgICAgdmFsdWU6IFwiMlwiLFxuICAgICAgICBsYWJlbDogXCLvuI/cgCBFeGFtcGxlIDJcIixcbiAgICAgICAgY2hpbGRyZW46IF9qc3goRVhBTVBMRTQ3LCB7fSlcbiAgICAgIH0pLCBfanN4KFRhYkl0ZW0sIHtcbiAgICAgICAgdmFsdWU6IFwiM1wiLFxuICAgICAgICBsYWJlbDogXCLvuI/cgCBFeGFtcGxlIDNcIixcbiAgICAgICAgY2hpbGRyZW46IF9qc3goRVhBTVBMRTMsIHt9KVxuICAgICAgfSksIF9qc3goVGFiSXRlbSwge1xuICAgICAgICB2YWx1ZTogXCI0XCIsXG4gICAgICAgIGxhYmVsOiBcIu+4j9yAIEV4YW1wbGUgNFwiLFxuICAgICAgICBjaGlsZHJlbjogX2pzeChFWEFNUExFNCwge30pXG4gICAgICB9KSwgX2pzeChUYWJJdGVtLCB7XG4gICAgICAgIHZhbHVlOiBcIjVcIixcbiAgICAgICAgbGFiZWw6IFwi77iP3IAgRXhhbXBsZSA1XCIsXG4gICAgICAgIGNoaWxkcmVuOiBfanN4KEVYQU1QTEU1LCB7fSlcbiAgICAgIH0pLCBfanN4KFRhYkl0ZW0sIHtcbiAgICAgICAgdmFsdWU6IFwiY2xvc2VcIixcbiAgICAgICAgbGFiZWw6IFwi4oaiXCIsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pXVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhUYWJzLCB7XG4gICAgICBjaGlsZHJlbjogW19qc3goVGFiSXRlbSwge1xuICAgICAgICB2YWx1ZTogXCI2XCIsXG4gICAgICAgIGxhYmVsOiBcIu+4j9yAIEV4YW1wbGUgNlwiLFxuICAgICAgICBjaGlsZHJlbjogX2pzeChFWEFNUExFNiwge30pXG4gICAgICB9KSwgX2pzeChUYWJJdGVtLCB7XG4gICAgICAgIHZhbHVlOiBcIjdcIixcbiAgICAgICAgbGFiZWw6IFwi77iP3IAgRXhhbXBsZSA3XCIsXG4gICAgICAgIGNoaWxkcmVuOiBfanN4KEVYQU1QTEU3LCB7fSlcbiAgICAgIH0pLCBfanN4KFRhYkl0ZW0sIHtcbiAgICAgICAgdmFsdWU6IFwiOFwiLFxuICAgICAgICBsYWJlbDogXCLvuI/cgCBFeGFtcGxlIDhcIixcbiAgICAgICAgY2hpbGRyZW46IF9qc3goRVhBTVBMRTgsIHt9KVxuICAgICAgfSksIF9qc3goVGFiSXRlbSwge1xuICAgICAgICB2YWx1ZTogXCJjbG9zZVwiLFxuICAgICAgICBsYWJlbDogXCLihqJcIixcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSldXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImludGVyZmFjZTJcIixcbiAgICAgIGNoaWxkcmVuOiBcIkludGVyZmFjZTJcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJJTlRFUkZBQ0VcXG4gIE1PRFVMRSBTVUJST1VUSU5FIGRjX0luaXRpYXRlQ2VsbFRvQ2VsbERhdGEyKG9iaiwgZG9tYWluMSwgZG9tYWluMilcXG4gICAgQ0xBU1MoRG9tYWluQ29ubmVjdGl2aXR5XyksIElOVEVOVChJTk9VVCkgOjogb2JqXFxuICAgICEhIERvbWFpbiBjb25uZWN0aXZpdHkgb2JqZWN0XFxuICAgIENMQVNTKERvbWFpbl8pLCBJTlRFTlQoSU4pIDo6IGRvbWFpbjFcXG4gICAgISEgUHJpbWFyeSBkb21haW4sIGluIENlbGxUb0NlbGwoaSksIGkgZGVub3RlcyB0aGVcXG4gICAgISEgZ2xvYmFsIGVsZW1lbnQgbnVtYmVyIGluIGRvbWFpbjEgZG9tYWluLlxcbiAgICBDTEFTUyhEb21haW5fKSwgSU5URU5UKElOKSA6OiBkb21haW4yXFxuICAgICEhIFNlY29uZGFyeSBkb21haW4gPT4gQ2VsbFRvQ2VsbChpKSBkZW5vdGVzIHRoZVxcbiAgICAhISBnbG9iYWwgZWxlbWVudCBudW1iZXIgaW4gZG9tYWluMiBkb21haW4uXFxuICBFTkQgU1VCUk9VVElORSBkY19Jbml0aWF0ZUNlbGxUb0NlbGxEYXRhMlxcbkVORCBJTlRFUkZBQ0VcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIHN1YnJvdXRpbmUgZ2VuZXJhdGVzIHRoZSBjZWxsIHRvIGNlbGwgY29ubmVjdGl2aXR5IGJldHdlZW5cXG50d28gZG9tYWlucy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy51bCwge1xuICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIm9iaiVjZWxsVG9DZWxsXCJcbiAgICAgICAgfSksIFwiIHdpbGwgYmUgaW5pdGlhdGVkXCJdXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJkb21haW4xXCJcbiAgICAgICAgfSksIFwiIG1haW4gZG9tYWluXCJdXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJkb21haW4yXCJcbiAgICAgICAgfSksIFwiIHNlY29uZGFyeSBkb21haW5cIl1cbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmFkbW9uaXRpb24sIHtcbiAgICAgIHR5cGU6IFwibm90ZVwiLFxuICAgICAgY2hpbGRyZW46IF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgICAgY2hpbGRyZW46IFtcIkFsbCBcIiwgX2pzeChfY29tcG9uZW50cy5zdHJvbmcsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJDRUxMXCJcbiAgICAgICAgfSksIFwiIGVsZW1lbnRzIGluIGRvbWFpbi0xIHdpbGwgYmUgbWFwcGVkIHRvIFwiLCBfanN4KF9jb21wb25lbnRzLnN0cm9uZywge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIkNFTExcIlxuICAgICAgICB9KSwgXCIgZWxlbWVudHMgaW4gZG9tYWluLTIuXCJdXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmFkbW9uaXRpb24sIHtcbiAgICAgIHR5cGU6IFwiaW5mb1wiLFxuICAgICAgY2hpbGRyZW46IF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgICAgY2hpbGRyZW46IFtcIklmIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJjZWxsVG9DZWxsKGllbClcIlxuICAgICAgICB9KSwgXCIgaXMgZXF1YWwgdG8gemVybyB0aGVuIGl0IG1lYW5zIHRoZXJlIGlzIG5vIGVsZW1lbnQgZm91bmQgaW4gZG9tYWluLTIgY29ycmVzcG9uZGluZyB0byBlbGVtZW50IG51bWJlciBpZWwgaW4gZG9tYWluLTEuXCJdXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmFkbW9uaXRpb24sIHtcbiAgICAgIHR5cGU6IFwibm90ZVwiLFxuICAgICAgY2hpbGRyZW46IF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgICAgY2hpbGRyZW46IFtcIlRoZSBzaXplIG9mIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJjZWxsVG9DZWxsXCJcbiAgICAgICAgfSksIFwiIGlzIHRoZSBsYXJnZXN0IGVsZW1lbnQgbnVtYmVyIHByZXNlbnQgaW4gZG9tYWluMS5cIl1cbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuYWRtb25pdGlvbiwge1xuICAgICAgdGl0bGU6IFwiVE9ET1wiLFxuICAgICAgdHlwZTogXCJpbmZvXCIsXG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIkN1cnJlbnRseSwgbG93ZXJib3VuZCBhbmQgdXBwZXIgYm91bmQgb2YgY2VsbFRvQ2VsbCBpcyAxIGFuZCBkb21haW4xJW1heEVsZW1OdW1iZXIuIEluIHRoZSBmdXR1cmUsIHRoZSBsb3dlciBib3VuZCB3aWxsIGJlIGRvbWFpbjElbWluRWxlbU51bWJlci5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJGb2xsb3dpbmcgcG9pbnRzIHNob3VsZCBiZSBub3RlZCBiZWZvcmUgY2FsbGluZyB0aGlzIHJvdXRpbmVcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy51bCwge1xuICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIlRoaXMgcm91dGluZSBwcm92aWRlcyBtYXAgYmV0d2VlbiBjZWxsIGVsZW1lbnRzIG9mIG9uZSBkb21haW4gdG8gY2VsbCBlbGVtZW50cyBvZiBhbm90aGVyIGRvbWFpbi5cIlxuICAgICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFwiVGhlIHRvcG9sb2d5IG9mIHRoZSBib3RoIGVsZW1lbnRzIHNob3VsZCBiZSB0aGUgc2FtZVwiXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJUaGVyZSBpcyBvbmUgdG8gb25lIG1hcHBpbmcgYmV0d2VlbiBlbGVtZW50cyBvZiBkb21haW4gMSBhbmQgZWxlbWVudHMgb2YgZG9tYWluMlwiXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJUaGlzIHJvdXRpbmUgd29ya3Mgd2VsbCBmb3IgdHdvIGRvbWFpbnMgb2Ygc2FtZSByZWdpb24gd2l0aCBzYW1lL2RpZmZlcmVudCBvcmRlci4gRm9yIGV4YW1wbGUsIGRvbWFpbiBvZiB0cmkzIGFuZCBkb21haW4gb2YgdHJpNiBlbGVtZW50cy5cIlxuICAgICAgfSksIFwiXFxuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKFRhYnMsIHtcbiAgICAgIGNoaWxkcmVuOiBbX2pzeChUYWJJdGVtLCB7XG4gICAgICAgIHZhbHVlOiBcIjFcIixcbiAgICAgICAgbGFiZWw6IFwi77iP3IAgRXhhbXBsZSAxXCIsXG4gICAgICAgIGNoaWxkcmVuOiBfanN4KEVYQU1QTEU5LCB7fSlcbiAgICAgIH0pLCBfanN4KFRhYkl0ZW0sIHtcbiAgICAgICAgdmFsdWU6IFwiMlwiLFxuICAgICAgICBsYWJlbDogXCLvuI/cgCBFeGFtcGxlIDJcIixcbiAgICAgICAgY2hpbGRyZW46IF9qc3goRVhBTVBMRTEwLCB7fSlcbiAgICAgIH0pLCBfanN4KFRhYkl0ZW0sIHtcbiAgICAgICAgdmFsdWU6IFwiY2xvc2VcIixcbiAgICAgICAgbGFiZWw6IFwi4oaiXCIsXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0pXVxuICAgIH0pXVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMgPSB7fSkge1xuICBjb25zdCB7d3JhcHBlcjogTURYTGF5b3V0fSA9IHtcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBNRFhMYXlvdXQgPyBfanN4KE1EWExheW91dCwge1xuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiBfanN4KF9jcmVhdGVNZHhDb250ZW50LCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gIH0pIDogX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./docs/docs-api/DomainConnectivity/InitiateCellToCellData.md\n");

/***/ })

}]);