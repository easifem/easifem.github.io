"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkeasifem_docs"] = globalThis["webpackChunkeasifem_docs"] || []).push([["content---docs-api-super-lu-formats-0-b-3-e46"],{

/***/ "./docs/docs-api/SuperLU/formats.md":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  assets: () => (/* binding */ assets),\n  contentTitle: () => (/* binding */ contentTitle),\n  \"default\": () => (/* binding */ MDXContent),\n  frontMatter: () => (/* binding */ frontMatter),\n  metadata: () => (/* reexport */ site_docs_docs_api_super_lu_formats_md_0b3_namespaceObject),\n  toc: () => (/* binding */ toc)\n});\n\n;// ./.docusaurus/docusaurus-plugin-content-docs/docs-api/site-docs-docs-api-super-lu-formats-md-0b3.json\nconst site_docs_docs_api_super_lu_formats_md_0b3_namespaceObject = /*#__PURE__*/JSON.parse('{\"id\":\"SuperLU/formats\",\"title\":\"Formats\",\"description\":\"Yesnot\",\"source\":\"@site/docs/docs-api/SuperLU/formats.md\",\"sourceDirName\":\"SuperLU\",\"slug\":\"/SuperLU/formats\",\"permalink\":\"/docs-api/SuperLU/formats\",\"draft\":false,\"unlisted\":false,\"editUrl\":\"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/SuperLU/formats.md\",\"tags\":[],\"version\":\"current\",\"lastUpdatedAt\":1539502055000,\"frontMatter\":{},\"sidebar\":\"tutorialSidebar\",\"previous\":{\"title\":\"Utility\",\"permalink\":\"/docs-api/SuperLU/dutil\"},\"next\":{\"title\":\"Options\",\"permalink\":\"/docs-api/SuperLU/options\"}}');\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(\"./node_modules/react/jsx-runtime.js\");\n// EXTERNAL MODULE: ./node_modules/@mdx-js/react/lib/index.js\nvar lib = __webpack_require__(\"./node_modules/@mdx-js/react/lib/index.js\");\n;// ./docs/docs-api/SuperLU/formats.md\n\n\nconst frontMatter = {};\nconst contentTitle = 'Formats';\n\nconst assets = {\n\n};\n\n\n\nconst toc = [{\n  \"value\": \"Yes_no_t\",\n  \"id\": \"yes_no_t\",\n  \"level\": 2\n}, {\n  \"value\": \"Fact_t\",\n  \"id\": \"fact_t\",\n  \"level\": 2\n}, {\n  \"value\": \"RowPerm_t\",\n  \"id\": \"rowperm_t\",\n  \"level\": 2\n}, {\n  \"value\": \"ColPerm_t\",\n  \"id\": \"colperm_t\",\n  \"level\": 2\n}, {\n  \"value\": \"Trans_t\",\n  \"id\": \"trans_t\",\n  \"level\": 2\n}, {\n  \"value\": \"DiagScale_t\",\n  \"id\": \"diagscale_t\",\n  \"level\": 2\n}, {\n  \"value\": \"IterRefine_t\",\n  \"id\": \"iterrefine_t\",\n  \"level\": 2\n}, {\n  \"value\": \"MemType_t\",\n  \"id\": \"memtype_t\",\n  \"level\": 2\n}, {\n  \"value\": \"Stack_end_t\",\n  \"id\": \"stack_end_t\",\n  \"level\": 2\n}, {\n  \"value\": \"LU_space_t\",\n  \"id\": \"lu_space_t\",\n  \"level\": 2\n}, {\n  \"value\": \"Norm_t\",\n  \"id\": \"norm_t\",\n  \"level\": 2\n}, {\n  \"value\": \"Milu_t\",\n  \"id\": \"milu_t\",\n  \"level\": 2\n}, {\n  \"value\": \"MType_t\",\n  \"id\": \"mtype_t\",\n  \"level\": 2\n}, {\n  \"value\": \"DType_t\",\n  \"id\": \"dtype_t\",\n  \"level\": 2\n}, {\n  \"value\": \"SType_t\",\n  \"id\": \"stype_t\",\n  \"level\": 2\n}, {\n  \"value\": \"NCFormat\",\n  \"id\": \"ncformat\",\n  \"level\": 2\n}, {\n  \"value\": \"NRFormat\",\n  \"id\": \"nrformat\",\n  \"level\": 2\n}, {\n  \"value\": \"SCformat\",\n  \"id\": \"scformat\",\n  \"level\": 2\n}, {\n  \"value\": \"SCPformat\",\n  \"id\": \"scpformat\",\n  \"level\": 2\n}, {\n  \"value\": \"NCPformat\",\n  \"id\": \"ncpformat\",\n  \"level\": 2\n}, {\n  \"value\": \"DNformat\",\n  \"id\": \"dnformat\",\n  \"level\": 2\n}, {\n  \"value\": \"<code>superlu_options_t</code>\",\n  \"id\": \"superlu_options_t\",\n  \"level\": 2\n}, {\n  \"value\": \"SuperLUStat_t\",\n  \"id\": \"superlustat_t\",\n  \"level\": 2\n}];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    header: \"header\",\n    pre: \"pre\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.header, {\n      children: (0,jsx_runtime.jsx)(_components.h1, {\n        id: \"formats\",\n        children: \"Formats\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"yes_no_t\",\n      children: \"Yes_no_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: yes_no_\\n  INTEGER(C_INT) :: NO, YES\\nEND TYPE yes_no_\\n\\nTYPE(yes_no_), PUBLIC, PARAMETER :: yes_no_t = yes_no_(NO, YES)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"fact_t\",\n      children: \"Fact_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: fact_\\n  INTEGER(C_INT) :: DOFACT, SamePattern, SamePattern_SameRowPerm, FACTORED\\nEND TYPE fact_\\n\\nTYPE(fact_), PUBLIC, PARAMETER :: fact_t = fact_(&\\n  & DOFACT, SamePattern, SamePattern_SameRowPerm, FACTORED)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"rowperm_t\",\n      children: \"RowPerm_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: rowperm_\\n  INTEGER(C_INT) :: NOROWPERM, LargeDiag_MC64, LargeDiag_HWPM, MY_PERMR\\nEND TYPE rowperm_\\n\\nTYPE(rowperm_), PUBLIC, PARAMETER :: rowperm_t = rowperm_( &\\n  & NOROWPERM, LargeDiag_MC64, LargeDiag_HWPM, MY_PERMR)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"colperm_t\",\n      children: \"ColPerm_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: colperm_\\n  INTEGER(C_INT) :: NATURAL, MMD_ATA, MMD_AT_PLUS_A, COLAMD, &\\n   & METIS_AT_PLUS_A, PARMETIS, ZOLTAN, MY_PERMC\\nEND TYPE\\n\\nTYPE(colperm_), PUBLIC, PARAMETER :: colperm_t = colperm_(&\\n  & NATURAL, MMD_ATA, MMD_AT_PLUS_A, COLAMD, &\\n  & METIS_AT_PLUS_A, PARMETIS, ZOLTAN, MY_PERMC)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"trans_t\",\n      children: \"Trans_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: trans_\\n  INTEGER(C_INT) :: NOTRANS, TRANS, CONJ\\nEND TYPE\\n\\nTYPE(trans_), PARAMETER, PUBLIC :: trans_t = trans_(&\\n  & NOTRANS, TRANS, CONJ)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"diagscale_t\",\n      children: \"DiagScale_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: DiagScale_\\n  INTEGER(C_INT) :: NOEQUIL, ROW, COL, BOTH\\nEND TYPE\\n\\nTYPE(DiagScale_), PUBLIC, PARAMETER :: DiagScale_t = DiagScale_(&\\n& NOEQUIL, ROW, COL, BOTH)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"iterrefine_t\",\n      children: \"IterRefine_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: IterRefine_\\n  INTEGER(C_INT) :: NOREFINE, SLU_SINGLE = 1, SLU_DOUBLE, SLU_EXTRA\\nEND TYPE\\n\\nTYPE(IterRefine_), PUBLIC, PARAMETER :: IterRefine_t = IterRefine_(&\\n  & NOREFINE, SLU_SINGLE, SLU_DOUBLE, SLU_EXTRA)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"memtype_t\",\n      children: \"MemType_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: MemType_\\n  INTEGER(C_INT) :: USUB, LSUB, UCOL, LUSUP, LLVL, ULVL, NO_MEMTYPE\\nEND TYPE MemType_\\n\\nTYPE(MemType_), PUBLIC, PARAMETER :: MemType_t = MemType_(&\\n  & USUB, LSUB, UCOL, LUSUP, LLVL, ULVL, NO_MEMTYPE)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"stack_end_t\",\n      children: \"Stack_end_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: stack_end_\\n  INTEGER(C_INT) :: HEAD, TAIL\\nEND TYPE\\n\\nTYPE(stack_end_), PUBLIC, PARAMETER :: stack_end_t = stack_end_(&\\n & HEAD, TAIL)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"lu_space_t\",\n      children: \"LU_space_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: LU_space_\\n  INTEGER(C_INT) :: SYSTEM, USER\\nEND TYPE\\n\\nTYPE(LU_space_), PARAMETER, PUBLIC :: LU_space_t = LU_space_(&\\n& SYSTEM, USER)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"norm_t\",\n      children: \"Norm_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: norm_\\n  INTEGER(C_INT) :: ONE_NORM, TWO_NORM, INF_NORM\\nEND TYPE\\n\\nTYPE(norm_), PUBLIC, PARAMETER :: norm_t = norm_(&\\n & ONE_NORM, TWO_NORM, INF_NORM)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"milu_t\",\n      children: \"Milu_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: milu_\\n  INTEGER(C_INT) :: SILU, SMILU_1, SMILU_2, SMILU_3\\nEND TYPE milu_\\n\\nTYPE(milu_), PARAMETER, PUBLIC :: milu_t = milu_(&\\n  &  SILU, SMILU_1, SMILU_2, SMILU_3)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"mtype_t\",\n      children: \"MType_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: Mtype_\\n  INTEGER(C_INT) :: SLU_GE\\n  INTEGER(C_INT) :: SLU_TRLU\\n  INTEGER(C_INT) :: SLU_TRUU\\n  INTEGER(C_INT) :: SLU_TRL\\n  INTEGER(C_INT) :: SLU_TRU\\n  INTEGER(C_INT) :: SLU_SYL\\n  INTEGER(C_INT) :: SLU_SYU\\n  INTEGER(C_INT) :: SLU_HEL\\n  INTEGER(C_INT) :: SLU_HEU\\nEND TYPE Mtype_\\n\\n\\nTYPE(Mtype_), PUBLIC, PARAMETER :: Mtype_t = Mtype_(&\\n  & SLU_GE=SLU_GE, &\\n  & SLU_TRLU=SLU_TRLU, &\\n  & SLU_TRUU=SLU_TRUU, &\\n  & SLU_TRL=SLU_TRL, &\\n  & SLU_TRU=SLU_TRU, &\\n  & SLU_SYL=SLU_SYL, &\\n  & SLU_SYU=SLU_SYU, &\\n  & SLU_HEL=SLU_HEL, &\\n  & SLU_HEU=SLU_HEU)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"dtype_t\",\n      children: \"DType_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: Dtype_\\n  INTEGER(C_INT) :: SLU_S\\n  INTEGER(C_INT) :: SLU_D\\n  INTEGER(C_INT) :: SLU_C\\n  INTEGER(C_INT) :: SLU_Z\\nEND TYPE Dtype_\\n\\n\\nTYPE(Dtype_), PARAMETER, PUBLIC :: Dtype_t = Dtype_(&\\n  & SLU_S=SLU_S, &\\n  & SLU_D=SLU_D, &\\n  & SLU_C=SLU_C, &\\n  & SLU_Z=SLU_Z)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"stype_t\",\n      children: \"SType_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: Stype_\\n  INTEGER(C_INT) :: SLU_NC\\n  INTEGER(C_INT) :: SLU_NCP\\n  INTEGER(C_INT) :: SLU_NR\\n  INTEGER(C_INT) :: SLU_SC\\n  INTEGER(C_INT) :: SLU_SCP\\n  INTEGER(C_INT) :: SLU_SR\\n  INTEGER(C_INT) :: SLU_DN\\n  INTEGER(C_INT) :: SLU_NR_LOC\\nEND TYPE Stype_\\n\\n\\nTYPE(Stype_), PARAMETER, PUBLIC :: Stype_t = Stype_(&\\n  & SLU_NC=SLU_NC, &\\n  & SLU_NCP=SLU_NCP, &\\n  & SLU_NR=SLU_NR, &\\n  & SLU_SC=SLU_SC, &\\n  & SLU_SCP=SLU_SCP, &\\n  & SLU_SR=SLU_SR, &\\n  & SLU_DN=SLU_DN, &\\n  & SLU_NR_LOC=SLU_NR_LOC &\\n  & )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"ncformat\",\n      children: \"NCFormat\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"! typedef struct {\\n!   int_t nnz;     /* number of nonzeros in the matrix */\\n!   void *nzval;   /* pointer to array of nonzero values, packed by column */\\n!   int_t *rowind; /* pointer to array of row indices of the nonzeros */\\n!   int_t *colptr; /* pointer to array of beginning of columns in nzval[]\\n!                     and rowind[]  */\\n!                  /* Note:\\n!                     Zero-based indexing is used;\\n!                     colptr[] has ncol+1 entries, the last one pointing\\n!                     beyond the last column, so that colptr[ncol] = nnz. */\\n! } NCformat;\\n\\nTYPE, BIND(c) :: NCformat\\n  INTEGER(C_INT) :: nnz\\n  TYPE(C_PTR) :: nzval\\n  TYPE(C_PTR) :: rowind\\n  TYPE(C_PTR) :: colptr\\nEND TYPE NCformat\\n\\nPUBLIC :: NCformat\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"nrformat\",\n      children: \"NRFormat\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"! typedef struct {\\n!   int_t nnz;     /* number of nonzeros in the matrix */\\n!   void *nzval;   /* pointer to array of nonzero values, packed by raw */\\n!   int_t *colind; /* pointer to array of columns indices of the nonzeros */\\n!   int_t *rowptr; /* pointer to array of beginning of rows in nzval[]\\n!                     and colind[]  */\\n!                  /* Note:\\n!                     Zero-based indexing is used;\\n!                     rowptr[] has nrow+1 entries, the last one pointing\\n!                     beyond the last row, so that rowptr[nrow] = nnz. */\\n! } NRformat;\\n\\nTYPE, BIND(c) :: NRformat\\n  INTEGER(C_INT) :: nnz\\n  TYPE(C_PTR) :: nzval\\n  TYPE(C_PTR) :: colind\\n  TYPE(C_PTR) :: rowptr\\nEND TYPE NRformat\\n\\nPUBLIC :: NRformat\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"scformat\",\n      children: \"SCformat\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"! typedef struct {\\n!   int_t nnz;    /* number of nonzeros in the matrix */\\n!   int_t nsuper; /* number of supernodes, minus 1 */\\n!   void *nzval;  /* pointer to array of nonzero values, packed by column */\\n!   int_t *nzval_colptr; /* pointer to array of beginning of columns in nzval[] */\\n!   int_t *rowind;       /* pointer to array of compressed row indices of\\n!                           rectangular supernodes */\\n!   int_t\\n!       *rowind_colptr; /* pointer to array of beginning of columns in rowind[] */\\n!   int_t *col_to_sup;  /* col_to_sup[j] is the supernode number to which column\\n!                        j belongs; mapping from column to supernode number. */\\n!   int_t *sup_to_col;  /* sup_to_col[s] points to the start of the s-th\\n!                        supernode; mapping from supernode number to column.\\n!                        e.g.: col_to_sup: 0 1 2 2 3 3 3 4 4 4 4 4 4 (ncol=12)\\n!                              sup_to_col: 0 1 2 4 7 12           (nsuper=4) */\\n!                       /* Note:\\n!                          Zero-based indexing is used;\\n!                          nzval_colptr[], rowind_colptr[], col_to_sup and\\n!                          sup_to_col[] have ncol+1 entries, the last one\\n!                          pointing beyond the last column.\\n!                          For col_to_sup[], only the first ncol entries are\\n!                          defined. For sup_to_col[], only the first nsuper+2\\n!                          entries are defined. */\\n! } SCformat;\\n!\\n\\nTYPE, BIND(c) :: SCformat\\n  INTEGER(C_INT) :: nnz\\n  INTEGER(C_INT) :: nsuper\\n  TYPE(C_PTR) :: nzval\\n  TYPE(C_PTR) :: nzval_colptr\\n  TYPE(C_PTR) :: rowind\\n  TYPE(C_PTR) :: rowind_colptr\\n  TYPE(C_PTR) :: col_to_sup\\n  TYPE(C_PTR) :: sup_to_col\\nEND TYPE SCformat\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"scpformat\",\n      children: \"SCPformat\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"! typedef struct {\\n!   int_t nnz;    /*number of nonzeros in the matrix*/\\n!   int_t nsuper; /*number of supernodes*/\\n!   void *nzval;  /* pointer to array of nonzero values, packed by column */\\n!   int_t*nzval_colbeg;  /*nzval_colbeg[j] points to beginning of column j\\n!                            in nzval[]*/\\n!   int_t *nzval_colend;  /* nzval_colend[j] points to one past the last element\\n!                            of column j in nzval[] */\\n!   int_t*rowind;        /*pointer to array of compressed row indices of\\n!                            rectangular supernodes*/\\n!   int_t *rowind_colbeg; /* rowind_colbeg[j] points to beginning of column j\\n!                            in rowind[] */\\n!   int_t*rowind_colend; /*rowind_colend[j] points to one past the last element\\n!                            of column j in rowind[]*/\\n!   int_t *col_to_sup;    /* col_to_sup[j] is the supernode number to which column\\n!                            j belongs; mapping from column to supernode. */\\n!   int_t*sup_to_colbeg; /*sup_to_colbeg[s] points to the start of the s-th\\n!                            supernode; mapping from supernode to column.*/\\n!   int_t *sup_to_colend; /* sup_to_colend[s] points to one past the end of the\\n!                            s-th supernode; mapping from supernode number to\\n!                            column.\\n!                         e.g.: col_to_sup: 0 1 2 2 3 3 3 4 4 4 4 4 4 (ncol=12)\\n!                               sup_to_colbeg: 0 1 2 4 7              (nsuper=4)\\n!                               sup_to_colend: 1 2 4 7 12                    */\\n!                         /* Note:\\n!                            Zero-based indexing is used;\\n!                            nzval_colptr[], rowind_colptr[], col_to_sup and\\n!                            sup_to_col[] have ncol+1 entries, the last one\\n!                            pointing beyond the last column.         */\\n! } SCPformat;\\n\\nTYPE, BIND(c) :: SCPformat\\n  INTEGER(C_INT) :: nnz, nsuper\\n  TYPE(C_PTR) :: nzval, nzval_colbeg, nzval_colend, rowind, &\\n    & rowind_colbeg, rowindx_colend, col_to_sup, sup_to_colbeg, &\\n    & sup_to_colend\\nEND TYPE SCPformat\\n\\nPUBLIC :: SCPformat\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"ncpformat\",\n      children: \"NCPformat\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"! typedef struct {\\n!   int_t nnz;     /*number of nonzeros in the matrix*/\\n!   void *nzval;   /* pointer to array of nonzero values, packed by column */\\n!   int_t*rowind; /*pointer to array of row indices of the nonzeros*/\\n!   /*Note: nzval[]/rowind[] always have the same length*/\\n!   int_t *colbeg; /* colbeg[j] points to the beginning of column j in nzval[]\\n!                     and rowind[]  */\\n!   int_t*colend; /*colend[j] points to one past the last element of column\\n!                     j in nzval[] and rowind[]*/\\n!                  /*Note:\\n!                     Zero-based indexing is used;\\n!                     The consecutive columns of the nonzeros may not be\\n!                     contiguous in storage, because the matrix has been\\n!                     postmultiplied by a column permutation matrix.*/\\n! } NCPformat;\\n\\nTYPE, BIND(c) :: NCPformat\\n  INTEGER(C_INT) :: nnz\\n  TYPE(C_PTR) :: nzval, rowindx, colbeg, colend\\nEND TYPE NCPformat\\n\\nPUBLIC :: NCPformat\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"dnformat\",\n      children: \"DNformat\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"! typedef struct {\\n!   int_t lda;   /*leading dimension*/\\n!   void *nzval; /* array of size lda*ncol to represent a dense matrix*/\\n! } DNformat;\\n\\nTYPE, BIND(c) :: DNformat\\n  INTEGER(C_INT) :: lda\\n  TYPE(C_PTR) :: nzval\\nEND TYPE DNformat\\n\\nPUBLIC :: DNformat\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"superlu_options_t\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"superlu_options_t\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"! typedef struct {\\n!     fact_t        Fact;\\n!     yes_no_t      Equil;\\n!     colperm_t     ColPerm;\\n!     trans_t       Trans;\\n!     IterRefine_t  IterRefine;\\n!     double        DiagPivotThresh;\\n!     yes_no_t      SymmetricMode;\\n!     yes_no_t      PivotGrowth;\\n!     yes_no_t      ConditionNumber;\\n!     rowperm_t     RowPerm;\\n!     int           ILU_DropRule;\\n!     double          ILU_DropTol;    /* threshold for dropping */\\n!     double          ILU_FillFactor; /* gamma in the secondary dropping */\\n!     norm_t          ILU_Norm;       /* infinity-norm, 1-norm, or 2-norm */\\n!     double          ILU_FillTol;    /* threshold for zero pivot perturbation */\\n!     milu_t          ILU_MILU;\\n!     double          ILU_MILU_Dim;   /* Dimension of PDE (if available) */\\n!     yes_no_t      ParSymbFact;\\n!     yes_no_t      ReplaceTinyPivot; /* used in SuperLU_DIST */\\n!     yes_no_t      SolveInitialized;\\n!     yes_no_t      RefineInitialized;\\n!     yes_no_t      PrintStat;\\n!     int           nnzL, nnzU;      /* used to store nnzs for now       */\\n!     int           num_lookaheads;  /* num of levels in look-ahead      */\\n!     yes_no_t      lookahead_etree; /* use etree computed from the\\n!                                       serial symbolic factorization */\\n!     yes_no_t      SymPattern;      /* symmetric factorization          */\\n! } superlu_options_t;\\n!\\n\\nTYPE, BIND(C) :: superlu_options_t\\n  INTEGER(C_INT) :: Fact\\n  INTEGER(C_INT) :: Equil\\n  INTEGER(C_INT) :: ColPerm\\n  INTEGER(C_INT) :: Trans\\n  INTEGER(C_INT) :: IterRefine\\n  REAL(C_DOUBLE) :: DiagPivotThresh\\n  INTEGER(C_INT) :: SymmetricMode\\n  INTEGER(C_INT) :: PivotGrowth\\n  INTEGER(C_INT) :: ConditionNumber\\n  INTEGER(C_INT) :: RowPerm\\n  INTEGER(C_INT) :: ILU_DropRule\\n  REAL(C_DOUBLE) :: ILU_DropTol\\n  REAL(C_DOUBLE) :: ILU_FillFactor\\n  INTEGER(C_INT) :: ILU_Norm\\n  REAL(C_DOUBLE) :: ILU_FillTol\\n  INTEGER(C_INT) :: ILU_MILU; \\n  REAL(C_DOUBLE) :: ILU_MILU_Dim\\n  INTEGER(C_INT) :: ParSymbFact\\n  INTEGER(C_INT) :: ReplaceTinyPivot\\n  INTEGER(C_INT) :: SolveInitialized\\n  INTEGER(C_INT) :: RefineInitialized\\n  INTEGER(C_INT) :: PrintStat = 0\\n  INTEGER(C_INT) :: nnzL\\n  INTEGER(C_INT) :: nnzU\\n  INTEGER(C_INT) :: num_lookaheads\\n  INTEGER(C_INT) :: lookahead_etree\\n  INTEGER(C_INT) :: SymPattern\\nEND TYPE superlu_options_t\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"superlustat_t\",\n      children: \"SuperLUStat_t\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"! typedef struct {\\n!     int     *panel_histo; /* histogram of panel size distribution */\\n!     double  *utime;       /* running time at various phases */\\n!     flops_t *ops;         /* operation count at various phases */\\n!     int     TinyPivots;   /* number of tiny pivots */\\n!     int     RefineSteps;  /* number of iterative refinement steps */\\n!     int     expansions;   /* number of memory expansions */\\n! } SuperLUStat_t;\\n\\nTYPE, BIND(C) :: SuperLUStat_t\\n  ! INTEGER(C_INT), POINTER :: panel_histo(:)\\n  ! REAL(C_DOUBLE), POINTER :: utime(:)\\n  ! REAL(C_FLOAT), POINTER :: ops(:)\\n  TYPE(C_PTR) :: panel_histo\\n  TYPE(C_PTR) :: utime\\n  TYPE(C_PTR) :: ops\\n  INTEGER(C_INT) :: TinyPivots\\n  INTEGER(C_INT) :: RefineSteps\\n  INTEGER(C_INT) :: expansions\\nEND TYPE SuperLUStat_t\\n\\nPUBLIC :: SuperLUStat_t\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9kb2NzL2RvY3MtYXBpL1N1cGVyTFUvZm9ybWF0cy5tZCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWFzaWZlbS1kb2NzLy4vZG9jcy9kb2NzLWFwaS9TdXBlckxVL2Zvcm1hdHMubWQ/NmM2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuZXhwb3J0IGNvbnN0IGZyb250TWF0dGVyID0ge307XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gJ0Zvcm1hdHMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1ldGFkYXRhfSBmcm9tICdAc2l0ZS8uZG9jdXNhdXJ1cy9kb2N1c2F1cnVzLXBsdWdpbi1jb250ZW50LWRvY3MvZG9jcy1hcGkvc2l0ZS1kb2NzLWRvY3MtYXBpLXN1cGVyLWx1LWZvcm1hdHMtbWQtMGIzLmpzb24nXG5leHBvcnQgY29uc3QgYXNzZXRzID0ge1xuXG59O1xuXG5pbXBvcnQge0ZyYWdtZW50IGFzIF9GcmFnbWVudCwganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHN9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHt1c2VNRFhDb21wb25lbnRzIGFzIF9wcm92aWRlQ29tcG9uZW50c30gZnJvbSBcIkBtZHgtanMvcmVhY3RcIjtcbmV4cG9ydCBjb25zdCB0b2MgPSBbe1xuICBcInZhbHVlXCI6IFwiWWVzX25vX3RcIixcbiAgXCJpZFwiOiBcInllc19ub190XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRmFjdF90XCIsXG4gIFwiaWRcIjogXCJmYWN0X3RcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJSb3dQZXJtX3RcIixcbiAgXCJpZFwiOiBcInJvd3Blcm1fdFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkNvbFBlcm1fdFwiLFxuICBcImlkXCI6IFwiY29scGVybV90XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiVHJhbnNfdFwiLFxuICBcImlkXCI6IFwidHJhbnNfdFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkRpYWdTY2FsZV90XCIsXG4gIFwiaWRcIjogXCJkaWFnc2NhbGVfdFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkl0ZXJSZWZpbmVfdFwiLFxuICBcImlkXCI6IFwiaXRlcnJlZmluZV90XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiTWVtVHlwZV90XCIsXG4gIFwiaWRcIjogXCJtZW10eXBlX3RcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJTdGFja19lbmRfdFwiLFxuICBcImlkXCI6IFwic3RhY2tfZW5kX3RcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJMVV9zcGFjZV90XCIsXG4gIFwiaWRcIjogXCJsdV9zcGFjZV90XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiTm9ybV90XCIsXG4gIFwiaWRcIjogXCJub3JtX3RcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJNaWx1X3RcIixcbiAgXCJpZFwiOiBcIm1pbHVfdFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIk1UeXBlX3RcIixcbiAgXCJpZFwiOiBcIm10eXBlX3RcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJEVHlwZV90XCIsXG4gIFwiaWRcIjogXCJkdHlwZV90XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiU1R5cGVfdFwiLFxuICBcImlkXCI6IFwic3R5cGVfdFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIk5DRm9ybWF0XCIsXG4gIFwiaWRcIjogXCJuY2Zvcm1hdFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIk5SRm9ybWF0XCIsXG4gIFwiaWRcIjogXCJucmZvcm1hdFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIlNDZm9ybWF0XCIsXG4gIFwiaWRcIjogXCJzY2Zvcm1hdFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIlNDUGZvcm1hdFwiLFxuICBcImlkXCI6IFwic2NwZm9ybWF0XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiTkNQZm9ybWF0XCIsXG4gIFwiaWRcIjogXCJuY3Bmb3JtYXRcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJETmZvcm1hdFwiLFxuICBcImlkXCI6IFwiZG5mb3JtYXRcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCI8Y29kZT5zdXBlcmx1X29wdGlvbnNfdDwvY29kZT5cIixcbiAgXCJpZFwiOiBcInN1cGVybHVfb3B0aW9uc190XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiU3VwZXJMVVN0YXRfdFwiLFxuICBcImlkXCI6IFwic3VwZXJsdXN0YXRfdFwiLFxuICBcImxldmVsXCI6IDJcbn1dO1xuZnVuY3Rpb24gX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpIHtcbiAgY29uc3QgX2NvbXBvbmVudHMgPSB7XG4gICAgY29kZTogXCJjb2RlXCIsXG4gICAgaDE6IFwiaDFcIixcbiAgICBoMjogXCJoMlwiLFxuICAgIGhlYWRlcjogXCJoZWFkZXJcIixcbiAgICBwcmU6IFwicHJlXCIsXG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmhlYWRlciwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuaDEsIHtcbiAgICAgICAgaWQ6IFwiZm9ybWF0c1wiLFxuICAgICAgICBjaGlsZHJlbjogXCJGb3JtYXRzXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcInllc19ub190XCIsXG4gICAgICBjaGlsZHJlbjogXCJZZXNfbm9fdFwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlRZUEUgOjogeWVzX25vX1xcbiAgSU5URUdFUihDX0lOVCkgOjogTk8sIFlFU1xcbkVORCBUWVBFIHllc19ub19cXG5cXG5UWVBFKHllc19ub18pLCBQVUJMSUMsIFBBUkFNRVRFUiA6OiB5ZXNfbm9fdCA9IHllc19ub18oTk8sIFlFUylcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZmFjdF90XCIsXG4gICAgICBjaGlsZHJlbjogXCJGYWN0X3RcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJUWVBFIDo6IGZhY3RfXFxuICBJTlRFR0VSKENfSU5UKSA6OiBET0ZBQ1QsIFNhbWVQYXR0ZXJuLCBTYW1lUGF0dGVybl9TYW1lUm93UGVybSwgRkFDVE9SRURcXG5FTkQgVFlQRSBmYWN0X1xcblxcblRZUEUoZmFjdF8pLCBQVUJMSUMsIFBBUkFNRVRFUiA6OiBmYWN0X3QgPSBmYWN0XygmXFxuICAmIERPRkFDVCwgU2FtZVBhdHRlcm4sIFNhbWVQYXR0ZXJuX1NhbWVSb3dQZXJtLCBGQUNUT1JFRClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwicm93cGVybV90XCIsXG4gICAgICBjaGlsZHJlbjogXCJSb3dQZXJtX3RcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJUWVBFIDo6IHJvd3Blcm1fXFxuICBJTlRFR0VSKENfSU5UKSA6OiBOT1JPV1BFUk0sIExhcmdlRGlhZ19NQzY0LCBMYXJnZURpYWdfSFdQTSwgTVlfUEVSTVJcXG5FTkQgVFlQRSByb3dwZXJtX1xcblxcblRZUEUocm93cGVybV8pLCBQVUJMSUMsIFBBUkFNRVRFUiA6OiByb3dwZXJtX3QgPSByb3dwZXJtXyggJlxcbiAgJiBOT1JPV1BFUk0sIExhcmdlRGlhZ19NQzY0LCBMYXJnZURpYWdfSFdQTSwgTVlfUEVSTVIpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImNvbHBlcm1fdFwiLFxuICAgICAgY2hpbGRyZW46IFwiQ29sUGVybV90XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiVFlQRSA6OiBjb2xwZXJtX1xcbiAgSU5URUdFUihDX0lOVCkgOjogTkFUVVJBTCwgTU1EX0FUQSwgTU1EX0FUX1BMVVNfQSwgQ09MQU1ELCAmXFxuICAgJiBNRVRJU19BVF9QTFVTX0EsIFBBUk1FVElTLCBaT0xUQU4sIE1ZX1BFUk1DXFxuRU5EIFRZUEVcXG5cXG5UWVBFKGNvbHBlcm1fKSwgUFVCTElDLCBQQVJBTUVURVIgOjogY29scGVybV90ID0gY29scGVybV8oJlxcbiAgJiBOQVRVUkFMLCBNTURfQVRBLCBNTURfQVRfUExVU19BLCBDT0xBTUQsICZcXG4gICYgTUVUSVNfQVRfUExVU19BLCBQQVJNRVRJUywgWk9MVEFOLCBNWV9QRVJNQylcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwidHJhbnNfdFwiLFxuICAgICAgY2hpbGRyZW46IFwiVHJhbnNfdFwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlRZUEUgOjogdHJhbnNfXFxuICBJTlRFR0VSKENfSU5UKSA6OiBOT1RSQU5TLCBUUkFOUywgQ09OSlxcbkVORCBUWVBFXFxuXFxuVFlQRSh0cmFuc18pLCBQQVJBTUVURVIsIFBVQkxJQyA6OiB0cmFuc190ID0gdHJhbnNfKCZcXG4gICYgTk9UUkFOUywgVFJBTlMsIENPTkopXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImRpYWdzY2FsZV90XCIsXG4gICAgICBjaGlsZHJlbjogXCJEaWFnU2NhbGVfdFwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlRZUEUgOjogRGlhZ1NjYWxlX1xcbiAgSU5URUdFUihDX0lOVCkgOjogTk9FUVVJTCwgUk9XLCBDT0wsIEJPVEhcXG5FTkQgVFlQRVxcblxcblRZUEUoRGlhZ1NjYWxlXyksIFBVQkxJQywgUEFSQU1FVEVSIDo6IERpYWdTY2FsZV90ID0gRGlhZ1NjYWxlXygmXFxuJiBOT0VRVUlMLCBST1csIENPTCwgQk9USClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiaXRlcnJlZmluZV90XCIsXG4gICAgICBjaGlsZHJlbjogXCJJdGVyUmVmaW5lX3RcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJUWVBFIDo6IEl0ZXJSZWZpbmVfXFxuICBJTlRFR0VSKENfSU5UKSA6OiBOT1JFRklORSwgU0xVX1NJTkdMRSA9IDEsIFNMVV9ET1VCTEUsIFNMVV9FWFRSQVxcbkVORCBUWVBFXFxuXFxuVFlQRShJdGVyUmVmaW5lXyksIFBVQkxJQywgUEFSQU1FVEVSIDo6IEl0ZXJSZWZpbmVfdCA9IEl0ZXJSZWZpbmVfKCZcXG4gICYgTk9SRUZJTkUsIFNMVV9TSU5HTEUsIFNMVV9ET1VCTEUsIFNMVV9FWFRSQSlcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwibWVtdHlwZV90XCIsXG4gICAgICBjaGlsZHJlbjogXCJNZW1UeXBlX3RcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJUWVBFIDo6IE1lbVR5cGVfXFxuICBJTlRFR0VSKENfSU5UKSA6OiBVU1VCLCBMU1VCLCBVQ09MLCBMVVNVUCwgTExWTCwgVUxWTCwgTk9fTUVNVFlQRVxcbkVORCBUWVBFIE1lbVR5cGVfXFxuXFxuVFlQRShNZW1UeXBlXyksIFBVQkxJQywgUEFSQU1FVEVSIDo6IE1lbVR5cGVfdCA9IE1lbVR5cGVfKCZcXG4gICYgVVNVQiwgTFNVQiwgVUNPTCwgTFVTVVAsIExMVkwsIFVMVkwsIE5PX01FTVRZUEUpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcInN0YWNrX2VuZF90XCIsXG4gICAgICBjaGlsZHJlbjogXCJTdGFja19lbmRfdFwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlRZUEUgOjogc3RhY2tfZW5kX1xcbiAgSU5URUdFUihDX0lOVCkgOjogSEVBRCwgVEFJTFxcbkVORCBUWVBFXFxuXFxuVFlQRShzdGFja19lbmRfKSwgUFVCTElDLCBQQVJBTUVURVIgOjogc3RhY2tfZW5kX3QgPSBzdGFja19lbmRfKCZcXG4gJiBIRUFELCBUQUlMKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJsdV9zcGFjZV90XCIsXG4gICAgICBjaGlsZHJlbjogXCJMVV9zcGFjZV90XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiVFlQRSA6OiBMVV9zcGFjZV9cXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNZU1RFTSwgVVNFUlxcbkVORCBUWVBFXFxuXFxuVFlQRShMVV9zcGFjZV8pLCBQQVJBTUVURVIsIFBVQkxJQyA6OiBMVV9zcGFjZV90ID0gTFVfc3BhY2VfKCZcXG4mIFNZU1RFTSwgVVNFUilcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwibm9ybV90XCIsXG4gICAgICBjaGlsZHJlbjogXCJOb3JtX3RcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJUWVBFIDo6IG5vcm1fXFxuICBJTlRFR0VSKENfSU5UKSA6OiBPTkVfTk9STSwgVFdPX05PUk0sIElORl9OT1JNXFxuRU5EIFRZUEVcXG5cXG5UWVBFKG5vcm1fKSwgUFVCTElDLCBQQVJBTUVURVIgOjogbm9ybV90ID0gbm9ybV8oJlxcbiAmIE9ORV9OT1JNLCBUV09fTk9STSwgSU5GX05PUk0pXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcIm1pbHVfdFwiLFxuICAgICAgY2hpbGRyZW46IFwiTWlsdV90XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiVFlQRSA6OiBtaWx1X1xcbiAgSU5URUdFUihDX0lOVCkgOjogU0lMVSwgU01JTFVfMSwgU01JTFVfMiwgU01JTFVfM1xcbkVORCBUWVBFIG1pbHVfXFxuXFxuVFlQRShtaWx1XyksIFBBUkFNRVRFUiwgUFVCTElDIDo6IG1pbHVfdCA9IG1pbHVfKCZcXG4gICYgIFNJTFUsIFNNSUxVXzEsIFNNSUxVXzIsIFNNSUxVXzMpXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcIm10eXBlX3RcIixcbiAgICAgIGNoaWxkcmVuOiBcIk1UeXBlX3RcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJUWVBFIDo6IE10eXBlX1xcbiAgSU5URUdFUihDX0lOVCkgOjogU0xVX0dFXFxuICBJTlRFR0VSKENfSU5UKSA6OiBTTFVfVFJMVVxcbiAgSU5URUdFUihDX0lOVCkgOjogU0xVX1RSVVVcXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNMVV9UUkxcXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNMVV9UUlVcXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNMVV9TWUxcXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNMVV9TWVVcXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNMVV9IRUxcXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNMVV9IRVVcXG5FTkQgVFlQRSBNdHlwZV9cXG5cXG5cXG5UWVBFKE10eXBlXyksIFBVQkxJQywgUEFSQU1FVEVSIDo6IE10eXBlX3QgPSBNdHlwZV8oJlxcbiAgJiBTTFVfR0U9U0xVX0dFLCAmXFxuICAmIFNMVV9UUkxVPVNMVV9UUkxVLCAmXFxuICAmIFNMVV9UUlVVPVNMVV9UUlVVLCAmXFxuICAmIFNMVV9UUkw9U0xVX1RSTCwgJlxcbiAgJiBTTFVfVFJVPVNMVV9UUlUsICZcXG4gICYgU0xVX1NZTD1TTFVfU1lMLCAmXFxuICAmIFNMVV9TWVU9U0xVX1NZVSwgJlxcbiAgJiBTTFVfSEVMPVNMVV9IRUwsICZcXG4gICYgU0xVX0hFVT1TTFVfSEVVKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJkdHlwZV90XCIsXG4gICAgICBjaGlsZHJlbjogXCJEVHlwZV90XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiVFlQRSA6OiBEdHlwZV9cXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNMVV9TXFxuICBJTlRFR0VSKENfSU5UKSA6OiBTTFVfRFxcbiAgSU5URUdFUihDX0lOVCkgOjogU0xVX0NcXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNMVV9aXFxuRU5EIFRZUEUgRHR5cGVfXFxuXFxuXFxuVFlQRShEdHlwZV8pLCBQQVJBTUVURVIsIFBVQkxJQyA6OiBEdHlwZV90ID0gRHR5cGVfKCZcXG4gICYgU0xVX1M9U0xVX1MsICZcXG4gICYgU0xVX0Q9U0xVX0QsICZcXG4gICYgU0xVX0M9U0xVX0MsICZcXG4gICYgU0xVX1o9U0xVX1opXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcInN0eXBlX3RcIixcbiAgICAgIGNoaWxkcmVuOiBcIlNUeXBlX3RcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJUWVBFIDo6IFN0eXBlX1xcbiAgSU5URUdFUihDX0lOVCkgOjogU0xVX05DXFxuICBJTlRFR0VSKENfSU5UKSA6OiBTTFVfTkNQXFxuICBJTlRFR0VSKENfSU5UKSA6OiBTTFVfTlJcXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNMVV9TQ1xcbiAgSU5URUdFUihDX0lOVCkgOjogU0xVX1NDUFxcbiAgSU5URUdFUihDX0lOVCkgOjogU0xVX1NSXFxuICBJTlRFR0VSKENfSU5UKSA6OiBTTFVfRE5cXG4gIElOVEVHRVIoQ19JTlQpIDo6IFNMVV9OUl9MT0NcXG5FTkQgVFlQRSBTdHlwZV9cXG5cXG5cXG5UWVBFKFN0eXBlXyksIFBBUkFNRVRFUiwgUFVCTElDIDo6IFN0eXBlX3QgPSBTdHlwZV8oJlxcbiAgJiBTTFVfTkM9U0xVX05DLCAmXFxuICAmIFNMVV9OQ1A9U0xVX05DUCwgJlxcbiAgJiBTTFVfTlI9U0xVX05SLCAmXFxuICAmIFNMVV9TQz1TTFVfU0MsICZcXG4gICYgU0xVX1NDUD1TTFVfU0NQLCAmXFxuICAmIFNMVV9TUj1TTFVfU1IsICZcXG4gICYgU0xVX0ROPVNMVV9ETiwgJlxcbiAgJiBTTFVfTlJfTE9DPVNMVV9OUl9MT0MgJlxcbiAgJiApXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcIm5jZm9ybWF0XCIsXG4gICAgICBjaGlsZHJlbjogXCJOQ0Zvcm1hdFwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIiEgdHlwZWRlZiBzdHJ1Y3Qge1xcbiEgICBpbnRfdCBubno7ICAgICAvKiBudW1iZXIgb2Ygbm9uemVyb3MgaW4gdGhlIG1hdHJpeCAqL1xcbiEgICB2b2lkICpuenZhbDsgICAvKiBwb2ludGVyIHRvIGFycmF5IG9mIG5vbnplcm8gdmFsdWVzLCBwYWNrZWQgYnkgY29sdW1uICovXFxuISAgIGludF90ICpyb3dpbmQ7IC8qIHBvaW50ZXIgdG8gYXJyYXkgb2Ygcm93IGluZGljZXMgb2YgdGhlIG5vbnplcm9zICovXFxuISAgIGludF90ICpjb2xwdHI7IC8qIHBvaW50ZXIgdG8gYXJyYXkgb2YgYmVnaW5uaW5nIG9mIGNvbHVtbnMgaW4gbnp2YWxbXVxcbiEgICAgICAgICAgICAgICAgICAgICBhbmQgcm93aW5kW10gICovXFxuISAgICAgICAgICAgICAgICAgIC8qIE5vdGU6XFxuISAgICAgICAgICAgICAgICAgICAgIFplcm8tYmFzZWQgaW5kZXhpbmcgaXMgdXNlZDtcXG4hICAgICAgICAgICAgICAgICAgICAgY29scHRyW10gaGFzIG5jb2wrMSBlbnRyaWVzLCB0aGUgbGFzdCBvbmUgcG9pbnRpbmdcXG4hICAgICAgICAgICAgICAgICAgICAgYmV5b25kIHRoZSBsYXN0IGNvbHVtbiwgc28gdGhhdCBjb2xwdHJbbmNvbF0gPSBubnouICovXFxuISB9IE5DZm9ybWF0O1xcblxcblRZUEUsIEJJTkQoYykgOjogTkNmb3JtYXRcXG4gIElOVEVHRVIoQ19JTlQpIDo6IG5uelxcbiAgVFlQRShDX1BUUikgOjogbnp2YWxcXG4gIFRZUEUoQ19QVFIpIDo6IHJvd2luZFxcbiAgVFlQRShDX1BUUikgOjogY29scHRyXFxuRU5EIFRZUEUgTkNmb3JtYXRcXG5cXG5QVUJMSUMgOjogTkNmb3JtYXRcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwibnJmb3JtYXRcIixcbiAgICAgIGNoaWxkcmVuOiBcIk5SRm9ybWF0XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiISB0eXBlZGVmIHN0cnVjdCB7XFxuISAgIGludF90IG5uejsgICAgIC8qIG51bWJlciBvZiBub256ZXJvcyBpbiB0aGUgbWF0cml4ICovXFxuISAgIHZvaWQgKm56dmFsOyAgIC8qIHBvaW50ZXIgdG8gYXJyYXkgb2Ygbm9uemVybyB2YWx1ZXMsIHBhY2tlZCBieSByYXcgKi9cXG4hICAgaW50X3QgKmNvbGluZDsgLyogcG9pbnRlciB0byBhcnJheSBvZiBjb2x1bW5zIGluZGljZXMgb2YgdGhlIG5vbnplcm9zICovXFxuISAgIGludF90ICpyb3dwdHI7IC8qIHBvaW50ZXIgdG8gYXJyYXkgb2YgYmVnaW5uaW5nIG9mIHJvd3MgaW4gbnp2YWxbXVxcbiEgICAgICAgICAgICAgICAgICAgICBhbmQgY29saW5kW10gICovXFxuISAgICAgICAgICAgICAgICAgIC8qIE5vdGU6XFxuISAgICAgICAgICAgICAgICAgICAgIFplcm8tYmFzZWQgaW5kZXhpbmcgaXMgdXNlZDtcXG4hICAgICAgICAgICAgICAgICAgICAgcm93cHRyW10gaGFzIG5yb3crMSBlbnRyaWVzLCB0aGUgbGFzdCBvbmUgcG9pbnRpbmdcXG4hICAgICAgICAgICAgICAgICAgICAgYmV5b25kIHRoZSBsYXN0IHJvdywgc28gdGhhdCByb3dwdHJbbnJvd10gPSBubnouICovXFxuISB9IE5SZm9ybWF0O1xcblxcblRZUEUsIEJJTkQoYykgOjogTlJmb3JtYXRcXG4gIElOVEVHRVIoQ19JTlQpIDo6IG5uelxcbiAgVFlQRShDX1BUUikgOjogbnp2YWxcXG4gIFRZUEUoQ19QVFIpIDo6IGNvbGluZFxcbiAgVFlQRShDX1BUUikgOjogcm93cHRyXFxuRU5EIFRZUEUgTlJmb3JtYXRcXG5cXG5QVUJMSUMgOjogTlJmb3JtYXRcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwic2Nmb3JtYXRcIixcbiAgICAgIGNoaWxkcmVuOiBcIlNDZm9ybWF0XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiISB0eXBlZGVmIHN0cnVjdCB7XFxuISAgIGludF90IG5uejsgICAgLyogbnVtYmVyIG9mIG5vbnplcm9zIGluIHRoZSBtYXRyaXggKi9cXG4hICAgaW50X3QgbnN1cGVyOyAvKiBudW1iZXIgb2Ygc3VwZXJub2RlcywgbWludXMgMSAqL1xcbiEgICB2b2lkICpuenZhbDsgIC8qIHBvaW50ZXIgdG8gYXJyYXkgb2Ygbm9uemVybyB2YWx1ZXMsIHBhY2tlZCBieSBjb2x1bW4gKi9cXG4hICAgaW50X3QgKm56dmFsX2NvbHB0cjsgLyogcG9pbnRlciB0byBhcnJheSBvZiBiZWdpbm5pbmcgb2YgY29sdW1ucyBpbiBuenZhbFtdICovXFxuISAgIGludF90ICpyb3dpbmQ7ICAgICAgIC8qIHBvaW50ZXIgdG8gYXJyYXkgb2YgY29tcHJlc3NlZCByb3cgaW5kaWNlcyBvZlxcbiEgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5ndWxhciBzdXBlcm5vZGVzICovXFxuISAgIGludF90XFxuISAgICAgICAqcm93aW5kX2NvbHB0cjsgLyogcG9pbnRlciB0byBhcnJheSBvZiBiZWdpbm5pbmcgb2YgY29sdW1ucyBpbiByb3dpbmRbXSAqL1xcbiEgICBpbnRfdCAqY29sX3RvX3N1cDsgIC8qIGNvbF90b19zdXBbal0gaXMgdGhlIHN1cGVybm9kZSBudW1iZXIgdG8gd2hpY2ggY29sdW1uXFxuISAgICAgICAgICAgICAgICAgICAgICAgIGogYmVsb25nczsgbWFwcGluZyBmcm9tIGNvbHVtbiB0byBzdXBlcm5vZGUgbnVtYmVyLiAqL1xcbiEgICBpbnRfdCAqc3VwX3RvX2NvbDsgIC8qIHN1cF90b19jb2xbc10gcG9pbnRzIHRvIHRoZSBzdGFydCBvZiB0aGUgcy10aFxcbiEgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcm5vZGU7IG1hcHBpbmcgZnJvbSBzdXBlcm5vZGUgbnVtYmVyIHRvIGNvbHVtbi5cXG4hICAgICAgICAgICAgICAgICAgICAgICAgZS5nLjogY29sX3RvX3N1cDogMCAxIDIgMiAzIDMgMyA0IDQgNCA0IDQgNCAobmNvbD0xMilcXG4hICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwX3RvX2NvbDogMCAxIDIgNCA3IDEyICAgICAgICAgICAobnN1cGVyPTQpICovXFxuISAgICAgICAgICAgICAgICAgICAgICAgLyogTm90ZTpcXG4hICAgICAgICAgICAgICAgICAgICAgICAgICBaZXJvLWJhc2VkIGluZGV4aW5nIGlzIHVzZWQ7XFxuISAgICAgICAgICAgICAgICAgICAgICAgICAgbnp2YWxfY29scHRyW10sIHJvd2luZF9jb2xwdHJbXSwgY29sX3RvX3N1cCBhbmRcXG4hICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBfdG9fY29sW10gaGF2ZSBuY29sKzEgZW50cmllcywgdGhlIGxhc3Qgb25lXFxuISAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRpbmcgYmV5b25kIHRoZSBsYXN0IGNvbHVtbi5cXG4hICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgY29sX3RvX3N1cFtdLCBvbmx5IHRoZSBmaXJzdCBuY29sIGVudHJpZXMgYXJlXFxuISAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lZC4gRm9yIHN1cF90b19jb2xbXSwgb25seSB0aGUgZmlyc3QgbnN1cGVyKzJcXG4hICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzIGFyZSBkZWZpbmVkLiAqL1xcbiEgfSBTQ2Zvcm1hdDtcXG4hXFxuXFxuVFlQRSwgQklORChjKSA6OiBTQ2Zvcm1hdFxcbiAgSU5URUdFUihDX0lOVCkgOjogbm56XFxuICBJTlRFR0VSKENfSU5UKSA6OiBuc3VwZXJcXG4gIFRZUEUoQ19QVFIpIDo6IG56dmFsXFxuICBUWVBFKENfUFRSKSA6OiBuenZhbF9jb2xwdHJcXG4gIFRZUEUoQ19QVFIpIDo6IHJvd2luZFxcbiAgVFlQRShDX1BUUikgOjogcm93aW5kX2NvbHB0clxcbiAgVFlQRShDX1BUUikgOjogY29sX3RvX3N1cFxcbiAgVFlQRShDX1BUUikgOjogc3VwX3RvX2NvbFxcbkVORCBUWVBFIFNDZm9ybWF0XFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcInNjcGZvcm1hdFwiLFxuICAgICAgY2hpbGRyZW46IFwiU0NQZm9ybWF0XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiISB0eXBlZGVmIHN0cnVjdCB7XFxuISAgIGludF90IG5uejsgICAgLypudW1iZXIgb2Ygbm9uemVyb3MgaW4gdGhlIG1hdHJpeCovXFxuISAgIGludF90IG5zdXBlcjsgLypudW1iZXIgb2Ygc3VwZXJub2RlcyovXFxuISAgIHZvaWQgKm56dmFsOyAgLyogcG9pbnRlciB0byBhcnJheSBvZiBub256ZXJvIHZhbHVlcywgcGFja2VkIGJ5IGNvbHVtbiAqL1xcbiEgICBpbnRfdCpuenZhbF9jb2xiZWc7ICAvKm56dmFsX2NvbGJlZ1tqXSBwb2ludHMgdG8gYmVnaW5uaW5nIG9mIGNvbHVtbiBqXFxuISAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBuenZhbFtdKi9cXG4hICAgaW50X3QgKm56dmFsX2NvbGVuZDsgIC8qIG56dmFsX2NvbGVuZFtqXSBwb2ludHMgdG8gb25lIHBhc3QgdGhlIGxhc3QgZWxlbWVudFxcbiEgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgY29sdW1uIGogaW4gbnp2YWxbXSAqL1xcbiEgICBpbnRfdCpyb3dpbmQ7ICAgICAgICAvKnBvaW50ZXIgdG8gYXJyYXkgb2YgY29tcHJlc3NlZCByb3cgaW5kaWNlcyBvZlxcbiEgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ3VsYXIgc3VwZXJub2RlcyovXFxuISAgIGludF90ICpyb3dpbmRfY29sYmVnOyAvKiByb3dpbmRfY29sYmVnW2pdIHBvaW50cyB0byBiZWdpbm5pbmcgb2YgY29sdW1uIGpcXG4hICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHJvd2luZFtdICovXFxuISAgIGludF90KnJvd2luZF9jb2xlbmQ7IC8qcm93aW5kX2NvbGVuZFtqXSBwb2ludHMgdG8gb25lIHBhc3QgdGhlIGxhc3QgZWxlbWVudFxcbiEgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgY29sdW1uIGogaW4gcm93aW5kW10qL1xcbiEgICBpbnRfdCAqY29sX3RvX3N1cDsgICAgLyogY29sX3RvX3N1cFtqXSBpcyB0aGUgc3VwZXJub2RlIG51bWJlciB0byB3aGljaCBjb2x1bW5cXG4hICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogYmVsb25nczsgbWFwcGluZyBmcm9tIGNvbHVtbiB0byBzdXBlcm5vZGUuICovXFxuISAgIGludF90KnN1cF90b19jb2xiZWc7IC8qc3VwX3RvX2NvbGJlZ1tzXSBwb2ludHMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzLXRoXFxuISAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcm5vZGU7IG1hcHBpbmcgZnJvbSBzdXBlcm5vZGUgdG8gY29sdW1uLiovXFxuISAgIGludF90ICpzdXBfdG9fY29sZW5kOyAvKiBzdXBfdG9fY29sZW5kW3NdIHBvaW50cyB0byBvbmUgcGFzdCB0aGUgZW5kIG9mIHRoZVxcbiEgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy10aCBzdXBlcm5vZGU7IG1hcHBpbmcgZnJvbSBzdXBlcm5vZGUgbnVtYmVyIHRvXFxuISAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uXFxuISAgICAgICAgICAgICAgICAgICAgICAgICBlLmcuOiBjb2xfdG9fc3VwOiAwIDEgMiAyIDMgMyAzIDQgNCA0IDQgNCA0IChuY29sPTEyKVxcbiEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwX3RvX2NvbGJlZzogMCAxIDIgNCA3ICAgICAgICAgICAgICAobnN1cGVyPTQpXFxuISAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBfdG9fY29sZW5kOiAxIDIgNCA3IDEyICAgICAgICAgICAgICAgICAgICAqL1xcbiEgICAgICAgICAgICAgICAgICAgICAgICAgLyogTm90ZTpcXG4hICAgICAgICAgICAgICAgICAgICAgICAgICAgIFplcm8tYmFzZWQgaW5kZXhpbmcgaXMgdXNlZDtcXG4hICAgICAgICAgICAgICAgICAgICAgICAgICAgIG56dmFsX2NvbHB0cltdLCByb3dpbmRfY29scHRyW10sIGNvbF90b19zdXAgYW5kXFxuISAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBfdG9fY29sW10gaGF2ZSBuY29sKzEgZW50cmllcywgdGhlIGxhc3Qgb25lXFxuISAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGluZyBiZXlvbmQgdGhlIGxhc3QgY29sdW1uLiAgICAgICAgICovXFxuISB9IFNDUGZvcm1hdDtcXG5cXG5UWVBFLCBCSU5EKGMpIDo6IFNDUGZvcm1hdFxcbiAgSU5URUdFUihDX0lOVCkgOjogbm56LCBuc3VwZXJcXG4gIFRZUEUoQ19QVFIpIDo6IG56dmFsLCBuenZhbF9jb2xiZWcsIG56dmFsX2NvbGVuZCwgcm93aW5kLCAmXFxuICAgICYgcm93aW5kX2NvbGJlZywgcm93aW5keF9jb2xlbmQsIGNvbF90b19zdXAsIHN1cF90b19jb2xiZWcsICZcXG4gICAgJiBzdXBfdG9fY29sZW5kXFxuRU5EIFRZUEUgU0NQZm9ybWF0XFxuXFxuUFVCTElDIDo6IFNDUGZvcm1hdFxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJuY3Bmb3JtYXRcIixcbiAgICAgIGNoaWxkcmVuOiBcIk5DUGZvcm1hdFwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIiEgdHlwZWRlZiBzdHJ1Y3Qge1xcbiEgICBpbnRfdCBubno7ICAgICAvKm51bWJlciBvZiBub256ZXJvcyBpbiB0aGUgbWF0cml4Ki9cXG4hICAgdm9pZCAqbnp2YWw7ICAgLyogcG9pbnRlciB0byBhcnJheSBvZiBub256ZXJvIHZhbHVlcywgcGFja2VkIGJ5IGNvbHVtbiAqL1xcbiEgICBpbnRfdCpyb3dpbmQ7IC8qcG9pbnRlciB0byBhcnJheSBvZiByb3cgaW5kaWNlcyBvZiB0aGUgbm9uemVyb3MqL1xcbiEgICAvKk5vdGU6IG56dmFsW10vcm93aW5kW10gYWx3YXlzIGhhdmUgdGhlIHNhbWUgbGVuZ3RoKi9cXG4hICAgaW50X3QgKmNvbGJlZzsgLyogY29sYmVnW2pdIHBvaW50cyB0byB0aGUgYmVnaW5uaW5nIG9mIGNvbHVtbiBqIGluIG56dmFsW11cXG4hICAgICAgICAgICAgICAgICAgICAgYW5kIHJvd2luZFtdICAqL1xcbiEgICBpbnRfdCpjb2xlbmQ7IC8qY29sZW5kW2pdIHBvaW50cyB0byBvbmUgcGFzdCB0aGUgbGFzdCBlbGVtZW50IG9mIGNvbHVtblxcbiEgICAgICAgICAgICAgICAgICAgICBqIGluIG56dmFsW10gYW5kIHJvd2luZFtdKi9cXG4hICAgICAgICAgICAgICAgICAgLypOb3RlOlxcbiEgICAgICAgICAgICAgICAgICAgICBaZXJvLWJhc2VkIGluZGV4aW5nIGlzIHVzZWQ7XFxuISAgICAgICAgICAgICAgICAgICAgIFRoZSBjb25zZWN1dGl2ZSBjb2x1bW5zIG9mIHRoZSBub256ZXJvcyBtYXkgbm90IGJlXFxuISAgICAgICAgICAgICAgICAgICAgIGNvbnRpZ3VvdXMgaW4gc3RvcmFnZSwgYmVjYXVzZSB0aGUgbWF0cml4IGhhcyBiZWVuXFxuISAgICAgICAgICAgICAgICAgICAgIHBvc3RtdWx0aXBsaWVkIGJ5IGEgY29sdW1uIHBlcm11dGF0aW9uIG1hdHJpeC4qL1xcbiEgfSBOQ1Bmb3JtYXQ7XFxuXFxuVFlQRSwgQklORChjKSA6OiBOQ1Bmb3JtYXRcXG4gIElOVEVHRVIoQ19JTlQpIDo6IG5uelxcbiAgVFlQRShDX1BUUikgOjogbnp2YWwsIHJvd2luZHgsIGNvbGJlZywgY29sZW5kXFxuRU5EIFRZUEUgTkNQZm9ybWF0XFxuXFxuUFVCTElDIDo6IE5DUGZvcm1hdFxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJkbmZvcm1hdFwiLFxuICAgICAgY2hpbGRyZW46IFwiRE5mb3JtYXRcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCIhIHR5cGVkZWYgc3RydWN0IHtcXG4hICAgaW50X3QgbGRhOyAgIC8qbGVhZGluZyBkaW1lbnNpb24qL1xcbiEgICB2b2lkICpuenZhbDsgLyogYXJyYXkgb2Ygc2l6ZSBsZGEqbmNvbCB0byByZXByZXNlbnQgYSBkZW5zZSBtYXRyaXgqL1xcbiEgfSBETmZvcm1hdDtcXG5cXG5UWVBFLCBCSU5EKGMpIDo6IEROZm9ybWF0XFxuICBJTlRFR0VSKENfSU5UKSA6OiBsZGFcXG4gIFRZUEUoQ19QVFIpIDo6IG56dmFsXFxuRU5EIFRZUEUgRE5mb3JtYXRcXG5cXG5QVUJMSUMgOjogRE5mb3JtYXRcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwic3VwZXJsdV9vcHRpb25zX3RcIixcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwic3VwZXJsdV9vcHRpb25zX3RcIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiISB0eXBlZGVmIHN0cnVjdCB7XFxuISAgICAgZmFjdF90ICAgICAgICBGYWN0O1xcbiEgICAgIHllc19ub190ICAgICAgRXF1aWw7XFxuISAgICAgY29scGVybV90ICAgICBDb2xQZXJtO1xcbiEgICAgIHRyYW5zX3QgICAgICAgVHJhbnM7XFxuISAgICAgSXRlclJlZmluZV90ICBJdGVyUmVmaW5lO1xcbiEgICAgIGRvdWJsZSAgICAgICAgRGlhZ1Bpdm90VGhyZXNoO1xcbiEgICAgIHllc19ub190ICAgICAgU3ltbWV0cmljTW9kZTtcXG4hICAgICB5ZXNfbm9fdCAgICAgIFBpdm90R3Jvd3RoO1xcbiEgICAgIHllc19ub190ICAgICAgQ29uZGl0aW9uTnVtYmVyO1xcbiEgICAgIHJvd3Blcm1fdCAgICAgUm93UGVybTtcXG4hICAgICBpbnQgICAgICAgICAgIElMVV9Ecm9wUnVsZTtcXG4hICAgICBkb3VibGUgICAgICAgICAgSUxVX0Ryb3BUb2w7ICAgIC8qIHRocmVzaG9sZCBmb3IgZHJvcHBpbmcgKi9cXG4hICAgICBkb3VibGUgICAgICAgICAgSUxVX0ZpbGxGYWN0b3I7IC8qIGdhbW1hIGluIHRoZSBzZWNvbmRhcnkgZHJvcHBpbmcgKi9cXG4hICAgICBub3JtX3QgICAgICAgICAgSUxVX05vcm07ICAgICAgIC8qIGluZmluaXR5LW5vcm0sIDEtbm9ybSwgb3IgMi1ub3JtICovXFxuISAgICAgZG91YmxlICAgICAgICAgIElMVV9GaWxsVG9sOyAgICAvKiB0aHJlc2hvbGQgZm9yIHplcm8gcGl2b3QgcGVydHVyYmF0aW9uICovXFxuISAgICAgbWlsdV90ICAgICAgICAgIElMVV9NSUxVO1xcbiEgICAgIGRvdWJsZSAgICAgICAgICBJTFVfTUlMVV9EaW07ICAgLyogRGltZW5zaW9uIG9mIFBERSAoaWYgYXZhaWxhYmxlKSAqL1xcbiEgICAgIHllc19ub190ICAgICAgUGFyU3ltYkZhY3Q7XFxuISAgICAgeWVzX25vX3QgICAgICBSZXBsYWNlVGlueVBpdm90OyAvKiB1c2VkIGluIFN1cGVyTFVfRElTVCAqL1xcbiEgICAgIHllc19ub190ICAgICAgU29sdmVJbml0aWFsaXplZDtcXG4hICAgICB5ZXNfbm9fdCAgICAgIFJlZmluZUluaXRpYWxpemVkO1xcbiEgICAgIHllc19ub190ICAgICAgUHJpbnRTdGF0O1xcbiEgICAgIGludCAgICAgICAgICAgbm56TCwgbm56VTsgICAgICAvKiB1c2VkIHRvIHN0b3JlIG5uenMgZm9yIG5vdyAgICAgICAqL1xcbiEgICAgIGludCAgICAgICAgICAgbnVtX2xvb2thaGVhZHM7ICAvKiBudW0gb2YgbGV2ZWxzIGluIGxvb2stYWhlYWQgICAgICAqL1xcbiEgICAgIHllc19ub190ICAgICAgbG9va2FoZWFkX2V0cmVlOyAvKiB1c2UgZXRyZWUgY29tcHV0ZWQgZnJvbSB0aGVcXG4hICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsIHN5bWJvbGljIGZhY3Rvcml6YXRpb24gKi9cXG4hICAgICB5ZXNfbm9fdCAgICAgIFN5bVBhdHRlcm47ICAgICAgLyogc3ltbWV0cmljIGZhY3Rvcml6YXRpb24gICAgICAgICAgKi9cXG4hIH0gc3VwZXJsdV9vcHRpb25zX3Q7XFxuIVxcblxcblRZUEUsIEJJTkQoQykgOjogc3VwZXJsdV9vcHRpb25zX3RcXG4gIElOVEVHRVIoQ19JTlQpIDo6IEZhY3RcXG4gIElOVEVHRVIoQ19JTlQpIDo6IEVxdWlsXFxuICBJTlRFR0VSKENfSU5UKSA6OiBDb2xQZXJtXFxuICBJTlRFR0VSKENfSU5UKSA6OiBUcmFuc1xcbiAgSU5URUdFUihDX0lOVCkgOjogSXRlclJlZmluZVxcbiAgUkVBTChDX0RPVUJMRSkgOjogRGlhZ1Bpdm90VGhyZXNoXFxuICBJTlRFR0VSKENfSU5UKSA6OiBTeW1tZXRyaWNNb2RlXFxuICBJTlRFR0VSKENfSU5UKSA6OiBQaXZvdEdyb3d0aFxcbiAgSU5URUdFUihDX0lOVCkgOjogQ29uZGl0aW9uTnVtYmVyXFxuICBJTlRFR0VSKENfSU5UKSA6OiBSb3dQZXJtXFxuICBJTlRFR0VSKENfSU5UKSA6OiBJTFVfRHJvcFJ1bGVcXG4gIFJFQUwoQ19ET1VCTEUpIDo6IElMVV9Ecm9wVG9sXFxuICBSRUFMKENfRE9VQkxFKSA6OiBJTFVfRmlsbEZhY3RvclxcbiAgSU5URUdFUihDX0lOVCkgOjogSUxVX05vcm1cXG4gIFJFQUwoQ19ET1VCTEUpIDo6IElMVV9GaWxsVG9sXFxuICBJTlRFR0VSKENfSU5UKSA6OiBJTFVfTUlMVTsgXFxuICBSRUFMKENfRE9VQkxFKSA6OiBJTFVfTUlMVV9EaW1cXG4gIElOVEVHRVIoQ19JTlQpIDo6IFBhclN5bWJGYWN0XFxuICBJTlRFR0VSKENfSU5UKSA6OiBSZXBsYWNlVGlueVBpdm90XFxuICBJTlRFR0VSKENfSU5UKSA6OiBTb2x2ZUluaXRpYWxpemVkXFxuICBJTlRFR0VSKENfSU5UKSA6OiBSZWZpbmVJbml0aWFsaXplZFxcbiAgSU5URUdFUihDX0lOVCkgOjogUHJpbnRTdGF0ID0gMFxcbiAgSU5URUdFUihDX0lOVCkgOjogbm56TFxcbiAgSU5URUdFUihDX0lOVCkgOjogbm56VVxcbiAgSU5URUdFUihDX0lOVCkgOjogbnVtX2xvb2thaGVhZHNcXG4gIElOVEVHRVIoQ19JTlQpIDo6IGxvb2thaGVhZF9ldHJlZVxcbiAgSU5URUdFUihDX0lOVCkgOjogU3ltUGF0dGVyblxcbkVORCBUWVBFIHN1cGVybHVfb3B0aW9uc190XFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcInN1cGVybHVzdGF0X3RcIixcbiAgICAgIGNoaWxkcmVuOiBcIlN1cGVyTFVTdGF0X3RcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCIhIHR5cGVkZWYgc3RydWN0IHtcXG4hICAgICBpbnQgICAgICpwYW5lbF9oaXN0bzsgLyogaGlzdG9ncmFtIG9mIHBhbmVsIHNpemUgZGlzdHJpYnV0aW9uICovXFxuISAgICAgZG91YmxlICAqdXRpbWU7ICAgICAgIC8qIHJ1bm5pbmcgdGltZSBhdCB2YXJpb3VzIHBoYXNlcyAqL1xcbiEgICAgIGZsb3BzX3QgKm9wczsgICAgICAgICAvKiBvcGVyYXRpb24gY291bnQgYXQgdmFyaW91cyBwaGFzZXMgKi9cXG4hICAgICBpbnQgICAgIFRpbnlQaXZvdHM7ICAgLyogbnVtYmVyIG9mIHRpbnkgcGl2b3RzICovXFxuISAgICAgaW50ICAgICBSZWZpbmVTdGVwczsgIC8qIG51bWJlciBvZiBpdGVyYXRpdmUgcmVmaW5lbWVudCBzdGVwcyAqL1xcbiEgICAgIGludCAgICAgZXhwYW5zaW9uczsgICAvKiBudW1iZXIgb2YgbWVtb3J5IGV4cGFuc2lvbnMgKi9cXG4hIH0gU3VwZXJMVVN0YXRfdDtcXG5cXG5UWVBFLCBCSU5EKEMpIDo6IFN1cGVyTFVTdGF0X3RcXG4gICEgSU5URUdFUihDX0lOVCksIFBPSU5URVIgOjogcGFuZWxfaGlzdG8oOilcXG4gICEgUkVBTChDX0RPVUJMRSksIFBPSU5URVIgOjogdXRpbWUoOilcXG4gICEgUkVBTChDX0ZMT0FUKSwgUE9JTlRFUiA6OiBvcHMoOilcXG4gIFRZUEUoQ19QVFIpIDo6IHBhbmVsX2hpc3RvXFxuICBUWVBFKENfUFRSKSA6OiB1dGltZVxcbiAgVFlQRShDX1BUUikgOjogb3BzXFxuICBJTlRFR0VSKENfSU5UKSA6OiBUaW55UGl2b3RzXFxuICBJTlRFR0VSKENfSU5UKSA6OiBSZWZpbmVTdGVwc1xcbiAgSU5URUdFUihDX0lOVCkgOjogZXhwYW5zaW9uc1xcbkVORCBUWVBFIFN1cGVyTFVTdGF0X3RcXG5cXG5QVUJMSUMgOjogU3VwZXJMVVN0YXRfdFxcblwiXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMgPSB7fSkge1xuICBjb25zdCB7d3JhcHBlcjogTURYTGF5b3V0fSA9IHtcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBNRFhMYXlvdXQgPyBfanN4KE1EWExheW91dCwge1xuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiBfanN4KF9jcmVhdGVNZHhDb250ZW50LCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gIH0pIDogX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./docs/docs-api/SuperLU/formats.md\n");

/***/ }),

/***/ "./node_modules/@mdx-js/react/lib/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MDXProvider: () => (/* binding */ MDXProvider),\n/* harmony export */   useMDXComponents: () => (/* binding */ useMDXComponents)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/**\n * @import {MDXComponents} from 'mdx/types.js'\n * @import {Component, ReactElement, ReactNode} from 'react'\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\n\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nfunction useMDXComponents(components) {\n  const contextComponents = react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {ReactElement}\n *   Element.\n * @satisfies {Component}\n */\nfunction MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1keC1qcy9yZWFjdC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vhc2lmZW0tZG9jcy8uL25vZGVfbW9kdWxlcy9AbWR4LWpzL3JlYWN0L2xpYi9pbmRleC5qcz9hZjEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7TURYQ29tcG9uZW50c30gZnJvbSAnbWR4L3R5cGVzLmpzJ1xuICogQGltcG9ydCB7Q29tcG9uZW50LCBSZWFjdEVsZW1lbnQsIFJlYWN0Tm9kZX0gZnJvbSAncmVhY3QnXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgTWVyZ2VDb21wb25lbnRzXG4gKiAgIEN1c3RvbSBtZXJnZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7UmVhZG9ubHk8TURYQ29tcG9uZW50cz59IGN1cnJlbnRDb21wb25lbnRzXG4gKiAgIEN1cnJlbnQgY29tcG9uZW50cyBmcm9tIHRoZSBjb250ZXh0LlxuICogQHJldHVybnMge01EWENvbXBvbmVudHN9XG4gKiAgIEFkZGl0aW9uYWwgY29tcG9uZW50cy5cbiAqXG4gKiBAdHlwZWRlZiBQcm9wc1xuICogICBDb25maWd1cmF0aW9uIGZvciBgTURYUHJvdmlkZXJgLlxuICogQHByb3BlcnR5IHtSZWFjdE5vZGUgfCBudWxsIHwgdW5kZWZpbmVkfSBbY2hpbGRyZW5dXG4gKiAgIENoaWxkcmVuIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge1JlYWRvbmx5PE1EWENvbXBvbmVudHM+IHwgTWVyZ2VDb21wb25lbnRzIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2NvbXBvbmVudHNdXG4gKiAgIEFkZGl0aW9uYWwgY29tcG9uZW50cyB0byB1c2Ugb3IgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlbSAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Rpc2FibGVQYXJlbnRDb250ZXh0PWZhbHNlXVxuICogICBUdXJuIG9mZiBvdXRlciBjb21wb25lbnQgY29udGV4dCAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG4vKiogQHR5cGUge1JlYWRvbmx5PE1EWENvbXBvbmVudHM+fSAqL1xuY29uc3QgZW1wdHlDb21wb25lbnRzID0ge31cblxuY29uc3QgTURYQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZW1wdHlDb21wb25lbnRzKVxuXG4vKipcbiAqIEdldCBjdXJyZW50IGNvbXBvbmVudHMgZnJvbSB0aGUgTURYIENvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFkb25seTxNRFhDb21wb25lbnRzPiB8IE1lcmdlQ29tcG9uZW50cyB8IG51bGwgfCB1bmRlZmluZWR9IFtjb21wb25lbnRzXVxuICogICBBZGRpdGlvbmFsIGNvbXBvbmVudHMgdG8gdXNlIG9yIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZW0gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtNRFhDb21wb25lbnRzfVxuICogICBDdXJyZW50IGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNRFhDb21wb25lbnRzKGNvbXBvbmVudHMpIHtcbiAgY29uc3QgY29udGV4dENvbXBvbmVudHMgPSBSZWFjdC51c2VDb250ZXh0KE1EWENvbnRleHQpXG5cbiAgLy8gTWVtb2l6ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB0b3AtbGV2ZWwgY29udGV4dCBjaGFuZ2VzXG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEN1c3RvbSBtZXJnZSB2aWEgYSBmdW5jdGlvbiBwcm9wXG4gICAgICBpZiAodHlwZW9mIGNvbXBvbmVudHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHMoY29udGV4dENvbXBvbmVudHMpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7Li4uY29udGV4dENvbXBvbmVudHMsIC4uLmNvbXBvbmVudHN9XG4gICAgfSxcbiAgICBbY29udGV4dENvbXBvbmVudHMsIGNvbXBvbmVudHNdXG4gIClcbn1cblxuLyoqXG4gKiBQcm92aWRlciBmb3IgTURYIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFkb25seTxQcm9wcz59IHByb3BlcnRpZXNcbiAqICAgUHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtSZWFjdEVsZW1lbnR9XG4gKiAgIEVsZW1lbnQuXG4gKiBAc2F0aXNmaWVzIHtDb21wb25lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNRFhQcm92aWRlcihwcm9wZXJ0aWVzKSB7XG4gIC8qKiBAdHlwZSB7UmVhZG9ubHk8TURYQ29tcG9uZW50cz59ICovXG4gIGxldCBhbGxDb21wb25lbnRzXG5cbiAgaWYgKHByb3BlcnRpZXMuZGlzYWJsZVBhcmVudENvbnRleHQpIHtcbiAgICBhbGxDb21wb25lbnRzID1cbiAgICAgIHR5cGVvZiBwcm9wZXJ0aWVzLmNvbXBvbmVudHMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwcm9wZXJ0aWVzLmNvbXBvbmVudHMoZW1wdHlDb21wb25lbnRzKVxuICAgICAgICA6IHByb3BlcnRpZXMuY29tcG9uZW50cyB8fCBlbXB0eUNvbXBvbmVudHNcbiAgfSBlbHNlIHtcbiAgICBhbGxDb21wb25lbnRzID0gdXNlTURYQ29tcG9uZW50cyhwcm9wZXJ0aWVzLmNvbXBvbmVudHMpXG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBNRFhDb250ZXh0LlByb3ZpZGVyLFxuICAgIHt2YWx1ZTogYWxsQ29tcG9uZW50c30sXG4gICAgcHJvcGVydGllcy5jaGlsZHJlblxuICApXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@mdx-js/react/lib/index.js\n");

/***/ })

}]);