"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[95064],{96306:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"TriangleInterface/boundaryMarkers","title":"Boundary markers","description":"- Boundary markers are tags used mainly to identify which output vertices and edges are associated with which PSLG segment and which vertices and edges occur on a triangulation boundary.","source":"@site/docs/docs-api/TriangleInterface/boundaryMarkers.md","sourceDirName":"TriangleInterface","slug":"/TriangleInterface/boundaryMarkers","permalink":"/docs-api/TriangleInterface/boundaryMarkers","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/TriangleInterface/boundaryMarkers.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"area file","permalink":"/docs-api/TriangleInterface/area"},"next":{"title":"Definitions related to triangulation","permalink":"/docs-api/TriangleInterface/definition"}}');var i=r(23420),a=r(54213);const s={},o="Boundary markers",d={},l=[];function c(e){const n={h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"boundary-markers",children:"Boundary markers"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Boundary markers are tags used mainly to identify which output vertices and edges are associated with which PSLG segment and which vertices and edges occur on a triangulation boundary."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"An everyday use is determining where boundary conditions should be applied to a finite element mesh. Using the B switch, you can prevent boundary markers from being written into files produced by Triangle."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The boundary marker associated with each segment in an output .poly file and each edge in an output .edge file is chosen as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If an output edge is part or all of a PSLG segment with a nonzero boundary marker, then the edge is assigned the same marker as the segment."}),"\n",(0,i.jsx)(n.li,{children:"Otherwise, if the edge occurs on a boundary of the triangulation (including boundaries of holes), the edge is assigned the marker one (1)."}),"\n",(0,i.jsx)(n.li,{children:"Otherwise, the edge is assigned the marker zero (0)."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The boundary marker associated with each vertex in an output .node file is chosen as follows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If a vertex is assigned a nonzero boundary marker in the input file, then it is assigned the same marker in the output .node file. Otherwise, the vertex is assigned the same marker if the vertex lies on a PSLG segment (including the segment's endpoints) with a nonzero boundary marker. If the vertex lies on several such segments, one of the markers is chosen arbitrarily. Otherwise, if the vertex occurs on a triangulation boundary, then the vertex is assigned marker one (1). Otherwise, the vertex is assigned the marker zero (0)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If you want Triangle to determine which vertices and edges are on the boundary, assign them the boundary marker zero (or use no markers at all) in your input files."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"All boundary vertices, edges, and segments in the output files will be assigned the value one."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},54213:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var t=r(36672);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);