"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[37451],{94140:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"LisLinSolver/LISLinSolver_","title":"LISLinSolver_","description":"Lis (Library of Iterative Solvers for linear systems) is a parallel software library for solving discretized linear equations","source":"@site/docs/docs-api/LisLinSolver/LISLinSolver_.md","sourceDirName":"LisLinSolver","slug":"/LisLinSolver/LISLinSolver_","permalink":"/docs-api/LisLinSolver/LISLinSolver_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/LisLinSolver/LISLinSolver_.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"LisLinSolver","permalink":"/docs-api/LisLinSolver/"},"next":{"title":"Lobatto","permalink":"/docs-api/LobattoPolynomialUtility/"}}');var l=i(23420),r=i(54213);const a={},o=void 0,t={},c=[{value:"Linear solvers",id:"linear-solvers",level:2},{value:"Eigensolvers",id:"eigensolvers",level:2},{value:"Preconditioners",id:"preconditioners",level:2},{value:"Matrix Storage Formats",id:"matrix-storage-formats",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Configuration for Multi thread",id:"configuration-for-multi-thread",level:3},{value:"Configuration for MPI",id:"configuration-for-mpi",level:3},{value:"Compile",id:"compile",level:2},{value:"Install",id:"install",level:2},{value:"Cleaning",id:"cleaning",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Matrix storage formats",id:"matrix-storage-formats-1",level:3},{value:"Double-double (quadruple) precision operations",id:"double-double-quadruple-precision-operations",level:3},{value:"Preconditioners",id:"preconditioners-1",level:3},{value:"Eigensolvers",id:"eigensolvers-1",level:3},{value:"Basic steps",id:"basic-steps",level:2},{value:"Vector",id:"vector",level:2},{value:"Matrix",id:"matrix",level:2},{value:"Setting CSR matrix",id:"setting-csr-matrix",level:2},{value:"Solving equations",id:"solving-equations",level:2},{value:"Precondition Solver Decoupled Manner",id:"precondition-solver-decoupled-manner",level:2},{value:"Solving eigenvalue problem",id:"solving-eigenvalue-problem",level:2}];function d(e){const n={annotation:"annotation",code:"code",h2:"h2",h3:"h3",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:"Lis (Library of Iterative Solvers for linear systems) is a parallel software library for solving discretized linear equations"}),"\n",(0,l.jsx)(n.span,{className:"katex-display",children:(0,l.jsxs)(n.span,{className:"katex",children:[(0,l.jsx)(n.span,{className:"katex-mathml",children:(0,l.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,l.jsxs)(n.semantics,{children:[(0,l.jsxs)(n.mrow,{children:[(0,l.jsx)(n.mi,{children:"A"}),(0,l.jsx)(n.mi,{children:"x"}),(0,l.jsx)(n.mo,{children:"="}),(0,l.jsx)(n.mi,{children:"b"})]}),(0,l.jsx)(n.annotation,{encoding:"application/x-tex",children:"Ax = b"})]})})}),(0,l.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,l.jsxs)(n.span,{className:"base",children:[(0,l.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,l.jsx)(n.span,{className:"mord mathnormal",children:"A"}),(0,l.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,l.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.jsx)(n.span,{className:"mrel",children:"="}),(0,l.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,l.jsxs)(n.span,{className:"base",children:[(0,l.jsx)(n.span,{className:"strut",style:{height:"0.6944em"}}),(0,l.jsx)(n.span,{className:"mord mathnormal",children:"b"})]})]})]})}),"\n",(0,l.jsx)(n.p,{children:"and eigenvalue problems:"}),"\n",(0,l.jsx)(n.span,{className:"katex-display",children:(0,l.jsxs)(n.span,{className:"katex",children:[(0,l.jsx)(n.span,{className:"katex-mathml",children:(0,l.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,l.jsxs)(n.semantics,{children:[(0,l.jsxs)(n.mrow,{children:[(0,l.jsx)(n.mi,{children:"A"}),(0,l.jsx)(n.mi,{children:"x"}),(0,l.jsx)(n.mo,{children:"="}),(0,l.jsx)(n.mi,{children:"\u03bb"}),(0,l.jsx)(n.mi,{children:"B"}),(0,l.jsx)(n.mi,{children:"x"})]}),(0,l.jsx)(n.annotation,{encoding:"application/x-tex",children:"Ax = \\lambda B x"})]})})}),(0,l.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,l.jsxs)(n.span,{className:"base",children:[(0,l.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,l.jsx)(n.span,{className:"mord mathnormal",children:"A"}),(0,l.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,l.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.jsx)(n.span,{className:"mrel",children:"="}),(0,l.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,l.jsxs)(n.span,{className:"base",children:[(0,l.jsx)(n.span,{className:"strut",style:{height:"0.6944em"}}),(0,l.jsx)(n.span,{className:"mord mathnormal",children:"\u03bb"}),(0,l.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05017em"},children:"B"}),(0,l.jsx)(n.span,{className:"mord mathnormal",children:"x"})]})]})]})}),"\n",(0,l.jsx)(n.h2,{id:"linear-solvers",children:"Linear solvers"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"CG"}),"\n",(0,l.jsx)(n.li,{children:"BiCG"}),"\n",(0,l.jsx)(n.li,{children:"CGS"}),"\n",(0,l.jsx)(n.li,{children:"BiCGSTAB"}),"\n",(0,l.jsx)(n.li,{children:"GPBiCG"}),"\n",(0,l.jsx)(n.li,{children:"BiCGSTAB"}),"\n",(0,l.jsx)(n.li,{children:"Jacobi"}),"\n",(0,l.jsx)(n.li,{children:"Gauss-Seidel"}),"\n",(0,l.jsx)(n.li,{children:"SOR"}),"\n",(0,l.jsx)(n.li,{children:"IDR"}),"\n",(0,l.jsx)(n.li,{children:"COCG"}),"\n",(0,l.jsx)(n.li,{children:"CR"}),"\n",(0,l.jsx)(n.li,{children:"BiCR"}),"\n",(0,l.jsx)(n.li,{children:"CRS"}),"\n",(0,l.jsx)(n.li,{children:"BiCRSTAB"}),"\n",(0,l.jsx)(n.li,{children:"GPBiCR"}),"\n",(0,l.jsx)(n.li,{children:"BiCRSafe"}),"\n",(0,l.jsx)(n.li,{children:"TFQMR"}),"\n",(0,l.jsx)(n.li,{children:"Orthomin"}),"\n",(0,l.jsx)(n.li,{children:"GMRES"}),"\n",(0,l.jsx)(n.li,{children:"MINRES"}),"\n",(0,l.jsx)(n.li,{children:"COCR"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"eigensolvers",children:"Eigensolvers"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Power"}),"\n",(0,l.jsx)(n.li,{children:"Inverse"}),"\n",(0,l.jsx)(n.li,{children:"Rayleigh Quotient"}),"\n",(0,l.jsx)(n.li,{children:"CG"}),"\n",(0,l.jsx)(n.li,{children:"CR"}),"\n",(0,l.jsx)(n.li,{children:"Subspace"}),"\n",(0,l.jsx)(n.li,{children:"Lanczos"}),"\n",(0,l.jsx)(n.li,{children:"Arnoldi"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"preconditioners",children:"Preconditioners"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Jacobi"}),"\n",(0,l.jsx)(n.li,{children:"SSOR"}),"\n",(0,l.jsx)(n.li,{children:"ILU(k)"}),"\n",(0,l.jsx)(n.li,{children:"ILUT"}),"\n",(0,l.jsx)(n.li,{children:"Crout ILU"}),"\n",(0,l.jsx)(n.li,{children:"I+S"}),"\n",(0,l.jsx)(n.li,{children:"SA-AMG"}),"\n",(0,l.jsx)(n.li,{children:"Hybrid"}),"\n",(0,l.jsx)(n.li,{children:"SAINV"}),"\n",(0,l.jsx)(n.li,{children:"Additive Schwarz"}),"\n",(0,l.jsx)(n.li,{children:"User defined"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"matrix-storage-formats",children:"Matrix Storage Formats"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"CSR"}),"\n",(0,l.jsx)(n.li,{children:"CSC"}),"\n",(0,l.jsx)(n.li,{children:"MSR"}),"\n",(0,l.jsx)(n.li,{children:"DIA"}),"\n",(0,l.jsx)(n.li,{children:"ELL"}),"\n",(0,l.jsx)(n.li,{children:"JAD"}),"\n",(0,l.jsx)(n.li,{children:"BSR"}),"\n",(0,l.jsx)(n.li,{children:"BSC"}),"\n",(0,l.jsx)(n.li,{children:"VBR"}),"\n",(0,l.jsx)(n.li,{children:"COO"}),"\n",(0,l.jsx)(n.li,{children:"DNS"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-txt",children:"lis-($VERSION)\n+ config\n| configuration files\n+ doc\n| documents\n+ graphics\n| sample files for graphics\n+ include\n| header files\n+ src\n| source files\n+ test\n| test programs\n+ win\nconfiguration files for Windows systems\n"})}),"\n",(0,l.jsx)(n.h3,{id:"configuration-for-multi-thread",children:"Configuration for Multi thread"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--prefix=<path to install>"})," location of installing the lib"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-omp"})," enable openmp support"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-f90"})," enable fortran90 interface"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-shared"})," enable shared library"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"TARGET=<TARGET>"})," optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"CC=<c_compiler>"})," specify c compiler"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"CFLAGS=<additional c flags>"})," specify additional cflags"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"FC=<fortran compiler>"})," specify fortran compiler"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"FCFLAGS=<f90 flags>"})," specify additional fortran compiler flags"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"LDFLAGS=<ld flags for linker>"}),"  optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-saamg"})," optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-quad"})," optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-longdouble"})," optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-longlong"})," optional, to support ",(0,l.jsx)(n.code,{children:"Int64"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-complex"})," optional, it is necessary when we want to compute the eigenvalues of unsymmetric system"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-gprof"})," optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--disable-test"})," optional"]}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"--enable-debug"})}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"In easifem we have used the following configuration"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"./configure \\\n--prefix=$EASIFEM_EXTPKGS \\\n--enable-omp \\\n--enable-f90 \\\n--enable-shared \\\n--enable-saamg \\\nFC=gfortran-12 \\\nCC=gcc-12\n"})}),"\n",(0,l.jsx)(n.p,{children:"Which prints following output"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:" Build with OpenMP library                  = yes\n  Build with MPI library                     = no\n  Enable FORTRAN 77 compatible interface     = yes\n  Enable Fortran 90 compatible interface     = yes\n  Enable SA-AMG preconditioner               = yes\n  Enable double-double precision support     = no\n  Enable long double precision support       = no\n  Enable 64bit integer support               = no\n  Enable complex scalar support              = yes\n  Enable dynamic linking                     = yes\n  Enable profiling                           = no\n\n  C compiler        = gcc-12\n  C flags           = -O3 -fomit-frame-pointer  -fopenmp -D_COMPLEX -DHAVE_CONFIG_H\n  C libraries       = -lm\n  F77 compiler      = gfortran-12\n  F77 flags         = -O3 -fomit-frame-pointer  -fopenmp -DCOMPLEX\n  F77 libraries     =  -L/usr/lib/gcc/x86_64-linux-gnu/12 -L/usr/lib/gcc/x86_64-linux-gnu/12/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/12/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/12/../../.. -lgfortran -lm -lquadmath\n  F90 compiler      = gfortran-12\n  F90 flags         = -O3 -fomit-frame-pointer  -Wp,-DZERO_ORIGIN=1 -fopenmp -DCOMPLEX\n  F90 libraries     =\n"})}),"\n",(0,l.jsx)(n.h3,{id:"configuration-for-mpi",children:"Configuration for MPI"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"--prefix=<path to install>"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"--enable-mpi"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"--enable-f90"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"--enable-shared"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"TARGET=<TARGET>"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"CC=<c_compiler>"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"CFLAGS=<additional c flags>"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"FC=<fortran compiler>"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"FCFLAGS=<f90 flags>"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"F77=<f77 compiler>"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"F77FLAGS=<f77 compiler flags>"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"LDFLAGS=<ld flags for linker>"})}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-saamg"})," optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-quad"})," optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-longdouble"})," optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-longlong"})," optional, to support ",(0,l.jsx)(n.code,{children:"Int64"})]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-complex"})," optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--enable-gprof"})," optional"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"--disable-test"})," optional"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["NOTE: Options ",(0,l.jsx)(n.code,{children:"--enable-omp"})," and ",(0,l.jsx)(n.code,{children:"--enable-mpi"})," can be combined."]}),"\n",(0,l.jsx)(n.h2,{id:"compile",children:"Compile"}),"\n",(0,l.jsx)(n.p,{children:"After configuration compile the code by using make command ."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"make\nmake check\n"})}),"\n",(0,l.jsx)(n.h2,{id:"install",children:"Install"}),"\n",(0,l.jsx)(n.p,{children:"After compilation we install the library by using make install command."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"make install\n"})}),"\n",(0,l.jsx)(n.p,{children:"which copies the files to the destination directory as follows:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-txt",children:"($INSTALLDIR)\n+bin\n|\n +lsolve esolve esolver gesolve gesolver hpcg_kernel hpcg_spmvtest spmvtest*\n+include\n|\n +lis_config.h lis.h lisf.h\n+lib\n|\n +liblis.a\n+share\n+doc/lis examples/lis man\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lis_config.h"})," is the header file required to build the library"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lis.h"})," and ",(0,l.jsx)(n.code,{children:"lisf.h"})," are the header files required by the C and Fortran compilers, respectively."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"liblis.a"})," is the library."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"To ensure that the library has been installed successfully, enter"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"make installcheck\n"})}),"\n",(0,l.jsx)(n.h2,{id:"cleaning",children:"Cleaning"}),"\n",(0,l.jsx)(n.p,{children:"To remove the copied files in installed directory, enter"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"> make uninstall\n"})}),"\n",(0,l.jsx)(n.p,{children:"To remove the generated library and executable files in source directory, enter"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"> make clean\n"})}),"\n",(0,l.jsx)(n.p,{children:"To remove the configuration files in addition to the other generated files, enter"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"> make distclean\n"})}),"\n",(0,l.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,l.jsx)(n.p,{children:"The current version has the following limitations:"}),"\n",(0,l.jsx)(n.h3,{id:"matrix-storage-formats-1",children:"Matrix storage formats"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The VBR format does not support the multiprocessing environment."}),"\n",(0,l.jsx)(n.li,{children:"The SA-AMG preconditioner supports only the CSR format."}),"\n",(0,l.jsx)(n.li,{children:"In the multiprocessing environment, the CSR is the only accepted format for user defined\narrays."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"double-double-quadruple-precision-operations",children:"Double-double (quadruple) precision operations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The Jacobi, Gauss-Seidel, SOR, IDR(s), COCG, and COCR methods do not support the double-double precision operations."}),"\n",(0,l.jsx)(n.li,{children:"The eigensolvers do not support the double-double precision operations."}),"\n",(0,l.jsx)(n.li,{children:"The Jacobi, Gauss-Seidel and SOR methods in the hybrid preconditioner do not support the double-double precision operations."}),"\n",(0,l.jsx)(n.li,{children:"The I+S and SA-AMG preconditioners do not support the double-double precision operations."}),"\n",(0,l.jsx)(n.li,{children:"The double-double precision operations does not support complex arithmetic."}),"\n",(0,l.jsx)(n.li,{children:"The double-double precision operations cannot be combined with the long-double precision operations."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"preconditioners-1",children:"Preconditioners"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The algorithm of the ILU(k) preconditioner is based on the localized ILU preconditioning[38], which factorizes the block diagonal elements in parallel. Note that the convergence behavior approaches to that of the Jacobi preconditioner as the number of threads or processes increases."}),"\n",(0,l.jsx)(n.li,{children:"If a preconditioner other than the Jacobi or SSOR is selected and matrix A is not in the CSR\nformat, a new matrix is created in the CSR format for preconditioning."}),"\n",(0,l.jsx)(n.li,{children:"The SA-AMG preconditioner does not support the BiCG method for unsymmetric matrices."}),"\n",(0,l.jsx)(n.li,{children:"The SA-AMG preconditioner does not support multithreading."}),"\n",(0,l.jsx)(n.li,{children:"The SA-AMG preconditioner does not support complex arithmetic."}),"\n",(0,l.jsx)(n.li,{children:"The assembly of the matrices in the SAINV preconditioner is not parallelized."}),"\n",(0,l.jsx)(n.li,{children:"The user defined preconditioner cannot be used."}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"eigensolvers-1",children:"Eigensolvers"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"To compute complex eigenvalues, complex arithmetic must be enabled."}),"\n",(0,l.jsx)(n.li,{children:"Therefore, when computing eigenvalues of unsymmetric matrices, complex arithmetic must always be enabled."}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"basic-steps",children:"Basic steps"}),"\n",(0,l.jsx)(n.p,{children:"We need following steps:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Initialization"}),"\n",(0,l.jsx)(n.li,{children:"Matrix creation"}),"\n",(0,l.jsx)(n.li,{children:"Vector creation"}),"\n",(0,l.jsx)(n.li,{children:"Solver creation"}),"\n",(0,l.jsx)(n.li,{children:"Value assignment for matrices and vectors"}),"\n",(0,l.jsx)(n.li,{children:"Solver assignment"}),"\n",(0,l.jsx)(n.li,{children:"Solver execution"}),"\n",(0,l.jsx)(n.li,{children:"Finalization"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"We also need to include"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'#include "lisf.h"\n'})}),"\n",(0,l.jsx)(n.p,{children:"which is located in include directory of install path."}),"\n",(0,l.jsx)(n.h2,{id:"vector",children:"Vector"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-fortran",children:'PROGRAM main\n! USE easifemBase\n#include "lisf.h"\n\nINTEGER :: ierr\nLIS_INTEGER :: i, n\nLIS_VECTOR :: v\n\nn = 4\nCALL lis_initialize(ierr)\n\nCALL lis_vector_create(0, v, ierr)\nCALL lis_vector_set_size(v, 0, n, ierr)\n\nDO i = 1, n\n  CALL lis_vector_set_value(LIS_INS_VALUE, i, DBLE(i), v, ierr)\nEND DO\n\nCALL lis_vector_destroy(v, ierr)\n\nCALL lis_finalize(ierr)\nEND PROGRAM main\n'})}),"\n",(0,l.jsx)(n.h2,{id:"matrix",children:"Matrix"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-fortran",children:'PROGRAM main\nUSE easifemBase\n#include "lisf.h"\n\nINTEGER :: ierr\nLIS_INTEGER :: i, n\nLIS_MATRIX :: A\n\nn = 4\nCALL lis_initialize(ierr)\n\nCALL lis_matrix_create(0, A, ierr)\nCALL lis_matrix_set_size(A, 0, n, ierr)\n\nDO i = 1, n\n  IF (i .GT. 1) THEN\n    CALL lis_matrix_set_value(LIS_INS_VALUE, i, i - 1, 1.0_DFP, A, ierr)\n  END IF\n\n  IF (i .LT. n) THEN\n    CALL lis_matrix_set_value(LIS_INS_VALUE, i, i + 1, 1.0_DFP, A, ierr)\n  END IF\n\n  CALL lis_matrix_set_value(LIS_INS_VALUE, i, i, 2.0_DFP, A, ierr)\nEND DO\n\nCALL lis_matrix_set_type(A, LIS_MATRIX_CSR, ierr)\nCALL lis_matrix_assemble(A, ierr)\n\nCALL lis_matrix_destroy(A, ierr)\n\nCALL lis_finalize(ierr)\nEND PROGRAM main\n'})}),"\n",(0,l.jsx)(n.h2,{id:"setting-csr-matrix",children:"Setting CSR matrix"}),"\n",(0,l.jsxs)(n.p,{children:["Note that index of ",(0,l.jsx)(n.code,{children:"IA"})," and ",(0,l.jsx)(n.code,{children:"JA"})," should start from 0."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-fortran",children:'PROGRAM main\nUSE easifemBase\n#include "lisf.h"\n\nCHARACTER(*), PARAMETER :: matrix_name = "../../CSRMatrix/matrixMarket/e40r0000.mtx"\nCHARACTER(*), PARAMETER :: rhs_name = "../../CSRMatrix/matrixMarket/e40r0000_rhs1.mtx"\nINTEGER :: ierr\nLIS_MATRIX :: A\nTYPE(CSRMatrix_) :: csrmat\nREAL(DFP), ALLOCATABLE :: rhs(:)\nREAL(DFP), ALLOCATABLE :: sol(:)\nINTEGER(I4B), ALLOCATABLE :: ia(:)\nINTEGER(I4B), ALLOCATABLE :: ja(:)\nINTEGER(I4B) :: n\nINTEGER(I4B) :: m\nINTEGER(I4B) :: nnz\nINTEGER(I4B) :: ii\nINTEGER(I4B) :: unitno\nCHARACTER(1024) :: astr\n\nOPEN (NEWUNIT=unitno, file=rhs_name, action="READ", status="OLD")\nREAD (unitno, *) astr\nREAD (unitno, *) n, m\nCALL Reallocate(rhs, n)\nDO ii = 1, n\n  READ (unitno, *) rhs(ii)\nEND DO\nCLOSE (unitno)\n\nCALL IMPORT(csrmat, matrix_name, SPARSE_FMT_COO)\n\nn = SIZE(csrmat, 1)\nm = SIZE(csrmat, 2)\nnnz = GetNNZ(csrmat)\nCALL Display(n, "nrow = ")\nCALL Display(m, "ncol = ")\nCALL Display(nnz, "nnz = ")\n\nCALL Reallocate(sol, n)\n\n! lis\n\nCALL lis_initialize(ierr)\n\nia = csrmat%csr%ia - 1\nja = csrmat%csr%ja - 1\n\nCALL lis_matrix_create(0, A, ierr)\nCALL lis_matrix_set_size(A, 0, n, ierr)\nCALL lis_matrix_set_csr(nnz, ia, ja, csrmat%a, A, ierr)\nCALL lis_matrix_assemble(A, ierr)\n\nCALL lis_matrix_destroy(A, ierr)\nCALL lis_finalize(ierr)\nEND PROGRAM main\n'})}),"\n",(0,l.jsx)(n.h2,{id:"solving-equations",children:"Solving equations"}),"\n",(0,l.jsx)(n.p,{children:"Following steps should be followed to solve a system of linear equations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Create a solver"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-fortran",children:"CALL lis_solver_create(solver, ierr)\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Set options of the solver"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-fortran",children:'str = "-i bicg -p none -tol 1.0e-12 -maxiter 1000"\nCALL lis_solver_set_option(str, solver, ierr)\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["After setting the option, we can solve ",(0,l.jsxs)(n.span,{className:"katex",children:[(0,l.jsx)(n.span,{className:"katex-mathml",children:(0,l.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,l.jsxs)(n.semantics,{children:[(0,l.jsxs)(n.mrow,{children:[(0,l.jsx)(n.mi,{children:"A"}),(0,l.jsx)(n.mi,{children:"x"}),(0,l.jsx)(n.mo,{children:"="}),(0,l.jsx)(n.mi,{children:"b"})]}),(0,l.jsx)(n.annotation,{encoding:"application/x-tex",children:"Ax=b"})]})})}),(0,l.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,l.jsxs)(n.span,{className:"base",children:[(0,l.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,l.jsx)(n.span,{className:"mord mathnormal",children:"A"}),(0,l.jsx)(n.span,{className:"mord mathnormal",children:"x"}),(0,l.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,l.jsx)(n.span,{className:"mrel",children:"="}),(0,l.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,l.jsxs)(n.span,{className:"base",children:[(0,l.jsx)(n.span,{className:"strut",style:{height:"0.6944em"}}),(0,l.jsx)(n.span,{className:"mord mathnormal",children:"b"})]})]})]})," by using"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-fortran",children:"CALL lis_solve(A, b, x, solver, ierr)\n"})}),"\n",(0,l.jsx)(n.p,{children:"Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-fortran",children:'PROGRAM main\nUSE easifemBase\n#include "lisf.h"\n\nCHARACTER(*), PARAMETER :: matrix_name = "../../CSRMatrix/matrixMarket/small5.mtx"\nCHARACTER(*), PARAMETER :: rhs_name = "../../CSRMatrix/matrixMarket/small5_rhs.mtx"\n\n! CHARACTER(*), PARAMETER :: matrix_name = "../../CSRMatrix/matrixMarket/e40r0000.mtx"\n! CHARACTER(*), PARAMETER :: rhs_name = "../../CSRMatrix/matrixMarket/e40r0000_rhs1.mtx"\nINTEGER :: ierr\nLIS_MATRIX :: A_\nLIS_VECTOR :: rhs_, sol_\nLIS_SOLVER :: solver\nTYPE(CSRMatrix_) :: csrmat\nREAL(DFP), ALLOCATABLE :: rhs(:)\nREAL(DFP), ALLOCATABLE :: sol(:)\nINTEGER(I4B), ALLOCATABLE :: ia(:)\nINTEGER(I4B), ALLOCATABLE :: ja(:)\nREAL(DFP), ALLOCATABLE :: a(:)\nINTEGER(I4B) :: n\nINTEGER(I4B) :: m\nINTEGER(I4B) :: nnz\nINTEGER(I4B) :: ii\nINTEGER(I4B) :: unitno\nCHARACTER(1024) :: astr\n\nOPEN (NEWUNIT=unitno, file=rhs_name, action="READ", status="OLD")\nREAD (unitno, *) astr\nREAD (unitno, *) n, m\nCALL Display(n, "n = ")\nCALL Reallocate(rhs, n)\nDO ii = 1, n\n  READ (unitno, *) rhs(ii)\nEND DO\nCLOSE (unitno)\n\nCALL IMPORT(csrmat, matrix_name, SPARSE_FMT_COO)\n\nn = SIZE(csrmat, 1)\nm = SIZE(csrmat, 2)\nnnz = GetNNZ(csrmat)\nCALL Display(n, "nrow = ")\nCALL Display(m, "ncol = ")\nCALL Display(nnz, "nnz = ")\n\nCALL Reallocate(sol, n)\n\n! lis\n\nCALL lis_initialize(ierr)\n\nia = csrmat%csr%ia - 1\nja = csrmat%csr%ja - 1\n\nCALL lis_matrix_create(0, A_, ierr)\nCALL lis_matrix_set_size(A_, 0, n, ierr)\nCALL lis_matrix_set_csr(nnz, ia, ja, csrmat%a, A_, ierr)\nCALL lis_matrix_assemble(A_, ierr)\nCALL lis_matrix_set()\nCALL chkerr(ierr)\nCALL display("flag 1")\n\nCALL lis_vector_create(0, sol_, ierr)\nCALL lis_vector_set_size(sol_, 0, n, ierr)\nCALL lis_vector_scatter(sol, sol_, ierr)\n\nCALL lis_vector_create(0, rhs_, ierr)\nCALL lis_vector_set_size(rhs_, 0, n, ierr)\nCALL lis_vector_scatter(rhs, rhs_, ierr)\nCALL chkerr(ierr)\n\nCALL display("flag 2")\n\nCALL lis_solver_create(solver, ierr)\nastr = "-i gmres -p none"\nCALL lis_solver_set_option(TRIM(astr), solver, ierr)\nastr = "-tol 1.0e-15 -maxiter "//tostring(n)\nCALL lis_solver_set_option(TRIM(astr), solver, ierr)\nCALL chkerr(ierr)\n\nCALL display("flag 3")\n\nCALL lis_solve(A_, rhs_, sol_, solver, ierr)\nCALL chkerr(ierr)\n\nCALL display("flag 4")\n\nCALL lis_vector_gather(sol_, sol, ierr)\nCALL Display(sol(1:5), "solution = ")\nCALL chkerr(ierr)\n\nCALL display("flag 5")\n\nCALL lis_solver_destroy(solver, ierr)\nCALL lis_matrix_destroy(A_, ierr)\nCALL lis_vector_destroy(rhs_, ierr)\nCALL lis_vector_destroy(sol_, ierr)\nCALL lis_finalize(ierr)\nEND PROGRAM main\n'})}),"\n",(0,l.jsx)(n.h2,{id:"precondition-solver-decoupled-manner",children:"Precondition Solver Decoupled Manner"}),"\n",(0,l.jsx)(n.p,{children:"We have mentioned how to solve linear equation above. However, in this method, every time we solve the system, preconditioner is updated. This is helpful when we are solving the nonlinear problem, as the global tangent matrix changes."}),"\n",(0,l.jsx)(n.h2,{id:"solving-eigenvalue-problem",children:"Solving eigenvalue problem"})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},54213:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(36672);const l={},r=s.createContext(l);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);