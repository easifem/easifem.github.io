"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[25017],{81815:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"TriangleInterface/triangulateio","title":"triangulateio","description":"triangulateio is used to pass data into and out of the triangulate() procedure.","source":"@site/docs/docs-api/TriangleInterface/triangulateio.md","sourceDirName":"TriangleInterface","slug":"/TriangleInterface/triangulateio","permalink":"/docs-api/TriangleInterface/triangulateio","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/TriangleInterface/triangulateio.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"triangulate","permalink":"/docs-api/TriangleInterface/triangulate"},"next":{"title":"TriangleInterpolationUtility","permalink":"/docs-api/TriangleInterpolationUtility/"}}');var r=t(23420),o=t(54213);const l={},s="triangulateio",d={},a=[{value:"<code>pointlist</code> (In and out)",id:"pointlist-in-and-out",level:2},{value:"<code>pointattributelist</code> (In and out)",id:"pointattributelist-in-and-out",level:2},{value:"<code>pointmarkerlist</code> (In and out)",id:"pointmarkerlist-in-and-out",level:2},{value:"<code>trianglelist</code> (In and out)",id:"trianglelist-in-and-out",level:2},{value:"<code>triangleattributelist</code> (In and out)",id:"triangleattributelist-in-and-out",level:2},{value:"<code>trianglereallist</code> (input only)",id:"trianglereallist-input-only",level:2},{value:"<code>neighborlist</code>(output only)",id:"neighborlistoutput-only",level:2},{value:"<code>segmentlist</code> (In and out)",id:"segmentlist-in-and-out",level:2},{value:"<code>segmentmarkerlist</code> (In and out)",id:"segmentmarkerlist-in-and-out",level:2},{value:"<code>holelist</code> (input only)",id:"holelist-input-only",level:2},{value:"<code>regionalist</code> (input only)",id:"regionalist-input-only",level:2},{value:"<code>edgelist</code> (output only)",id:"edgelist-output-only",level:2},{value:"<code>edgemarkerlist</code> (output only)",id:"edgemarkerlist-output-only",level:2},{value:"<code>normlist</code> (output only)",id:"normlist-output-only",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"triangulateio",children:"triangulateio"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct triangulateio {\n  REAL *pointlist;                                               /* In / out */\n  REAL *pointattributelist;                                      /* In / out */\n  int *pointmarkerlist;                                          /* In / out */\n  int numberofpoints;                                            /* In / out */\n  int numberofpointattributes;                                   /* In / out */\n\n  int *trianglelist;                                             /* In / out */\n  REAL *triangleattributelist;                                   /* In / out */\n  REAL *trianglearealist;                                         /* In only */\n  int *neighborlist;                                             /* Out only */\n  int numberoftriangles;                                         /* In / out */\n  int numberofcorners;                                           /* In / out */\n  int numberoftriangleattributes;                                /* In / out */\n\n  int *segmentlist;                                              /* In / out */\n  int *segmentmarkerlist;                                        /* In / out */\n  int numberofsegments;                                          /* In / out */\n\n  REAL *holelist;                        /* In / pointer to array copied out */\n  int numberofholes;                                      /* In / copied out */\n\n  REAL *regionlist;                      /* In / pointer to array copied out */\n  int numberofregions;                                    /* In / copied out */\n\n  int *edgelist;                                                 /* Out only */\n  int *edgemarkerlist;            /* Not used with Voronoi diagram; out only */\n  REAL *normlist;                /* Used only with Voronoi diagram; out only */\n  int numberofedges;                                             /* Out only */\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"triangulateio"})," is used to pass data into and out of the ",(0,r.jsx)(n.code,{children:"triangulate()"})," procedure."]}),"\n",(0,r.jsx)(n.p,{children:"Arrays are used to store points, triangles, markers, and so forth."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["In all cases, the first item in any array is stored starting at index [0]. However, that item is item number ",(0,r.jsx)(n.code,{children:"1"})," unless the ",(0,r.jsx)(n.code,{children:"z"})," switch is used, which is item number ",(0,r.jsx)(n.code,{children:"0"}),". Hence, you may find it easier to index points (and triangles in the neighbor list) if you use the ",(0,r.jsx)(n.code,{children:"z"})," switch. Unless, of course, you`re calling Triangle from a Fortran program."]})}),"\n",(0,r.jsxs)(n.p,{children:["Description of fields (except the ",(0,r.jsx)(n.code,{children:"numberof"})," fields, which are obvious):"]}),"\n",(0,r.jsxs)(n.h2,{id:"pointlist-in-and-out",children:[(0,r.jsx)(n.code,{children:"pointlist"})," (In and out)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An array of point coordinates."}),"\n",(0,r.jsx)(n.li,{children:"The first point's x coordinate is at index[0] and its y coordinate at index [1], followed by the coordinates of the remaining points."}),"\n",(0,r.jsx)(n.li,{children:"Each point occupies two real numbers."}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"pointattributelist-in-and-out",children:[(0,r.jsx)(n.code,{children:"pointattributelist"})," (In and out)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An array of point attributes."}),"\n",(0,r.jsxs)(n.li,{children:["Each point's attributes occupy ",(0,r.jsx)(n.code,{children:"numberofpointattributes"})," real numbers."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"pointmarkerlist-in-and-out",children:[(0,r.jsx)(n.code,{children:"pointmarkerlist"})," (In and out)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An array of point markers"}),"\n",(0,r.jsx)(n.li,{children:"one integer per point."}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"trianglelist-in-and-out",children:[(0,r.jsx)(n.code,{children:"trianglelist"})," (In and out)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An array of triangle corners."}),"\n",(0,r.jsx)(n.li,{children:"The first triangle's first corner is at index [0], followed by its other two corners in counterclockwise order, followed by any other nodes if the triangle represents a nonlinear element."}),"\n",(0,r.jsxs)(n.li,{children:["Each triangle occupies ",(0,r.jsx)(n.code,{children:"numberofcorners"})," integers."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"triangleattributelist-in-and-out",children:[(0,r.jsx)(n.code,{children:"triangleattributelist"})," (In and out)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An array of triangle attributes."}),"\n",(0,r.jsxs)(n.li,{children:["Each triangle's attributes occupy ",(0,r.jsx)(n.code,{children:"numberoftriangleattributes"})," reals."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"trianglereallist-input-only",children:[(0,r.jsx)(n.code,{children:"trianglereallist"})," (input only)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An array of triangle area constraints"}),"\n",(0,r.jsx)(n.li,{children:"one real number per triangle."}),"\n",(0,r.jsx)(n.li,{children:"Input only."}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"neighborlistoutput-only",children:[(0,r.jsx)(n.code,{children:"neighborlist"}),"(output only)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An array of triangle neighbors"}),"\n",(0,r.jsx)(n.li,{children:"three integers per triangle."}),"\n",(0,r.jsx)(n.li,{children:"Output only."}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"segmentlist-in-and-out",children:[(0,r.jsx)(n.code,{children:"segmentlist"})," (In and out)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"segmentlist"}),": An array of segment endpoints."]}),"\n",(0,r.jsx)(n.li,{children:"The first segment's endpoints are at indices [0] and [1], followed by the remaining segments."}),"\n",(0,r.jsx)(n.li,{children:"Two integers per segment."}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"segmentmarkerlist-in-and-out",children:[(0,r.jsx)(n.code,{children:"segmentmarkerlist"})," (In and out)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"segmentmarkerlist"}),": An array of segment markers"]}),"\n",(0,r.jsx)(n.li,{children:"one int per segment."}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"holelist-input-only",children:[(0,r.jsx)(n.code,{children:"holelist"})," (input only)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"holelist"}),": An array of holes."]}),"\n",(0,r.jsx)(n.li,{children:"The first hole's x and y coordinates are at indices [0] and [1], followed by the remaining holes."}),"\n",(0,r.jsx)(n.li,{children:"Two real numbers per hole."}),"\n",(0,r.jsx)(n.li,{children:"Input only, although the pointer is copied to the output structure for your convenience."}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"regionalist-input-only",children:[(0,r.jsx)(n.code,{children:"regionalist"})," (input only)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"regionlist"}),": An array of regional attributes and area constraints."]}),"\n",(0,r.jsx)(n.li,{children:"Four real numbers per area constraint."}),"\n"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"index"}),(0,r.jsx)(n.th,{children:"comment"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"x coordinate"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"y coordinate"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"regional attribute"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"maximum area"})]})]})]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Each regional attribute is used only if you select the ",(0,r.jsx)(n.code,{children:"A"})," switch, and each area constraint is used only if you select the ",(0,r.jsx)(n.code,{children:"a"})," switch (with no number following), but omitting one of these switches does not change the memory layout."]})}),"\n",(0,r.jsx)(n.p,{children:"Input only, although the pointer is copied to the output structure for your convenience."}),"\n",(0,r.jsxs)(n.h2,{id:"edgelist-output-only",children:[(0,r.jsx)(n.code,{children:"edgelist"})," (output only)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"edgelist"}),": An array of edge endpoints. The first edge's endpoints are at indices [0] and [1], followed by the remaining edges."]}),"\n",(0,r.jsx)(n.li,{children:"Two integers per edge."}),"\n",(0,r.jsx)(n.li,{children:"Output only."}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"edgemarkerlist-output-only",children:[(0,r.jsx)(n.code,{children:"edgemarkerlist"})," (output only)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"edgemarkerlist"}),": An array of edge markers; one int per edge. Output only."]}),"\n",(0,r.jsxs)(n.h2,{id:"normlist-output-only",children:[(0,r.jsx)(n.code,{children:"normlist"})," (output only)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"normlist"}),": An array of normal vectors, used for infinite rays in Voronoi diagrams."]}),"\n",(0,r.jsx)(n.li,{children:"The first normal vector's x and y magnitudes are at indices [0] and [1], followed by the remaining vectors."}),"\n",(0,r.jsx)(n.li,{children:"For each finite edge in a Voronoi diagram, the normal vector written is the zero vector."}),"\n",(0,r.jsx)(n.li,{children:"Two real numbers per edge."}),"\n",(0,r.jsx)(n.li,{children:"Output only."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},54213:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var i=t(36672);const r={},o=i.createContext(r);function l(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);