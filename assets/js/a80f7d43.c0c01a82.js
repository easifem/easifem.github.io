"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[27040],{3009:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"ARPACK/SSEUPD","title":"SSEUPD","description":"This subroutine returns the converged approximations to eigenvalues of Az = lambdaB*z.","source":"@site/docs/docs-api/ARPACK/SSEUPD.md","sourceDirName":"ARPACK","slug":"/ARPACK/SSEUPD","permalink":"/docs-api/ARPACK/SSEUPD","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/ARPACK/SSEUPD.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"SSAUPD","permalink":"/docs-api/ARPACK/SSAUPD"},"next":{"title":"SymLargestEigenval","permalink":"/docs-api/ARPACK/SymLargestEigenval"}}');var s=i(23420),t=i(54213);const l={},o="SSEUPD",d={},c=[{value:"Usage",id:"usage",level:2},{value:"RVEC",id:"rvec",level:2},{value:"HOWMNY",id:"howmny",level:2},{value:"SELECT",id:"select",level:2},{value:"D",id:"d",level:2},{value:"Z",id:"z",level:2},{value:"LDZ",id:"ldz",level:2},{value:"SIGMA",id:"sigma",level:2},{value:"Other args",id:"other-args",level:2},{value:"WORKL",id:"workl",level:2},{value:"INFO",id:"info",level:2},{value:"Remarks",id:"remarks",level:2},{value:"Remark-1",id:"remark-1",level:3},{value:"Remark-2",id:"remark-2",level:3}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"sseupd",children:"SSEUPD"})}),"\n",(0,s.jsxs)(n.p,{children:["This subroutine returns the converged approximations to eigenvalues of ",(0,s.jsx)(n.code,{children:"A*z = lambda*B*z"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Optionally, it can also return:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"the corresponding approximate eigenvectors,"}),"\n",(0,s.jsx)(n.li,{children:"an orthonormal (Lanczos) basis for the associated approximate invariant subspace"}),"\n",(0,s.jsx)(n.li,{children:"Both."}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"There is negligible additional cost to obtain eigenvectors.",type:"note",children:(0,s.jsxs)(n.p,{children:["An orthonormal (Lanczos) basis is always computed. There is an additional storage cost of ",(0,s.jsx)(n.code,{children:"n*nev"})," if both are requested (in this case a separate array Z must be supplied)."]})}),"\n",(0,s.jsxs)(n.p,{children:["These quantities are obtained from the Lanczos factorization computed by ",(0,s.jsx)(n.a,{href:"/docs-api/ARPACK/SSAUPD",children:"SSAUPD"})," for the linear operator ",(0,s.jsx)(n.code,{children:"OP"})," prescribed by the ",(0,s.jsx)(n.code,{children:"MODE"})," selection, see ",(0,s.jsx)(n.a,{href:"/docs-api/ARPACK/SSAUPD#iparam7",children:"IPARAM(7)"})," in SSAUPD documentation. Therefore, ",(0,s.jsx)(n.code,{children:"SSAUPD"})," must be called before this routine is called. These approximate eigenvalues and vectors are commonly called ",(0,s.jsx)(n.code,{children:"Ritz values"})," and ",(0,s.jsx)(n.code,{children:"Ritz vectors"})," respectively.  They are referred to as such in the comments that follow."]}),"\n",(0,s.jsx)(n.p,{children:"The computed orthonormal basis for the invariant subspace corresponding to these Ritz values is referred to as a Lanczos basis."}),"\n",(0,s.jsxs)(n.p,{children:["See documentation in the header of the subroutine SSAUPD for a definition of OP as well as other terms and the relation of computed Ritz values and vectors of OP with respect to the given problem  ",(0,s.jsx)(n.code,{children:"A*z = lambda*B*z"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The approximate eigenvalues of the original problem are returned in ascending algebraic order.  The user may elect to call this routine once for each desired Ritz vector and store it peripherally if desired."}),"\n",(0,s.jsx)(n.p,{children:"There is also the option of computing a selected set of these vectors with a single call."}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fortran",children:"  CALL SSEUPD( &\n    & RVEC, HOWMNY, SELECT, &\n    & D, Z, LDZ, SIGMA, BMAT, &\n    & N, WHICH, NEV, TOL, RESID, &\n    & NCV, V, LDV, IPARAM, &\n    & IPNTR, WORKD, WORKL, &\n    & LWORKL, INFO )\n"})}),"\n",(0,s.jsx)(n.p,{children:"RVEC, LOGICAL, INPUT"}),"\n",(0,s.jsx)(n.h2,{id:"rvec",children:"RVEC"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: LOGICAL"}),"\n",(0,s.jsx)(n.li,{children:"Intent: INPUT"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Specifies whether Ritz vectors corresponding to the Ritz value approximations to the eigenproblem ",(0,s.jsx)(n.code,{children:"A*z = lambda*B*z"})," are computed."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"RVEC"}),(0,s.jsx)(n.th,{children:"task"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".FALSE."})}),(0,s.jsx)(n.td,{children:"Compute Ritz values only."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".TRUE."})}),(0,s.jsx)(n.td,{children:"Compute Ritz vectors."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"howmny",children:"HOWMNY"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: Character*1"}),"\n",(0,s.jsx)(n.li,{children:"Intent: INPUT"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Specifies how many Ritz vectors are wanted and the form of Z the matrix of Ritz vectors. See remark 1 below."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"'A', compute NEV Ritz vectors"}),"\n",(0,s.jsx)(n.li,{children:"'S', compute some of the Ritz vectors, specified by the logical array SELECT."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"select",children:"SELECT"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: Logical array of dimension NCV."}),"\n",(0,s.jsx)(n.li,{children:"Intent: INPUT/WORKSPACE"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"HOWMNY = S"}),", ",(0,s.jsx)(n.code,{children:"SELECT"})," specifies the Ritz vectors to be computed.\nTo select the Ritz vector corresponding to a Ritz value ",(0,s.jsx)(n.code,{children:"D(j)"}),", ",(0,s.jsx)(n.code,{children:"SELECT(j)"})," must be set to ",(0,s.jsx)(n.code,{children:".TRUE."}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"HOWMNY = 'A'"}),", ",(0,s.jsx)(n.code,{children:"SELECT"})," is used as a workspace for reordering the Ritz values."]}),"\n",(0,s.jsx)(n.h2,{id:"d",children:"D"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Type: ",(0,s.jsx)(n.code,{children:"Real( NEV )"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Intent: OUTPUT"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["On exit, ",(0,s.jsx)(n.code,{children:"D"})," contains the Ritz value approximations to the eigenvalues of ",(0,s.jsx)(n.code,{children:"A*z = lambda*B*z"}),". The values are returned in ascending order. If ",(0,s.jsx)(n.code,{children:"IPARAM(7) = 3,4,5"})," then ",(0,s.jsx)(n.code,{children:"D"})," represents the Ritz values of ",(0,s.jsx)(n.code,{children:"OP"})," computed by ",(0,s.jsx)(n.code,{children:"SSAUPD"})," transformed to those of the original eigensystem ",(0,s.jsx)(n.code,{children:"A*z = lambda*B*z"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"IPARAM(7) = 1,2"})," then the Ritz values of OP are the same as the those of ",(0,s.jsx)(n.code,{children:"A*z = lambda*B*z"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"z",children:"Z"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Type: ",(0,s.jsx)(n.code,{children:"Real( N, NEV)"})," array if HOWMNY = 'A'."]}),"\n",(0,s.jsx)(n.li,{children:"Intent: OUTPUT"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["On exit, Z contains the B-orthonormal Ritz vectors of the eigensystem ",(0,s.jsx)(n.code,{children:"A*z = lambda*B*z"})," corresponding to the Ritz value approximations."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["If  ",(0,s.jsx)(n.code,{children:"RVEC = .FALSE."})," then Z is not referenced."]})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["The array ",(0,s.jsx)(n.code,{children:"Z"})," may be set equal to first ",(0,s.jsx)(n.code,{children:"NEV"})," columns of the Arnoldi/Lanczos basis array ",(0,s.jsx)(n.code,{children:"V"})," computed by SSAUPD."]})}),"\n",(0,s.jsx)(n.h2,{id:"ldz",children:"LDZ"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: Integer."}),"\n",(0,s.jsx)(n.li,{children:"Intent: INPUT"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The leading dimension of the array Z.  If Ritz vectors are desired, then  ",(0,s.jsx)(n.code,{children:"LDZ .ge.  max( 1, N )"}),".  In any case,  ",(0,s.jsx)(n.code,{children:"LDZ .ge. 1"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"sigma",children:"SIGMA"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: Real"}),"\n",(0,s.jsx)(n.li,{children:"Intent: INPUT"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"IPARAM(7) = 3,4,5"})," represents the shift. Not referenced if ",(0,s.jsx)(n.code,{children:"IPARAM(7) = 1 or 2"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"other-args",children:"Other args"}),"\n",(0,s.jsx)(n.p,{children:"The remaining arguments MUST be the same as for the call to SSAUPD that was just completed."}),"\n",(0,s.jsx)(n.p,{children:"The remaining arguments"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fortran",children:"BMAT\nN\nWHICH\nNEV\nTOL\nRESID\nNCV\nV\nLDV\nIPARAM\nIPNTR\nWORKD\nWORKL\nLWORKL\nINFO\n"})}),"\n",(0,s.jsx)(n.p,{children:"must be passed directly to SSEUPD following the last call to SSAUPD. These arguments MUST NOT BE MODIFIED between the last call to SSAUPD and the call to SSEUPD."}),"\n",(0,s.jsxs)(n.p,{children:["Two of these parameters (",(0,s.jsx)(n.code,{children:"WORKL"}),", ",(0,s.jsx)(n.code,{children:"INFO"}),") are also output parameters:"]}),"\n",(0,s.jsx)(n.h2,{id:"workl",children:"WORKL"}),"\n",(0,s.jsx)(n.p,{children:"Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"WORKL(1:4*ncv)"})," contains information obtained in ",(0,s.jsx)(n.code,{children:"ssaupd"}),".  They are not changed by ",(0,s.jsx)(n.code,{children:"sseupd"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"WORKL(4*ncv+1:ncv*ncv+8*ncv)"})," holds the untransformed Ritz values, the computed error estimates,\nand the associated eigenvector matrix of H."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.mdxAdmonitionTitle,{children:[(0,s.jsx)(n.code,{children:"IPNTR(8:10)"})," contains the pointer into ",(0,s.jsx)(n.code,{children:"WORKL"})," for addresses of the above information computed by SSEUPD."]})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IPNTR(8)"})," pointer to the NCV RITZ values of the original system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IPNTR(9)"})," pointer to the NCV corresponding error bounds."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IPNTR(10)"})," pointer to the NCV by NCV matrix of eigenvectors of the tridiagonal matrix T. Only referenced by ",(0,s.jsx)(n.code,{children:"sseupd"})," if RVEC = .TRUE. See Remarks."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"info",children:"INFO"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Integer"}),"\n",(0,s.jsx)(n.li,{children:"OUTPUT"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Error flag on output."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"0: Normal exit."}),"\n",(0,s.jsx)(n.li,{children:"-1: N must be positive."}),"\n",(0,s.jsx)(n.li,{children:"-2: NEV must be positive."}),"\n",(0,s.jsx)(n.li,{children:"-3: NCV must be greater than NEV and less than or equal to N."}),"\n",(0,s.jsx)(n.li,{children:"-5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'."}),"\n",(0,s.jsx)(n.li,{children:"-6: BMAT must be one of 'I' or 'G'."}),"\n",(0,s.jsx)(n.li,{children:"-7: Length of private work WORKL array is not sufficient."}),"\n",(0,s.jsx)(n.li,{children:"-8: Error return from trid. eigenvalue calculation; Information error from LAPACK routine ssteqr."}),"\n",(0,s.jsx)(n.li,{children:"-9: Starting vector is zero."}),"\n",(0,s.jsx)(n.li,{children:"-10: IPARAM(7) must be 1,2,3,4,5."}),"\n",(0,s.jsx)(n.li,{children:"-11: IPARAM(7) = 1 and BMAT = 'G' are incompatible."}),"\n",(0,s.jsx)(n.li,{children:"-12: NEV and WHICH = 'BE' are incompatible."}),"\n",(0,s.jsx)(n.li,{children:"-14: SSAUPD did not find any eigenvalues to sufficient accuracy."}),"\n",(0,s.jsx)(n.li,{children:"-15: HOWMNY must be one of 'A' or 'S' if RVEC = .true."}),"\n",(0,s.jsx)(n.li,{children:"-16: HOWMNY = 'S' not yet implemented"}),"\n",(0,s.jsx)(n.li,{children:"-17: SSEUPD got a different count of the number of converged Ritz values than SSAUPD got. This indicates the user probably made an error in passing data from SSAUPD to SSEUPD or that the data was modified before entering SSEUPD."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"remarks",children:"Remarks"}),"\n",(0,s.jsx)(n.h3,{id:"remark-1",children:"Remark-1"}),"\n",(0,s.jsx)(n.p,{children:"The converged Ritz values are always returned in increasing (algebraic) order."}),"\n",(0,s.jsx)(n.h3,{id:"remark-2",children:"Remark-2"}),"\n",(0,s.jsx)(n.p,{children:"Currently only HOWMNY = 'A' is implemented. It is included at this stage for the user who wants to incorporate it."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},54213:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var r=i(36672);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);