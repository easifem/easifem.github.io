"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[706],{54488:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"VTKFile/VTKFile_","title":"Structure","description":"VTKFile class is a child of [XMLFile]]. It is used for visualizing the results using vtk library or paraview.  You can find more details on the [Website","source":"@site/docs/docs-api/VTKFile/VTKFile_.md","sourceDirName":"VTKFile","slug":"/VTKFile/VTKFile_","permalink":"/docs-api/VTKFile/VTKFile_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/VTKFile/VTKFile_.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"VTKFile","permalink":"/docs-api/VTKFile/"},"next":{"title":"VTKFile example 1","permalink":"/docs-api/VTKFile/VTKFile_test_1"}}');var i=t(23420),r=t(54213);const s={},l="Structure",d={},c=[{value:"Serial Format",id:"serial-format",level:2},{value:"ImageData",id:"imagedata",level:3},{value:"RectilinearGrid",id:"rectilineargrid",level:3},{value:"StructuredGrid",id:"structuredgrid",level:3},{value:"PolyData",id:"polydata",level:3},{value:"UnstructuredGrid",id:"unstructuredgrid",level:3},{value:"Module structure",id:"module-structure",level:2},{value:"VTKDataArrayEncoder",id:"vtkdataarrayencoder",level:3},{value:"XMLFile",id:"xmlfile",level:3},{value:"ConstructorMethods",id:"constructormethods",level:2},{value:"InitiateVTKFile",id:"initiatevtkfile",level:3},{value:"AddSurrogate",id:"addsurrogate",level:3},{value:"Deallocate",id:"deallocate",level:3},{value:"Close",id:"close",level:3},{value:"OpenScratchFile",id:"openscratchfile",level:3},{value:"CloseScratchFile",id:"closescratchfile",level:3},{value:"TagsMethods",id:"tagsmethods",level:2},{value:"WriteRootTag",id:"writeroottag",level:3},{value:"WriteDataStructureTag",id:"writedatastructuretag",level:3},{value:"WriteStartTag",id:"writestarttag",level:3},{value:"WriteEndTag",id:"writeendtag",level:3},{value:"WriteSelfClosingTag",id:"writeselfclosingtag",level:3},{value:"WriteTag",id:"writetag",level:3},{value:"VertMethods",id:"vertmethods",level:2},{value:"WriteVerts",id:"writeverts",level:3},{value:"CellMethods",id:"cellmethods",level:2},{value:"WriteCells",id:"writecells",level:3},{value:"DataArrayMethods",id:"dataarraymethods",level:2},{value:"WriteDataArrayLocationTag",id:"writedataarraylocationtag",level:3},{value:"WriteDataArrayTag",id:"writedataarraytag",level:3},{value:"WriteDataArray",id:"writedataarray",level:3},{value:"DataArrayAppendedMethods",id:"dataarrayappendedmethods",level:2},{value:"WriteToScratch",id:"writetoscratch",level:3},{value:"FieldDataMethods",id:"fielddatamethods",level:2},{value:"WriteFieldData",id:"writefielddata",level:3},{value:"PointsMethods",id:"pointsmethods",level:2},{value:"WritePoints",id:"writepoints",level:3},{value:"PieceMethods",id:"piecemethods",level:2}];function o(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"structure",children:"Structure"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"VTKFile_"})," class is a child of [[XMLFile_]]. It is used for visualizing the results using ",(0,i.jsx)(n.code,{children:"vtk"})," library or ",(0,i.jsx)(n.code,{children:"paraview"}),".  You can find more details on the ",(0,i.jsx)(n.a,{href:"https://kitware.github.io/vtk-examples/site/VTKFileFormats",children:"Website"})]}),"\n",(0,i.jsx)(n.p,{children:"The major motivation for XML based VTKFile was to facilitate data streaming and parallel I/O. Some features of the format include support for compression, portable binary encoding, random access, big endian and little endian byte order, multiple file representation of piece data, and new file extensions for different VTK dataset types. XML provides many features as well, especially the ability to extend a file format with application specific tags."}),"\n",(0,i.jsx)(n.p,{children:"There are two types of VTK XML data files: parallel and serial as described in the following."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Serial"}),". File types designed for reading and writing by applications of only a single process. All of the data are contained within a single file."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parallel"}),". File types designed for reading and writing by applications with multiple processes executing in parallel. The dataset is broken into pieces. Each process is assigned a piece or set of pieces to read or write. An individual piece is stored in a corresponding serial file type. The parallel file type does not actually contain any data, but instead describes structural information and then references other serial files containing the data for each piece."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In the XML format, VTK datasets are classified into one of two categories."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Structured"}),". The dataset is a topologically regular array of cells such as pixels and voxels (e.g., image data) or quadrilaterals and hexahedra (e.g., structured grid). Rectangular subsets of the data are described through extents. The structured dataset types are\xa0",(0,i.jsx)(n.a,{href:"https://www.vtk.org/doc/nightly/html/classvtkImageData.html#details",children:"vtkImageData"}),",\xa0",(0,i.jsx)(n.a,{href:"https://www.vtk.org/doc/nightly/html/classvtkRectilinearGrid.html#details",children:"vtkRectilinearGrid"}),", and\xa0",(0,i.jsx)(n.a,{href:"https://www.vtk.org/doc/nightly/html/classvtkStructuredGrid.html#details",children:"vtkStructuredGrid"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Unstructured"}),". The dataset forms a topologically irregular set of points and cells. Subsets of the data are describedusing pieces. The unstructured dataset types are\xa0",(0,i.jsx)(n.a,{href:"https://www.vtk.org/doc/nightly/html/classvtkPolyData.html#details",children:"vtkPolyData"}),"\xa0and\xa0",(0,i.jsx)(n.a,{href:"https://www.vtk.org/doc/nightly/html/classvtkUnstructuredGrid.html#details",children:"vtkUnstructuredGrid"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"By convention, each data type and file type is paired with a particular file extension. The types and corresponding extensions are"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["ImageData (",(0,i.jsx)(n.em,{children:".vti"}),") \u2014 Serial, structured."]}),"\n",(0,i.jsxs)(n.li,{children:["PolyData (",(0,i.jsx)(n.em,{children:".vtp"}),") \u2014 Serial, unstructured."]}),"\n",(0,i.jsxs)(n.li,{children:["RectilinearGrid (",(0,i.jsx)(n.em,{children:".vtr"}),") \u2014 Serial, structured."]}),"\n",(0,i.jsxs)(n.li,{children:["StructuredGrid (",(0,i.jsx)(n.em,{children:".vts"}),") \u2014 Serial, structured."]}),"\n",(0,i.jsxs)(n.li,{children:["UnstructuredGrid (",(0,i.jsx)(n.em,{children:".vtu"}),") \u2014 Serial, unstructured."]}),"\n",(0,i.jsxs)(n.li,{children:["PImageData (",(0,i.jsx)(n.em,{children:".pvti"}),") \u2014 Parallel, structured."]}),"\n",(0,i.jsxs)(n.li,{children:["PPolyData (",(0,i.jsx)(n.em,{children:".pvtp"}),") \u2014 Parallel, unstructured."]}),"\n",(0,i.jsxs)(n.li,{children:["PRectilinearGrid (",(0,i.jsx)(n.em,{children:".pvtr"}),") \u2014 Parallel, structured."]}),"\n",(0,i.jsxs)(n.li,{children:["PStructuredGrid (",(0,i.jsx)(n.em,{children:".pvts"}),") \u2014 Parallel, structured."]}),"\n",(0,i.jsxs)(n.li,{children:["PUnstructuredGrid (",(0,i.jsx)(n.em,{children:".pvtu"}),") \u2014 Parallel, unstructured."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"All of the VTK XML file types are valid XML documents."}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"There is one case in which the file is not a valid XML document. When the AppendedData section is not encoded as base64, raw binary data is present that may violate the XML specification. This is not default behavior, and must be explicitly enabled by the user."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"serial-format",children:"Serial Format"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Serial XML File Formats"})," The VTKFile element contains one element whose name corresponds to the type of dataset the file describes. We refer to this as the dataset element, which is one of"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ImageData"}),"\n",(0,i.jsx)(n.li,{children:"RectilinearGrid"}),"\n",(0,i.jsx)(n.li,{children:"StructuredGrid"}),"\n",(0,i.jsx)(n.li,{children:"PolyData"}),"\n",(0,i.jsx)(n.li,{children:"UnstructuredGrid."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The dataset element contains one or more Piece elements, each describing a portion of the dataset (See ",(0,i.jsx)(n.code,{children:"WriteDataStructureTag()"}),"). Together, the dataset element and Piece elements specify the entire dataset."]}),"\n",(0,i.jsx)(n.p,{children:"Each piece of a dataset must specify the geometry (points and cells) of that piece along with the data associated with each point or cell. Geometry is specified differently for each dataset type, but every piece of every dataset contains PointData and CellData elements specifying the data for each point and cell in the piece."}),"\n",(0,i.jsx)(n.p,{children:"The general structure for each serial dataset format is as follows:"}),"\n",(0,i.jsx)(n.h3,{id:"imagedata",children:"ImageData"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each ImageData piece specifies its extent within the dataset\u2019s whole extent (See, WholeExtent in InitiateVTKFile). See [[#WriteRootTag]]"}),"\n",(0,i.jsx)(n.li,{children:"The points and cells are described implicitly by the extent, origin, and spacing. See [[#PieceMethods]]"}),"\n",(0,i.jsx)(n.li,{children:"Note that the origin and spacing are constant across all pieces, so they are specified as attributes of the ImageData XML element as follows."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"<VTKFile type=\u201dImageData\u201d ...>\n  <ImageData WholeExtent=\u201dx1 x2 y1 y2 z1 z2\u201d\n   Origin=\u201dx0 y0 z0\u201d Spacing=\u201ddx dy dz\u201d>\n   <Piece Extent=\u201dx1 x2 y1 y2 z1 z2\u201d>\n      <PointData>...</PointData>\n      <CellData>...</CellData>\n   </Piece>\n   </ImageData>\n</VTKFile>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"rectilineargrid",children:"RectilinearGrid"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each RectilinearGrid piece specifies its extent within the dataset\u2019s whole extent. See [[#WriteRootTag]]"}),"\n",(0,i.jsx)(n.li,{children:"The points are described by the Coordinates element. See [[#PointsMethods]]"}),"\n",(0,i.jsx)(n.li,{children:"The cells are described implicitly by the extent."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<VTKFile type="RectilinearGrid" ...>\n  <RectilinearGrid WholeExtent="x1 x2 y1 y2 z1 z2">\n    <Piece Extent="x1 x2 y1 y2 z1 z2">\n    <PointData>...</PointData>\n    <CellData>...</CellData>\n    <Coordinates>...</Coordinates>\n    </Piece>\n  </RectilinearGrid>\n</VTKFile>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"structuredgrid",children:"StructuredGrid"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each StructuredGrid piece specifies its extent within the dataset\u2019s whole extent. See [[#WriteRootTag]]"}),"\n",(0,i.jsx)(n.li,{children:"The points are described explicitly by the Points element. See [[#PointsMethods]]"}),"\n",(0,i.jsx)(n.li,{children:"The cells are described implicitly by the extent."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<VTKFile type="StructuredGrid" ...>\n  <StructuredGrid WholeExtent="x1 x2 y1 y2 z1 z2">\n    <Piece Extent="x1 x2 y1 y2 z1 z2">\n    <PointData>...</PointData>\n    <CellData>...</CellData>\n    <Points>...</Points>\n    </Piece>\n  </StructuredGrid>\n</VTKFile>\n'})}),"\n",(0,i.jsx)(n.p,{children:"You can learn more about StructuredGrid from following examples:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"[[VTKFile_test_4]]"}),"\n",(0,i.jsx)(n.li,{children:"[[VTKFile_test_5]]"}),"\n",(0,i.jsx)(n.li,{children:"[[VTKFile_test_6]]"}),"\n",(0,i.jsx)(n.li,{children:"[[VTKFile_test_7]]"}),"\n",(0,i.jsx)(n.li,{children:"[[VTKFile_test_8]]"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"polydata",children:"PolyData"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each PolyData piece specifies a set of points and cells independently from the other pieces."}),"\n",(0,i.jsx)(n.li,{children:"The points are described explicitly by the Points element."}),"\n",(0,i.jsx)(n.li,{children:"The cells are described explicitly by the Verts, Lines, Strips, and Polys elements."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<VTKFile type="PolyData" ...>\n  <PolyData>\n    <Piece NumberOfPoints="#" NumberOfVerts="#" NumberOfLines="#"\n      NumberOfStrips="#" NumberOfPolys="#">\n    <PointData>...</PointData>\n    <CellData>...</CellData>\n    <Points>...</Points>\n    <Verts>...</Verts>\n    <Lines>...</Lines>\n    <Strips>...</Strips>\n    <Polys>...</Polys>\n   </Piece>\n  </PolyData>\n</VTKFile>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"unstructuredgrid",children:"UnstructuredGrid"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Each UnstructuredGrid piece specifies a set of points and cells independently from the other pieces. See [[#PieceMethods]]"}),"\n",(0,i.jsx)(n.li,{children:"The points are described explicitly by the Points element. See [[#PointsMethods]]"}),"\n",(0,i.jsx)(n.li,{children:"The cells are described explicitly by the Cells element. See [[#CellMethods]]"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<VTKFile type="UnstructuredGrid" ...>\n  <UnstructuredGrid>\n    <Piece NumberOfPoints="#" NumberOfCells="#">\n    <PointData>...</PointData>\n    <CellData>...</CellData>\n    <Points>...</Points>\n    <Cells>...</Cells>\n    </Piece>\n  </UnstructuredGrid>\n</VTKFile>\n'})}),"\n",(0,i.jsx)(n.h2,{id:"module-structure",children:"Module structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:'TYPE, EXTENDS( XMLFile_ ) :: VTKFile_\n  PRIVATE\n  LOGICAL( LGT ) :: isStructured = .FALSE.\n    !! Is dataset structured\n  INTEGER( I4B ) :: dataStructureType = 0\n    !! 1 : VTK_ImageData\n    !! 2 : VTK_RectilinearGrid\n    !! 3 : VTK_StructuredGrid\n    !! 4 : VTK_PolyData\n    !! 5 : VTK_UnstructuredGrid\n    !! 6 : PARALLEL_VTK_ImageData\n    !! 7 : PARALLEL_VTK_RectilinearGrid\n    !! 8 : PARALLEL_VTK_StructuredGrid\n    !! 9 : PARALLEL_VTK_PolyData\n    !! 10: PARALLEL_VTK_UnstructuredGrid\n  CHARACTER( LEN = MAX_LEN_DATA_STRUCTURENAME ) :: dataStructureName\n    !! ImageData,\n    !! RectilinearGrid,\n    !! StructuredGrid,\n    !! PolyData,\n    !! UnstructuredGrid\n    !! PImageData\n    !! PRectilinearGrid\n    !! PStructuredGrid\n    !! PPolyData\n    !! PUnstructuredGrid\n  INTEGER( I4B ) :: dataFormat = 0\n    !! VTK_ASCII\n    !! VTK_BINARY\n    !! VTK_APPENDED\n    !! VTK_RAW_APPENDED\n    !! VTK_BINARY_APPENDED\n  INTEGER( I4B ) :: wholeExtent( 6 ) = 0\n    !! Whole extent\n  INTEGER( I4B ) :: indent = 0\n    !! Indent\n  INTEGER( I4B ) :: offset = 0\n    !! offset for appended mode\n  TYPE( String ) :: encoding4Appended\n    !! appended data encoding: "raw" or "base64".\n  INTEGER( I4B ) :: scratch=0\n    !! Used for scratch file\n  LOGICAL( LGT ) :: isVolatile = .FALSE.\n  TYPE( String ) :: volatileBuffer\n'})}),"\n",(0,i.jsx)(n.h3,{id:"vtkdataarrayencoder",children:"VTKDataArrayEncoder"}),"\n",(0,i.jsxs)(n.p,{children:["This module provides a function called ",(0,i.jsx)(n.code,{children:"EncodeVTKDataArray"})," which helps us encoding the Fortran array into VTK Format."]}),"\n",(0,i.jsx)(n.p,{children:"We have following interface:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE FUNCTION EncodeVTKDataArray( x, fmt ) RESULT( Ans )\nEND FUNCTION EncodeVTKDataArray\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"x"})," is a Fortran array of intrinsic type, It can be a Rank-1, Rank-2, Rank-3 and Rank-4 array of ",(0,i.jsx)(n.code,{children:"Real32"}),", ",(0,i.jsx)(n.code,{children:"Real64"}),", ",(0,i.jsx)(n.code,{children:"Int8"}),", ",(0,i.jsx)(n.code,{children:"Int16"}),", ",(0,i.jsx)(n.code,{children:"Int32"}),", ",(0,i.jsx)(n.code,{children:"Int64"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"fmt"})," is a string variable having values ",(0,i.jsx)(n.code,{children:'"ASCII", "BINARY"'}),". In ASCII format two numbers are separated by a space."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ans"})," is the encoded string"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:'Encoding of Rank-1 is easy to understand "x(1) x(2) x(3) ... x(N)"'}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Encoding of Rank-2 is in Column major, that is, That is encoding of RESHAPE( x, [N*2])"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Encoding of higher rank is also in Column major, that is, encoding of RESHAPE( x, [N*Rank])"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We have another interface described below."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE FUNCTION EncodeVTKDataArray( x, y, z, fmt ) RESULT( Ans )\nEND FUNCTION EncodeVTKDataArray\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"x,y,z"})," can be Rank-1, Rank-2, Rank-3 of type ",(0,i.jsx)(n.code,{children:"Int8"}),", ",(0,i.jsx)(n.code,{children:"Int16"}),", ",(0,i.jsx)(n.code,{children:"Int32"}),", ",(0,i.jsx)(n.code,{children:"Int64"}),",  ",(0,i.jsx)(n.code,{children:"Real32"}),", and ",(0,i.jsx)(n.code,{children:"Real64"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ans"})," is the encoded string"]}),"\n",(0,i.jsx)(n.li,{children:'The encoding of Rank-1 is "x(1) y(1) z(1) ... x(N) y(N) z(N)"'}),"\n",(0,i.jsx)(n.li,{children:'The encoding of Rank-2 is in column major "x(1,jj) y(1, jj) z(1,jj) ... x(N,jj) y(N,jj) z(N,jj)".'}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"xmlfile",children:"XMLFile"}),"\n",(0,i.jsx)(n.p,{children:"You can find more details at [[XMLFile_]]"}),"\n",(0,i.jsx)(n.h2,{id:"constructormethods",children:"ConstructorMethods"}),"\n",(0,i.jsx)(n.h3,{id:"initiatevtkfile",children:"InitiateVTKFile"}),"\n",(0,i.jsxs)(n.p,{children:["This subroutine creates an instance of ",(0,i.jsx)(n.code,{children:"VTKFile"}),". This routine initiates the ",(0,i.jsx)(n.code,{children:"XMLFile"}),", and opens it. It also write header file by calling ",(0,i.jsx)(n.code,{children:"WriteRootTag()"})," and DataStructure tag by calling ",(0,i.jsx)(n.code,{children:"WriteDataStructureTag()"}),". It also opens the scratch file."]}),"\n",(0,i.jsx)(n.p,{children:"The interface is given below"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE InitiateVTKFile( obj, filename, mode, DataFormat, &\n  & DataStructureType, WholeExtent, isVolatile, meshDataFormat, &\n  & Spacing, Origin )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  CHARACTER( LEN = * ), INTENT( IN ) :: filename\n    !! Name of the file, where xml data will be printed\n  CHARACTER( LEN = * ), INTENT( IN ) :: mode\n    !! READ, WRITE, NEW, REPLACE\n  INTEGER( I4B ), INTENT( IN ) :: DataFormat\n    !! VTK_ASCII, VTK_APPENEDED, VTK_BINARY\n  INTEGER( I4B ), INTENT( IN ) :: DataStructureType\n    !! VTK_IMAGEDATA, VTK_STRUCTUREDGRID, etc.\n  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: WholeExtent( : )\n    !! Required for structured data set\n    !! [x1, x2, y1, y2, z1, z2]\n  LOGICAL( LGT ), OPTIONAL, INTENT( IN ) :: isVolatile\n    !! True if volatileBuffer is used to keep the xml file\n  CHARACTER( LEN = * ), OPTIONAL, INTENT( IN ) :: meshDataFormat\n    !! Float32, Float64, etc\n  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: Spacing( : )\n    !! dx, dy, dz, needed in case of ImageData\n  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: Origin( : )\n    !! x0, y0, z0, needed in case of ImageData\nEND SUBROUTINE InitiateVTKFile\n"})}),"\n",(0,i.jsx)(n.h3,{id:"addsurrogate",children:"AddSurrogate"}),"\n",(0,i.jsx)(n.p,{children:"Add surrogate to the module exception handler"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE AddSurrogate( obj, UserObj )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( ExceptionHandler_ ), INTENT( IN ) :: UserObj\nEND SUBROUTINE AddSurrogate\n"})}),"\n",(0,i.jsx)(n.h3,{id:"deallocate",children:"Deallocate"}),"\n",(0,i.jsx)(n.p,{children:"Deallocate the data stored in the file, and close the file."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE Deallocate( obj, delete )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  LOGICAL( LGT ), OPTIONAL, INTENT( IN ) :: delete\nEND SUBROUTINE Deallocate\n"})}),"\n",(0,i.jsx)(n.h3,{id:"close",children:"Close"}),"\n",(0,i.jsx)(n.p,{children:"If the file is open then close the file."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE Close( obj )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\nEND SUBROUTINE Close\n"})}),"\n",(0,i.jsx)(n.h3,{id:"openscratchfile",children:"OpenScratchFile"}),"\n",(0,i.jsxs)(n.p,{children:["Opens the scratch file if data format is ",(0,i.jsx)(n.code,{children:"VTK_APPENDED"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE OpenScratchFile( obj )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\nEND SUBROUTINE OpenScratchFile\n"})}),"\n",(0,i.jsx)(n.h3,{id:"closescratchfile",children:"CloseScratchFile"}),"\n",(0,i.jsx)(n.p,{children:"Closes the scratchFile"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE CloseScratchFile( obj )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\nEND SUBROUTINE CloseScratchFile\n"})}),"\n",(0,i.jsx)(n.h2,{id:"tagsmethods",children:"TagsMethods"}),"\n",(0,i.jsx)(n.h3,{id:"writeroottag",children:"WriteRootTag"}),"\n",(0,i.jsx)(n.p,{children:"This routine write the root tag. This routine is called when we initiate\nthe VTKFile."}),"\n",(0,i.jsxs)(n.p,{children:["The document-level element is\xa0",(0,i.jsx)(n.em,{children:"VTKFile"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"<VTKFile type=\u201dImageData\u201d version=\u201d0.1\u201d byte_order=\u201dLittleEndian\u201d> ... </VTKFile>\n"})}),"\n",(0,i.jsx)(n.p,{children:"The attributes of the element are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"type"}),"\xa0\u2014 The type of the file (the bulleted items in the previous list)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"version"}),"\xa0\u2014 File version number in \u201cmajor.minor\u201d format."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"byte_order"}),"\xa0\u2014 Machine byte order in which data are stored. This is either \u201cBigEndian\u201d or \u201cLittleEndian\u201d."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"compressor"}),"\xa0\u2014 Some data in the file may be compressed. This specifies the subclass of\xa0",(0,i.jsx)(n.a,{href:"https://www.vtk.org/doc/nightly/html/classvtkDataCompressor.html#details",children:"vtkDataCompressor"}),"\xa0that was used to compress the data."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Nested inside the\xa0",(0,i.jsx)(n.code,{children:"VTKFile"}),"\xa0element is an element whose name corresponds to the type of the data format (i.e., the ",(0,i.jsx)(n.code,{children:"type"}),"\xa0attribute). This element describes the topology the dataset, and is different for the serial and parallel formats, which are described as follows."]}),"\n",(0,i.jsxs)(n.p,{children:["The fortran interface for ",(0,i.jsx)(n.code,{children:"WriteRootTag"})," is given below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE VTKFile_WriteRootTag( obj )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\nEND SUBROUTINE VTKFile_WriteRootTag\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"writedatastructuretag",children:"WriteDataStructureTag"}),"\n",(0,i.jsx)(n.p,{children:"Please read the InitiateVTKFile routine."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE VTKFile_WriteDataStructureTag( obj, meshDataFormat )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  CHARACTER( LEN = * ), OPTIONAL, INTENT( IN ) :: meshDataFormat\n    !! Float32, Float64\n    !! It should be present for parallel data structure\n    !! PARALLEL_VTK_RECTILINEARGRID, PARALLEL_VTK_STRUCTUREDGRID,\n    !! PARALLEL_VTK_UNSTRUCTUREDGRID\nEND SUBROUTINE VTKFile_WriteDataStructureTag\n"})}),"\n",(0,i.jsx)(n.h3,{id:"writestarttag",children:"WriteStartTag"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE VTKFile_WriteStartTag( obj, name, attrNames, attrValues )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: name\n  TYPE( String ), OPTIONAL, INTENT( IN ) :: attrNames( : )\n  TYPE( String ), OPTIONAL, INTENT( IN ) :: attrValues( : )\nEND SUBROUTINE VTKFile_WriteStartTag\n"})}),"\n",(0,i.jsx)(n.h3,{id:"writeendtag",children:"WriteEndTag"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE VTKFile_WriteEndTag( obj, name )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: name\nEND SUBROUTINE VTKFile_WriteEndTag\n"})}),"\n",(0,i.jsx)(n.h3,{id:"writeselfclosingtag",children:"WriteSelfClosingTag"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE VTKFile_WriteSelfClosingTag( obj, name, attrNames, &\n  & attrValues )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: name\n  TYPE( String ), OPTIONAL, INTENT( IN ) :: attrNames( : )\n  TYPE( String ), OPTIONAL, INTENT( IN ) :: attrValues( : )\nEND SUBROUTINE VTKFile_WriteSelfClosingTag\n"})}),"\n",(0,i.jsx)(n.h3,{id:"writetag",children:"WriteTag"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE VTKFile_WriteTag( obj, name, attrNames, &\n  & attrValues, content )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: name\n  TYPE( String ), OPTIONAL, INTENT( IN ) :: attrNames( : )\n  TYPE( String ), OPTIONAL, INTENT( IN ) :: attrValues( : )\n  TYPE( String ), OPTIONAL, INTENT( IN ) :: content\nEND SUBROUTINE VTKFile_WriteTag\n"})}),"\n",(0,i.jsx)(n.h2,{id:"vertmethods",children:"VertMethods"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Verts, Lines, Strips, and Polys"})," \u2014 The Verts, Lines, Strips, and Polys elements define cells explicitly by specifying point connectivity. Cell types are implicitly known by the type of element in which they are specified. Each element contains two DataArray elements. The first array specifies the point connectivity. All the cells\u2019 point lists are concatenated together. The second array specifies the offset into the connectivity array for the end of each cell."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<Verts>\n  <DataArray type="Int32" Name="connectivity" .../>\n  <DataArray type="Int32" Name="offsets" .../>\n</Verts>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"writeverts",children:"WriteVerts"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WriteVerts( obj, connectivity, offsets )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  INTEGER( I4B ), INTENT( IN ) :: connectivity( : )\n  INTEGER( I4B ), INTENT( IN ) :: offsets( : )\nEND SUBROUTINE WriteVerts\n"})}),"\n",(0,i.jsx)(n.h2,{id:"cellmethods",children:"CellMethods"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Cells"})," \u2014 The Cells element defines cells explicitly by specifying point connectivity and cell types. It contains three DataArray elements. The first array specifies the point ",(0,i.jsx)(n.code,{children:"connectivity"}),". All the cells\u2019 point lists are concatenated together. The second array specifies the ",(0,i.jsx)(n.code,{children:"offset"})," into the connectivity array for the end of each cell. The third array specifies the ",(0,i.jsx)(n.code,{children:"type"})," of each cell."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'  <Cells>\n    <DataArray type="Int32" Name="connectivity" .../>\n    <DataArray type="Int32" Name="offsets" .../>\n    <DataArray type="UInt8" Name="types" .../>\n  </Cells>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"writecells",children:"WriteCells"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\nMODULE SUBROUTINE WriteCells( obj, connectivity, offsets, types )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  INTEGER( I4B ), INTENT( IN ) :: connectivity( : )\n  INTEGER( I4B ), INTENT( IN ) :: offsets( : )\n  INTEGER( Int8 ), INTENT( IN ) :: types( : )\nEND SUBROUTINE WriteCells\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"dataarraymethods",children:"DataArrayMethods"}),"\n",(0,i.jsx)(n.p,{children:"Every dataset describes the data associated with its points and cells with PointData and CellData XML elements as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'  <PointData Scalars="Temperature" Vectors="Velocity">\n    <DataArray Name="Velocity" .../>\n    <DataArray Name="Temperature" .../>\n    <DataArray Name="Pressure" .../>\n  </PointData>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We specify ",(0,i.jsx)(n.code,{children:"PointData"})," or ",(0,i.jsx)(n.code,{children:"CellData"})," by using the [[#WriteDataArrayLocationTag]]. We can write DataArray element by using [[#WriteDataArrayTag]]. The content inside the DataArray can also be written by using [[#WriteDataArrayTag]]. One can also use the [[#WriteDataArray]] method to write the content in simple way."]}),"\n",(0,i.jsxs)(n.p,{children:["VTK allows an arbitrary number of data arrays to be associated with the points and cells of a dataset. Each data array is described by a ",(0,i.jsx)(n.code,{children:"DataArray"})," element which, among other things, gives each array a name. The following attributes of ",(0,i.jsx)(n.code,{children:"PointData"})," and ",(0,i.jsx)(n.code,{children:"CellData"})," are used to specify the active arrays by name:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Scalars \u2014 The name of the active scalars array, if any."}),"\n",(0,i.jsx)(n.li,{children:"Vectors \u2014 The name of the active vectors array, if any."}),"\n",(0,i.jsx)(n.li,{children:"Normals \u2014 The name of the active normals array, if any."}),"\n",(0,i.jsx)(n.li,{children:"Tensors \u2014 The name of the active tensors array, if any."}),"\n",(0,i.jsx)(n.li,{children:"TCoords \u2014 The name of the active texture coordinates array, if any."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"DataArray"})," \u2014 The DataArray element stores a sequence of values of one type. There may be one or more components per value."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<DataArray type="Float32" Name="vectors" NumberOfComponents="3"\n           format="appended" offset="0"/>\n<DataArray type="Float32" Name="scalars" format="binary">\n           bAAAAAAAAAAAAIA/AAAAQAAAQEAAAIBA... </DataArray>\n<DataArray type="Int32" Name="offsets" format="ascii">\n           10 20 30 ... </DataArray>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The attributes of the ",(0,i.jsx)(n.code,{children:"DataArray"})," elements are described as follows"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"type"})," \u2014 The data type of a single component of the array. This is one of Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Float32, Float64. Note: the 64-bit integer types are only supported if ",(0,i.jsx)(n.code,{children:"VTK_USE_64BIT_IDS"})," is on the platform is 64-bit."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Name"})," \u2014 The name of the array. This is usually a brief description of the data stored in the array."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"NumberOfComponents"})," \u2014 The number of components per value in the array."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"format"})," \u2014 The means by which the data values themselves are stored in the file. This is \u201cascii\u201d, \u201cbinary\u201d, or \u201cappended\u201d."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"offset"})," \u2014 If the format attribute is \u201cappended\u201d, this specifies the offset from the beginning of the appended data section to the beginning of this array\u2019s data."]}),"\n",(0,i.jsx)(n.p,{children:"The format attribute chooses among the three ways in which data values can be stored:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"format=\u201dascii\u201d \u2014 The data are listed in ASCII directly inside the DataArray element. Whitespace is used for separation."}),"\n",(0,i.jsx)(n.li,{children:"format=\u201dbinary\u201d \u2014 The data are encoded in base64 and listed contiguously inside the DataArray element. Data may also be compressed before encoding in base64. The byte-order of the data matches that specified by the byte_order attribute of the VTKFile element."}),"\n",(0,i.jsx)(n.li,{children:"format=\u201dappended\u201d \u2014 The data are stored in the appended data section. Since many DataArray elements may store their data in this section, the offset attribute is used to specify where each DataArray\u2019s data begins. This format is the default used by VTK\u2019s writers."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The appended data section is stored in an AppendedData element that is nested inside VTKFile after the dataset element:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<VTKFile ...>\n  ...\n  <AppendedData encoding="base64">\n                _QMwEAAAAAAAAA...\n  </AppendedData>\n</VTKFile>\n'})}),"\n",(0,i.jsx)(n.p,{children:"The appended data section begins with the first character after the underscore inside the AppendedData element. The underscore is not part of the data, but is always present. Data in this section is always in binary form, but can be compressed and/or base64 encoded. The byte-order of the data matches that specified by the byte_order attribute of the VTKFile element. Each DataArray\u2019s data are stored contiguously and appended immediately after the previous DataArray\u2019s data without a seperator. The DataArray\u2019s offset attribute indicates the file position offset from the first character after the underscore to the beginning its data."}),"\n",(0,i.jsx)(n.h3,{id:"writedataarraylocationtag",children:"WriteDataArrayLocationTag"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:'MODULE SUBROUTINE VTKFile_WriteDataArrayLocationTag( obj, location, action )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: location\n    !! "CELL" and "NODE"\n  TYPE( String ), INTENT( IN ) :: action\n    !! "OPEN" or "CLOSE"\nEND SUBROUTINE VTKFile_WriteDataArrayLocationTag\n'})}),"\n",(0,i.jsx)(n.h3,{id:"writedataarraytag",children:"WriteDataArrayTag"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE VTKFile_WriteDataArrayTag( obj, dataType, name, &\n  & numberOfComponents, content, isTuples, isOffset )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: dataType\n  TYPE( String ), INTENT( IN ) :: name\n  INTEGER( I4B ), INTENT( IN ) :: numberOfComponents\n  TYPE( String ), OPTIONAL, INTENT( IN ) :: content\n  LOGICAL( LGT ), OPTIONAL, INTENT( IN ) :: isTuples\n  LOGICAL( LGT ), OPTIONAL, INTENT( IN ) :: isOffset\nEND SUBROUTINE VTKFile_WriteDataArrayTag\n"})}),"\n",(0,i.jsx)(n.h3,{id:"writedataarray",children:"WriteDataArray"}),"\n",(0,i.jsx)(n.p,{children:"This routine write the data array to VTK file. There are two main interface as explained below. This routine encode the fortran array into strings and then make a call to [[#WriteDataArrayTag]] routine."}),"\n",(0,i.jsx)(n.p,{children:"Interface:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WriteDataArray( obj, name, x, isTuples, numberOfComponents )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: name\n  TYPE( Real32/Real64/Int8/Int16/Int32/Int64 ), INTENT( IN ) :: x (rank-1/2/3/4)\n  LOGICAL( LGT ), OPTIONAL, INTENT( IN ) :: isTuples\n  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: numberOfComponents\nEND SUBROUTINE WriteDataArray\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Here ",(0,i.jsx)(n.code,{children:"x"})," can be a rank-1,2,3,4 array of Fortran intrinsic type  Int8/Int16/Int32/Int64, Real32/Real64"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"isTuples"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"numberOfComponents"})," For rank-1 array, by default the number of components will be 1. For rank>1, the number of components will be the size of first dimension, that is, SIZE(x,1)."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The another interface is given below"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WriteDataArray( obj, name, x, y, z, isTuples )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: name\n  TYPE( Real32/Real64/Int8/Int16/Int32/Int64 ), INTENT( IN ) :: x (rank-1/2/3/4)\n  TYPE( Real32/Real64/Int8/Int16/Int32/Int64 ), INTENT( IN ) :: y (rank-1/2/3/4)\n  TYPE( Real32/Real64/Int8/Int16/Int32/Int64 ), INTENT( IN ) :: z (rank-1/2/3/4)\n  LOGICAL( LGT ), OPTIONAL, INTENT( IN ) :: isTuples\nEND SUBROUTINE WriteDataArray\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this case the number of components are always 3."}),"\n",(0,i.jsx)(n.h2,{id:"dataarrayappendedmethods",children:"DataArrayAppendedMethods"}),"\n",(0,i.jsx)(n.h3,{id:"writetoscratch",children:"WriteToScratch"}),"\n",(0,i.jsx)(n.p,{children:"This generic routine can be used to write to scratch file."}),"\n",(0,i.jsx)(n.p,{children:"Interface-1:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WriteToScratch( obj, x )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( Int8/Int16/Int32/Int64/Real32/Real64 ), INTENT( IN ) :: x (rank-1/2/3/4)\nEND SUBROUTINE WriteToScratch\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE VTKFile_WriteToScratch5( obj, x, y, z )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( Int8/Int16/Int32/Int64/Real32/Real64 ), INTENT( IN ) :: x( rank-1/2/3 )\n  TYPE( Int8/Int16/Int32/Int64/Real32/Real64 ), INTENT( IN ) :: y( rank-1/2/3 )\n  TYPE( Int8/Int16/Int32/Int64/Real32/Real64 ), INTENT( IN ) :: z( rank-1/2/3 )\nEND SUBROUTINE VTKFile_WriteToScratch5\n"})}),"\n",(0,i.jsx)(n.h2,{id:"fielddatamethods",children:"FieldDataMethods"}),"\n",(0,i.jsx)(n.h3,{id:"writefielddata",children:"WriteFieldData"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WriteFieldData( obj, name, x )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: name\n  CLASS( * ), INTENT( IN ) :: x\nEND SUBROUTINE WriteFieldData\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WriteFieldData( obj, action )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: action\n    !! Open, Close\nEND SUBROUTINE WriteFieldData\n"})}),"\n",(0,i.jsx)(n.h2,{id:"pointsmethods",children:"PointsMethods"}),"\n",(0,i.jsxs)(n.p,{children:["Also see [[#InitiateVTKFile]] routine to check Datastructure where Points element is needed. The Points element explicitly defines coordinates for each point individually. It contains one ",(0,i.jsx)(n.code,{children:"DataArray"})," element describing an array with three components per value, each specifying the coordinates of one point."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"<Points>\n  <DataArray NumberOfComponents=\u201d3\u201d .../>\n</Points>\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Coordinates"})," \u2014 The Coordinates element defines point coordinates for an extent by specifying the ordinate along each axis for each integer value in the extent\u2019s range. It contains three DataArray elements describing the ordinates along the x-y-z axes, respectively. It is needed by ",(0,i.jsx)(n.code,{children:"RectilinearGrid"})," Datastructure."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"<Coordinates>\n  <DataArray .../>\n  <DataArray .../>\n  <DataArray .../>\n</Coordinates>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"writepoints",children:"WritePoints"}),"\n",(0,i.jsx)(n.p,{children:"Interface-1:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WritePoints( obj, x, y, z )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  REAL( Real64/Real32 ), INTENT( IN ) :: x( : )\n  REAL( Real64/Real32 ), INTENT( IN ) :: y( : )\n  REAL( Real64/Real32 ), INTENT( IN ) :: z( : )\nEND SUBROUTINE WritePoints\n"})}),"\n",(0,i.jsx)(n.p,{children:"Interface-2:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WritePoints( obj, x )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  REAL( Real64/Real32 ), INTENT( IN ) :: x( 1: )\nEND SUBROUTINE WritePoints\n"})}),"\n",(0,i.jsx)(n.p,{children:"Interface-3: Some time we compute x, y, z from meshgrid. In such cases x, y and z will be rank-3. where x(I,J,K) denote the x coord of Ith node in x, Jth node in y, and Kth node in z direction. See example [[VTKFile_test_4]]"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WritePoints( obj, x, y, z )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  REAL( Real64/Real32 ), INTENT( IN ) :: x( :, :, : )\n  REAL( Real64/Real32 ), INTENT( IN ) :: y( :, :, : )\n  REAL( Real64/Real32 ), INTENT( IN ) :: z( :, :, : )\nEND SUBROUTINE WritePoints\n"})}),"\n",(0,i.jsx)(n.p,{children:"Interface-4:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WritePoints( obj, x )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  REAL( Real64/Real32 ), INTENT( IN ) :: x( :, :, :, : )\nEND SUBROUTINE WritePoints\n"})}),"\n",(0,i.jsx)(n.h2,{id:"piecemethods",children:"PieceMethods"}),"\n",(0,i.jsx)(n.p,{children:"See [[#InitiateVTKFile]] to see where PieceMethods are useful."}),"\n",(0,i.jsx)(n.p,{children:"Write Piece for [[#ImageData]], [[#RectilinearGrid]], [[#StructuredGrid]]"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WritePiece( obj, extent, srcFileName )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  INTEGER( I4B ), INTENT( IN ) :: extent( : )\n  CHARACTER( LEN = * ), OPTIONAL, INTENT( IN ) :: srcFileName\nEND SUBROUTINE WritePiece\n"})}),"\n",(0,i.jsx)(n.p,{children:"Write Piece element for [[#UnstructuredGrid]]"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WritePiece( obj, nPoints, nCells )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  INTEGER( I4B ), INTENT( IN ) :: nPoints\n  INTEGER( I4B ), INTENT( IN ) :: nCells\nEND SUBROUTINE WritePiece\n"})}),"\n",(0,i.jsx)(n.p,{children:"Write Piece element for [[#PolyData]]"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WritePiece( obj, nPoints, nVerts, nLines, &\n  & nStrips, nPolys )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\n  INTEGER( I4B ), INTENT( IN ) :: nPoints\n  INTEGER( I4B ), INTENT( IN ) :: nVerts\n  INTEGER( I4B ), INTENT( IN ) :: nLines\n  INTEGER( I4B ), INTENT( IN ) :: nStrips\n  INTEGER( I4B ), INTENT( IN ) :: nPolys\nEND SUBROUTINE WritePiece\n"})}),"\n",(0,i.jsx)(n.p,{children:"The following close the Piece element."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"MODULE SUBROUTINE WritePiece( obj )\n  CLASS( VTKFile_ ), INTENT( INOUT ) :: obj\nEND SUBROUTINE WritePiece\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},54213:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var a=t(36672);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);