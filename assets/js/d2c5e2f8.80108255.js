"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[60558],{34586:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"TriangleInterface/poly","title":"poly (PSLG)","description":"Triangle: poly files poly files","source":"@site/docs/docs-api/TriangleInterface/poly.md","sourceDirName":"TriangleInterface","slug":"/TriangleInterface/poly","permalink":"/docs-api/TriangleInterface/poly","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/TriangleInterface/poly.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"node file","permalink":"/docs-api/TriangleInterface/node"},"next":{"title":"Quality meshing: angle and size constraints","permalink":"/docs-api/TriangleInterface/quality"}}');var s=i(23420),a=i(54213);const l={},o="poly (PSLG)",r={},c=[{value:"Vertices",id:"vertices",level:2},{value:"Segments",id:"segments",level:2},{value:"Holes",id:"holes",level:2},{value:"Region",id:"region",level:2},{value:"Miscellaneous",id:"miscellaneous",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsxs)(n.h1,{id:"poly-pslg",children:[(0,s.jsx)(n.code,{children:"poly"})," (PSLG)"]})}),"\n",(0,s.jsxs)(n.p,{children:["Triangle: ",(0,s.jsx)(n.code,{children:"poly"})," files ",(0,s.jsx)(n.code,{children:"poly"})," files"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-txt",children:"- First line: <# of vertices> <dimension (must be 2)> <# of attributes> <# of boundary markers (0 or 1)>\n- Following lines: <vertex #> <x> <y> \\[attributes\\] \\[boundary marker\\]\n- One line: <# of segments> <# of boundary markers (0 or 1)>\n- Following lines: <segment #> <endpoint> <endpoint> \\[boundary marker\\]\n- One line: <# of holes>\n- Following lines: <hole #> <x> <y>\n- Optional line: <# of regional attributes and/or area constraints>\n- Optional following lines: <region #> <x> <y> <attribute> <maximum area>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"poly"})," file represents a PSLG, as well as some additional information."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"PSLG stands for Planar Straight Line Graph, a term familiar to computational geometers. By definition, a PSLG is just a list of vertices and segments."})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"poly"})," file can also contain information about holes and concavities, as well as regional attributes and constraints on the areas of triangles."]}),"\n",(0,s.jsx)(n.h2,{id:"vertices",children:"Vertices"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The first section lists all the vertices, and is identical to the format of ",(0,s.jsx)(n.code,{children:"node"})," files."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"# of vertices"})," may be set to zero to indicate that the vertices are listed in a separate ",(0,s.jsx)(n.code,{children:"node"})," file; ",(0,s.jsx)(n.code,{children:"poly"})," files produced by Triangle always have this format. A vertex set represented this way has the advantage that it may easily be triangulated with or without segments."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"segments",children:"Segments"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The second section lists the segments."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Segments are edges whose presence in the triangulation is enforced (although each segment may be subdivided into smaller edges)."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Each segment is specified by listing the indices of its two endpoints."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"This means that you must include its endpoints in the vertex list."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Each segment, like each vertex, may have a boundary marker."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"q"}),", ",(0,s.jsx)(n.code,{children:"a"}),", ",(0,s.jsx)(n.code,{children:"u"}),", and ",(0,s.jsx)(n.code,{children:"s"})," are NOT selected, Triangle will produce a constrained Delaunay triangulation (CDT), in which each segment appears as a single edge in the triangulation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"q"}),", ",(0,s.jsx)(n.code,{children:"a"}),", ",(0,s.jsx)(n.code,{children:"u"}),", or ",(0,s.jsx)(n.code,{children:"s"})," is SELECTED, Triangle will produce a conforming constrained Delaunay triangulation (CCDT), in which segments may be subdivided into smaller edges."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"D"})," is selected as well, Triangle will produce a conforming Delaunay triangulation, so every triangle is Delaunay, and not just constrained Delaunay."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"holes",children:"Holes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The third section lists holes (and concavities, if c is selected) in the triangulation."}),"\n",(0,s.jsx)(n.li,{children:"Holes are specified by identifying a point inside each hole."}),"\n",(0,s.jsx)(n.li,{children:"After the triangulation is formed, Triangle creates holes by eating triangles, spreading out from each hole point until its progress is blocked by PSLG segments; you must be careful to enclose each hole in segments, or your whole triangulation might be eaten away. If the two triangles abutting a segment are eaten, the segment itself is also eaten."}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"Do not place a hole directly on a segment; if you do, Triangle will choose one side of the segment arbitrarily."})}),"\n",(0,s.jsx)(n.h2,{id:"region",children:"Region"}),"\n",(0,s.jsx)(n.p,{children:"The optional fourth section lists regional attributes (to be assigned to all triangles in a region) and regional constraints on the maximum triangle area."}),"\n",(0,s.jsxs)(n.p,{children:["Triangle will read this section only if the ",(0,s.jsx)(n.code,{children:"A"})," switch is used or the ",(0,s.jsx)(n.code,{children:"a"})," switch is used without a number following it, and the ",(0,s.jsx)(n.code,{children:"r"})," switch is NOT used."]}),"\n",(0,s.jsx)(n.p,{children:"Regional attributes and area constraints are propagated in the same manner as holes; you specify a point for each attribute and/or constraint, and the attribute and/or constraint will affect the whole region (bounded by segments) containing the point."}),"\n",(0,s.jsxs)(n.p,{children:["If two values are written on a line after the x and y coordinates, the first such value is assumed to be a regional attribute (but will only be applied if the ",(0,s.jsx)(n.code,{children:"A"})," switch is selected), and the second value is assumed to be a regional area constraint (but will only be applied if the ",(0,s.jsx)(n.code,{children:"a"})," switch is selected). You may specify just one value after the coordinates, which can serve as both an attribute and an area constraint, depending on the choice of switches. If you are using the ",(0,s.jsx)(n.code,{children:"A"})," and ",(0,s.jsx)(n.code,{children:"a"})," switches simultaneously and wish to assign an attribute to some region without imposing an area constraint, use a negative maximum area."]}),"\n",(0,s.jsx)(n.h2,{id:"miscellaneous",children:"Miscellaneous"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Blank lines and comments prefixed by ",(0,s.jsx)(n.code,{children:"#"})," may be placed anywhere."]}),"\n",(0,s.jsx)(n.li,{children:"Vertices, segments, holes, and regions must be numbered consecutively, starting from one or zero. (The choice to begin the numbering from one or zero must be consistent across all objects.)"}),"\n",(0,s.jsxs)(n.li,{children:["When a triangulation is created from a ",(0,s.jsx)(n.code,{children:"poly"})," file, you must either enclose the entire region to be triangulated in PSLG segments, or use the c switch, which encloses the convex hull of the input vertex set."]}),"\n",(0,s.jsx)(n.li,{children:"If you do not use the c switch, Triangle will eat all triangles that are not enclosed by segments; if you are not careful, your whole triangulation may be eaten away. If you do use the c switch, you can still produce concavities by the appropriate placement of holes just within the convex hull."}),"\n",(0,s.jsx)(n.li,{children:"An ideal PSLG has no intersecting segments, nor any vertices that lie upon segments (except, of course, the endpoints of each segment.)"}),"\n",(0,s.jsxs)(n.li,{children:["You aren't required to make your ",(0,s.jsx)(n.code,{children:"poly"})," files ideal, but you should be aware of what can go wrong."]}),"\n",(0,s.jsx)(n.li,{children:"Segment intersections are relatively safe Triangle will calculate the intersection points for you and add them to the triangulation as long as your machine's floatingpoint precision doesn't become a problem. You are tempting the fates if you have three segments that cross at the same location, and expect Triangle to figure out where the intersection point is. Thanks to floatingpoint roundoff error, Triangle will probably decide that the three segments intersect at three different points, and you will find a minuscule triangle in your output unless Triangle tries to refine the tiny triangle, uses up the last bit of machine precision, and fails to terminate at all."}),"\n",(0,s.jsx)(n.li,{children:"You're better off putting the intersection point in the input files, and manually breaking up each segment into two."}),"\n",(0,s.jsx)(n.li,{children:"Similarly, if you place a vertex at the middle of a segment, and hope that Triangle will break up the segment at that vertex, you might get lucky. On the other hand, Triangle might decide that the vertex doesn't lie precisely on the line, and you'll have a needlesharp triangle in your output or a lot of tiny triangles if you're generating a quality mesh."}),"\n",(0,s.jsxs)(n.li,{children:["When Triangle reads a ",(0,s.jsx)(n.code,{children:"poly"})," file, it also writes a ",(0,s.jsx)(n.code,{children:"poly"})," file, which includes all edges that are subsegments of input segments."]}),"\n",(0,s.jsxs)(n.li,{children:["If the ",(0,s.jsx)(n.code,{children:"c"})," switch is used, the output ",(0,s.jsx)(n.code,{children:"poly"})," file will also include all of the edges on the convex hull."]}),"\n",(0,s.jsxs)(n.li,{children:["Hence, the output ",(0,s.jsx)(n.code,{children:"poly"})," file is useful for finding edges associated with input segments and setting boundary conditions in finite element simulations."]}),"\n",(0,s.jsx)(n.li,{children:"More importantly, you will need it if you plan to refine the output mesh, and don't want segments to be missing in later triangulations."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},54213:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var t=i(36672);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);