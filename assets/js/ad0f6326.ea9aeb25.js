"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[56923],{92414:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>E,frontMatter:()=>o,metadata:()=>l,toc:()=>r});const l=JSON.parse('{"id":"AbstractMesh/ElemData_","title":"ElemData","description":"It is a data type for storing the element-data information.","source":"@site/docs/docs-api/AbstractMesh/ElemData_.md","sourceDirName":"AbstractMesh","slug":"/AbstractMesh/ElemData_","permalink":"/docs-api/AbstractMesh/ElemData_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AbstractMesh/ElemData_.md","tags":[],"version":"current","lastUpdatedAt":1746862724000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Structure","permalink":"/docs-api/AbstractMesh/AbstractMesh_"},"next":{"title":"NodeData","permalink":"/docs-api/AbstractMesh/NodeData_"}}');var t=a(23420),d=a(54213);const o={sidebar_position:3},i="ElemData",s={},r=[{value:"Structure",id:"structure",level:2},{value:"<code>isActive</code>",id:"isactive",level:3},{value:"<code>globalElements</code>",id:"globalelements",level:3},{value:"<code>localElemNum</code>",id:"localelemnum",level:3},{value:"<code>elementType</code>",id:"elementtype",level:3},{value:"<code>name</code>",id:"name",level:3},{value:"<code>meshID</code>",id:"meshid",level:3},{value:"<code>material</code>",id:"material",level:3},{value:"<code>globalNodes</code>",id:"globalnodes",level:3},{value:"<code>globalEdges</code> and <code>edgeOrient</code>",id:"globaledges-and-edgeorient",level:3},{value:"<code>globalFaces</code> and <code>faceOrient</code>",id:"globalfaces-and-faceorient",level:3},{value:"<code>globalElements</code>",id:"globalelements-1",level:3},{value:"<code>boundaryData</code>",id:"boundarydata",level:3},{value:"ElemdataType",id:"elemdatatype",level:2},{value:"Elemdata_Copy",id:"elemdata_copy",level:2},{value:"Elemdata_Display",id:"elemdata_display",level:2},{value:"Elemdata_ElemType2String",id:"elemdata_elemtype2string",level:2},{value:"Elemdata_Deallocate",id:"elemdata_deallocate",level:2},{value:"Elemdata_SetTotalMaterial",id:"elemdata_settotalmaterial",level:2},{value:"Elemdata_Set",id:"elemdata_set",level:2},{value:"Elemdata_Pointer",id:"elemdata_pointer",level:2},{value:"Elemdata_lt",id:"elemdata_lt",level:2},{value:"Elemdata_eq",id:"elemdata_eq",level:2},{value:"Elemdata_SetID",id:"elemdata_setid",level:2},{value:"Elemdata_GetGlobalFaceCon",id:"elemdata_getglobalfacecon",level:2},{value:"Elemdata_GetConnectivity",id:"elemdata_getconnectivity",level:2},{value:"Elemdata_GetConnectivity2",id:"elemdata_getconnectivity2",level:2},{value:"Elemdata_GetTotalEntities",id:"elemdata_gettotalentities",level:2},{value:"Elemdata_GetVertex",id:"elemdata_getvertex",level:2},{value:"Elemdata_GetEdge",id:"elemdata_getedge",level:2},{value:"Elemdata_GetFace",id:"elemdata_getface",level:2},{value:"Elemdata_GetCell",id:"elemdata_getcell",level:2},{value:"Elemdata_GetTotalEdgeDOF",id:"elemdata_gettotaledgedof",level:2},{value:"Elemdata_GetTotalFaceDOF",id:"elemdata_gettotalfacedof",level:2},{value:"Elemdata_GetTotalCellDOF",id:"elemdata_gettotalcelldof",level:2},{value:"Elemdata_GetElementToElements1",id:"elemdata_getelementtoelements1",level:2},{value:"Elemdata_GetElementToElements2",id:"elemdata_getelementtoelements2",level:2},{value:"Elemdata_GetEdgeConnectivity",id:"elemdata_getedgeconnectivity",level:2},{value:"Elemdata_isActive",id:"elemdata_isactive",level:2},{value:"Elemdata_globalElemNum",id:"elemdata_globalelemnum",level:2},{value:"Elemdata_localElemNum",id:"elemdata_localelemnum",level:2},{value:"Elemdata_name",id:"elemdata_name",level:2},{value:"Elemdata_topoName",id:"elemdata_toponame",level:2},{value:"Elemdata_topoIndx",id:"elemdata_topoindx",level:2},{value:"Elemdata_meshid",id:"elemdata_meshid",level:2},{value:"Elemdata_GetTotalMaterial",id:"elemdata_gettotalmaterial",level:2},{value:"Elemdata_GetTotalGlobalNodes",id:"elemdata_gettotalglobalnodes",level:2},{value:"Elemdata_GetTotalGlobalEdges",id:"elemdata_gettotalglobaledges",level:2},{value:"Elemdata_GetTotalEdgeOrient",id:"elemdata_gettotaledgeorient",level:2},{value:"Elemdata_GetTotalGlobalFaces",id:"elemdata_gettotalglobalfaces",level:2},{value:"Elemdata_GetTotalFaceOrient",id:"elemdata_gettotalfaceorient",level:2},{value:"Elemdata_GetTotalGlobalElements",id:"elemdata_gettotalglobalelements",level:2},{value:"Elemdata_GetTotalBoundaryData",id:"elemdata_gettotalboundarydata",level:2},{value:"Elemdata_GetMaterial",id:"elemdata_getmaterial",level:2},{value:"Elemdata_GetGlobalNodes",id:"elemdata_getglobalnodes",level:2},{value:"Elemdata_GetGlobalEdges",id:"elemdata_getglobaledges",level:2},{value:"Elemdata_GetGlobalFaces",id:"elemdata_getglobalfaces",level:2},{value:"Elemdata_GetGlobalFaceNumber",id:"elemdata_getglobalfacenumber",level:2},{value:"Elemdata_GetGlobalEdgeNumber",id:"elemdata_getglobaledgenumber",level:2},{value:"Elemdata_GetGlobalElements",id:"elemdata_getglobalelements",level:2},{value:"Elemdata_GetBoundaryData",id:"elemdata_getboundarydata",level:2},{value:"Elemdata_GetGlobalNodesPointer",id:"elemdata_getglobalnodespointer",level:2},{value:"Elemdata_GetEdgeOrient",id:"elemdata_getedgeorient",level:2},{value:"Elemdata_GetFaceOrient",id:"elemdata_getfaceorient",level:2},{value:"Elemdata_GetOrientation",id:"elemdata_getorientation",level:2},{value:"Elemdata_FindFace",id:"elemdata_findface",level:2},{value:"Elemdata_FindEdge",id:"elemdata_findedge",level:2},{value:"Elemdata_IsBoundaryElement",id:"elemdata_isboundaryelement",level:2},{value:"Elemdata_Order",id:"elemdata_order",level:2}];function c(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,d.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"elemdata",children:"ElemData"})}),"\n",(0,t.jsx)(n.p,{children:"It is a data type for storing the element-data information."}),"\n",(0,t.jsx)(n.h2,{id:"structure",children:"Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"TYPE :: ElemData_\n  LOGICAL(LGT) :: isActive = .TRUE.\n    !! Is element in active stage\n  INTEGER(I4B) :: globalElemNum = 0_I4B\n    !! global element number\n    !! cell connectivity number\n  INTEGER(I4B) :: localElemNum = 0_I4B\n    !! local element number\n  INTEGER(I4B) :: elementType = INTERNAL_ELEMENT\n    !! BOUNDARY_ELEMENT: If the element contqains the boundary node\n    !! it will be called the boundary element\n    !! INTERNAL_ELEMENT: If the element does not contain the boundary node\n    !! then it will be called the internal element\n  INTEGER(I4B) :: name = 0\n    !! This is name of the element\n    !! It can be Triangle, Triangle3, Triangle6, etc.\n    !! Quadrangle,\n  INTEGER(I4B) :: meshID = 0\n    !! ID of mesh to which the element belong\n    !! This is a gmsh concept\n  INTEGER(INT8), ALLOCATABLE :: material(:)\n    !! materials mapped to the mesh\n    !! material(1) is the material-id (type of material) of medium 1\n    !! material(2) is the material-id (type of material) of medium 2\n    !!\n    !! ...\n    !!\n    !! For example, soil is a porous medium with n = 1,\n    !! fluid is a medium with n =2\n    !! then material(1) denotes the type of soil => clay, sand, silt\n    !! and material(2) denotes the type of fluid => water, oil, air\n  INTEGER(I4B), ALLOCATABLE :: globalNodes(:)\n    !! nodes contained in the element, connectivity\n    !! Vertex connectivity\n  INTEGER(I4B), ALLOCATABLE :: globalEdges(:)\n    !! Edge connectivity\n  INTEGER(INT8), ALLOCATABLE :: edgeOrient(:)\n    !! Orientation of edge\n  INTEGER(I4B), ALLOCATABLE :: globalFaces(:)\n    !! Face connectivity\n  INTEGER(INT8), ALLOCATABLE :: faceOrient(:, :)\n    !! Orientation of face\n  INTEGER(I4B), ALLOCATABLE :: globalElements(:)\n    !! Contains the information about the element surrounding an element\n    !! Lets us say that `globalElem1`, `globalElem2`, `globalElem3`\n    !! surrounds a local element ielem (its global element number is\n    !! globalElem), then\n    !! - globalElements( [1,2,3] ) contains globalElem1, pFace, nFace\n    !! - globalElements( [4,5,6] ) contains globalElem2, pFace, nFace\n    !! - globalElements( [7,8,9] ) contains globalElem3, pFace, nFace.\n    !! Here,\n    !! - pFace is the local facet number of parent element\n    !! globalElem (ielem) which is connected to the nFace of the neighbor\n    !! element\n    !! All element numbers are global element number\n  INTEGER(I4B), ALLOCATABLE :: boundaryData(:)\n    !! If `iel` is boundary element, then boudnaryData contains\n    !! the local facet number of iel which concides with the\n    !! mesh boundary.\n    !! If an element contains the boundary node then it is considered\n    !! as a boundary element.\n    !! It may happen that a boundary element has no boundary face, in which\n    !! case boundaryData will have zero size\nEND TYPE ElemData_\n"})}),"\n",(0,t.jsx)(n.h3,{id:"isactive",children:(0,t.jsx)(n.code,{children:"isActive"})}),"\n",(0,t.jsx)(n.p,{children:"If the element is active or not."}),"\n",(0,t.jsx)(n.h3,{id:"globalelements",children:(0,t.jsx)(n.code,{children:"globalElements"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"globalElemNum"})," global element number, this number is given by the mesh generator."]}),"\n",(0,t.jsx)(n.h3,{id:"localelemnum",children:(0,t.jsx)(n.code,{children:"localElemNum"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"localElemNum"})," local element number, This number is decided internally. It represents the internal storage address."]}),"\n",(0,t.jsx)(n.h3,{id:"elementtype",children:(0,t.jsx)(n.code,{children:"elementType"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"elementType"})," has following meaning as of 2024-04-14"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"BOUNDARY_ELEMENT"}),": If the element contains a facet which coincides with the boundary then, then it will be called the boundary element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"INTERNAL_ELEMENT"}),": Otherwise the element is classified as the internal element."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"name",children:(0,t.jsx)(n.code,{children:"name"})}),"\n",(0,t.jsx)(n.p,{children:"Name of the element. You can find more information about this on following pages:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs-api/GlobalData/",children:"GlobalData"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"../ReferenceElement",children:"ReferenceElement"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"meshid",children:(0,t.jsx)(n.code,{children:"meshID"})}),"\n",(0,t.jsx)(n.p,{children:"It represent the mesh region. This parameter can be used to assign material properties, boundary conditions, etc to a region of the mesh."}),"\n",(0,t.jsx)(n.h3,{id:"material",children:(0,t.jsx)(n.code,{children:"material"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"material"})," maps the material to the mesh, for example"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"material(1)"})," is the material-id of medium 1 (here 1 may denote soil)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"material(2)"})," is the material-id of medium 2 (here, 2 may denote water)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mo,{children:"\u22ef"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\cdots"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.313em"}}),(0,t.jsx)(n.span,{className:"minner",children:"\u22ef"})]})})]})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"material(n)"})," is the material-id of medium n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For example, soil is a porous medium with material id = 1, fluid is a medium with id=2. Then, material(1) denotes the type of soil, that is, clay, sand, and silt. Also, material(2) denotes the type of fluid, water, oil, air."}),"\n",(0,t.jsxs)(n.p,{children:["The size of ",(0,t.jsx)(n.code,{children:"material"})," denotes the total number of materials assigned to the element."]}),"\n",(0,t.jsx)(n.h3,{id:"globalnodes",children:(0,t.jsx)(n.code,{children:"globalNodes"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"globalNodes"})," nodes contained in the element, i.e., vertex connectivity."]}),"\n",(0,t.jsxs)(n.h3,{id:"globaledges-and-edgeorient",children:[(0,t.jsx)(n.code,{children:"globalEdges"})," and ",(0,t.jsx)(n.code,{children:"edgeOrient"})]}),"\n",(0,t.jsx)(n.p,{children:"edge connectivity and edge orientation."}),"\n",(0,t.jsxs)(n.h3,{id:"globalfaces-and-faceorient",children:[(0,t.jsx)(n.code,{children:"globalFaces"})," and ",(0,t.jsx)(n.code,{children:"faceOrient"})]}),"\n",(0,t.jsx)(n.p,{children:"face connectivity and face orientation."}),"\n",(0,t.jsx)(n.h3,{id:"globalelements-1",children:(0,t.jsx)(n.code,{children:"globalElements"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"globalElements"})," contains the information about the elements surrounding an element. This is explained below:"]}),"\n",(0,t.jsxs)(n.p,{children:["Let us say that ",(0,t.jsx)(n.code,{children:"globalElem1"}),", ",(0,t.jsx)(n.code,{children:"globalElem2"}),", and ",(0,t.jsx)(n.code,{children:"globalElem3"})," surround a local element ",(0,t.jsx)(n.code,{children:"ielem"})," (its global element number is ",(0,t.jsx)(n.code,{children:"globalElem"}),"), then"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"globalElements( [1,2,3] )"})," contains ",(0,t.jsx)(n.code,{children:"globalElem1"}),", ",(0,t.jsx)(n.code,{children:"pFace"}),", ",(0,t.jsx)(n.code,{children:"nFace"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"globalElements( [4,5,6] )"})," contains ",(0,t.jsx)(n.code,{children:"globalElem2"}),", ",(0,t.jsx)(n.code,{children:"pFace"}),", ",(0,t.jsx)(n.code,{children:"nFace"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"globalElements( [7,8,9] )"})," contains ",(0,t.jsx)(n.code,{children:"globalElem3"}),", ",(0,t.jsx)(n.code,{children:"pFace"}),", ",(0,t.jsx)(n.code,{children:"nFace"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"pFace"})," is the local facet number of parent element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nFace"})," is the local facet number of the neighbor"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Here, ",(0,t.jsx)(n.code,{children:"pFace"})," is the local facet number of parent element, (i.e., ",(0,t.jsx)(n.code,{children:"globalElem (ielem)"}),"). The ",(0,t.jsx)(n.code,{children:"nFace"})," (local-facet-number) of the neighboring element."]}),"\n",(0,t.jsx)(n.h3,{id:"boundarydata",children:(0,t.jsx)(n.code,{children:"boundaryData"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It represents the information about the boundary element. It should be used only when the element is a boundary element."}),"\n",(0,t.jsxs)(n.li,{children:["If an element ",(0,t.jsx)(n.code,{children:"iel"})," is a boundary element, then ",(0,t.jsx)(n.code,{children:"boundaryData"})," contains the local facet numbers of ",(0,t.jsx)(n.code,{children:"iel"})," which coincides with the mesh boundary. It may happen that a boundary element has no boundary face (but only a single boundary node), in this case ",(0,t.jsx)(n.code,{children:"boundaryData"})," will have zero size."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In addition we have defined ",(0,t.jsx)(n.code,{children:"ElemdataPointer_"})," which is a pointer to ",(0,t.jsx)(n.code,{children:"Elemdata_"})," type. The pointer is defined as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"TYPE ElemdataPointer_\n  CLASS(Elemdata_), POINTER :: ptr => NULL()\nEND TYPE ElemdataPointer_\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdatatype",children:"ElemdataType"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ElemdataType_"})," is a derived type which contains the information about the element data. The structure of the ",(0,t.jsx)(n.code,{children:"ElemdataType_"})," is as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"TYPE ElemdataType_\n  INTEGER(I4B) :: internal = INTERNAL_ELEMENT\n  INTEGER(I4B) :: boundary = BOUNDARY_ELEMENT\n  INTEGER(I4B) :: domainBoundary = DOMAIN_BOUNDARY_ELEMENT\n  INTEGER(I4B) :: ghost = GHOST_ELEMENT\nEND TYPE ElemdataType_\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ElemdataType_"})," is private but you can use its instance called ",(0,t.jsx)(n.code,{children:"TypeElem"}),". For example to get the field ",(0,t.jsx)(n.code,{children:"internal"})," you should use ",(0,t.jsx)(n.code,{children:"TypeElem%internal"}),"."]})}),"\n",(0,t.jsx)(n.p,{children:"This module exposes following methods."}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_copy",children:"Elemdata_Copy"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Copy obj2 to obj1"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_Copy(obj1, obj2)\n  TYPE(Elemdata_), INTENT(INOUT) :: obj1\n  TYPE(Elemdata_), INTENT(IN) :: obj2\nEND SUBROUTINE\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_display",children:"Elemdata_Display"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Display the element data information."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_Display(obj)\n  TYPE(Elemdata_), INTENT(IN) :: obj\nEND SUBROUTINE\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_elemtype2string",children:"Elemdata_ElemType2String"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Convert the element type to string."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_ElemType2String(elementType) RESULT(ans)\n  INTEGER(I4B), INTENT(IN) :: elementType\n  CHARACTER(:), ALLOCATABLE :: ans\nEND FUNCTION\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_deallocate",children:"Elemdata_Deallocate"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Deallocate the element data."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_Deallocate(obj)\n  TYPE(Elemdata_), INTENT(INOUT) :: obj\nEND SUBROUTINE\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_settotalmaterial",children:"Elemdata_SetTotalMaterial"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Set the total number of materials."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_SetTotalMaterial(obj, n)\n  TYPE(Elemdata_), INTENT(INOUT) :: obj\n  INTEGER(I4B), INTENT(IN) :: n\nEND SUBROUTINE\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_set",children:"Elemdata_Set"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Set the element data."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE SUBROUTINE Elemdata_Set(obj, globalElemNum, localElemNum, &\n        elementType, globalNodes, globalElements, boundaryData, globalEdges, &\n   globalFaces, name, topoName, isActive, meshID, medium, material, materials)\n  ! obj%elementData(ii)%globalElemNum = elemNumber(ii)\n  ! obj%elementData(ii)%localElemNum = ii\n  ! obj%elementData(ii)%globalNodes = connectivity(:, ii)\n  TYPE(Elemdata_), INTENT(INOUT) :: obj\n  !! element data object\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalElemNum\n  !! global element number\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: localElemNum\n  !! local element number\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: elementType\n  !! element type: internal element, boundary element, etc.\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalNodes(:)\n  !! vertex connectivity\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalElements(:)\n  !! element to element mapping\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: boundaryData(:)\n  !! boundary data\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalEdges(:)\n  !! edge connectivity\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalFaces(:)\n  !! gace connectivity\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: name\n  !! Type of element, triangle, triangle3, Quadrangle4, etc\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: topoName\n  !! topology  name of the element\n  LOGICAL(LGT), OPTIONAL, INTENT(IN) :: isActive\n  !! is element active\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: meshID\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: medium\n  !! medium id like soil,water, etc\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: material\n  !! material like soil1, soil2, wate1, water2, etc\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: materials(:)\n  !! materials\nEND SUBROUTINE\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_pointer",children:"Elemdata_Pointer"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create a pointer to the element data."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_Pointer() RESULT(ans)\n  CLASS(Elemdata_), POINTER :: ans\n  ALLOCATE (Elemdata_ :: ans)\nEND FUNCTION Elemdata_Pointer\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_lt",children:"Elemdata_lt"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Compare two element data objects. Less than operator."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_lt(obj, obj2) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  TYPE(Elemdata_), INTENT(IN) :: obj2\n  LOGICAL(LGT) :: ans\n  ans = obj%globalElemNum .GT. obj2%globalElemNum\nEND FUNCTION Elemdata_lt\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_eq",children:"Elemdata_eq"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Compare two element data objects. Equal operator."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_eq(obj, obj2) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  TYPE(Elemdata_), INTENT(IN) :: obj2\n  LOGICAL(LGT) :: ans\n  ans = obj%globalElemNum .EQ. obj2%globalElemNum\nEND FUNCTION Elemdata_eq\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_setid",children:"Elemdata_SetID"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Set the element ID."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_SetID(obj, id)\n  TYPE(Elemdata_), INTENT(INOUT) :: obj\n  INTEGER(I4B), INTENT(IN) :: id\nEND SUBROUTINE\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getglobalfacecon",children:"Elemdata_GetGlobalFaceCon"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Get the global face connectivity. Returns the vertex connectivity of global face of elements."}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_GetGlobalFaceCon(obj, globalFaceCon, localFaceCon)\n  TYPE(Elemdata_), INTENT(INOUT) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: globalFaceCon(:, :)\n  INTEGER(I4B), OPTIONAL, INTENT(INOUT) :: localFaceCon(:, :)\nEND SUBROUTINE\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getconnectivity",children:"Elemdata_GetConnectivity"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the connectivity of the element."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"tsize is the size of data written in con"}),"\n",(0,t.jsx)(n.li,{children:"con is the connectivity array, it should be allocated"}),"\n",(0,t.jsxs)(n.li,{children:["opt is the type of connectivity, following options are allowed","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'"V" or "v" : vertex connectivity'}),"\n",(0,t.jsx)(n.li,{children:'"E" or "e" : edge connectivity'}),"\n",(0,t.jsx)(n.li,{children:'"F" or "f" : face connectivity'}),"\n",(0,t.jsx)(n.li,{children:'"C" or "c" : cell connectivity'}),"\n",(0,t.jsx)(n.li,{children:'"A" or "a" : all connectivity'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_GetConnectivity(obj, con, tsize, opt)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: con(:)\n  INTEGER(I4B), INTENT(OUT) :: tsize\n  CHARACTER(*), INTENT(IN), OPTIONAL :: opt\nEND SUBROUTINE\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getconnectivity2",children:"Elemdata_GetConnectivity2"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the connectivity of the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_GetConnectivity2(obj, cellCon, faceCon, edgeCon, nodeCon, &\n                                     tCellCon, tFaceCon, tEdgeCon, tNodeCon)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: cellCon(:)\n  !! cell connectivity\n  INTEGER(I4B), INTENT(INOUT) :: faceCon(:)\n  !! face connectivity\n  INTEGER(I4B), INTENT(INOUT) :: edgeCon(:)\n  !! edge connectivity\n  INTEGER(I4B), INTENT(INOUT) :: nodeCon(:)\n  !! node connectivity\n  INTEGER(I4B), INTENT(OUT) :: tCellCon\n  !! total data written in cellCon\n  INTEGER(I4B), INTENT(OUT) :: tFaceCon\n  !! total data written in faceCon\n  INTEGER(I4B), INTENT(OUT) :: tEdgeCon\n  !! total data written in edgeCon\n  INTEGER(I4B), INTENT(OUT) :: tNodeCon\n  !! total data written in nodeCon\nEND SUBROUTINE\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotalentities",children:"Elemdata_GetTotalEntities"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the total number of vertex, edge, face and cell entities in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_GetTotalEntities(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B) :: ans(4)\n  ans(1) = SIZE(obj%globalNodes)\n  ans(2) = SIZE(obj%globalEdges)\n  ans(3) = SIZE(obj%globalFaces)\n  ans(4) = 1\nEND FUNCTION Elemdata_GetTotalEntities\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getvertex",children:"Elemdata_GetVertex"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the global vertex number of a given local vertex number."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_GetVertex(obj, ii) RESULT(ans)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(in) :: ii\n  !! local vertex number\n  INTEGER(I4B) :: ans\n  !! global vertex number\n  \n  ans = obj%globalNodes(ii)\nEND FUNCTION Elemdata_GetVertex\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getedge",children:"Elemdata_GetEdge"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the global edge number of a given local edge number."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_GetEdge(obj, ii) RESULT(ans)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(in) :: ii\n  !! local edge number\n  INTEGER(I4B) :: ans\n  !! global edge number\n  ans = obj%globalEdges(ii)\nEND FUNCTION Elemdata_GetEdge\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getface",children:"Elemdata_GetFace"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the global face number of a given local face number."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_GetFace(obj, ii) RESULT(ans)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(in) :: ii\n  !! local face number\n  INTEGER(I4B) :: ans\n  !! global face number\n  ans = obj%globalFaces(ii)\nEND FUNCTION Elemdata_GetFace\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getcell",children:"Elemdata_GetCell"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the global or local cell number of the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_GetCell(obj, islocal) RESULT(ans)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  LOGICAL(LGT), INTENT(in) :: islocal\n  !! If true then local cell number is returned\n  INTEGER(I4B) :: ans\n  !! global or local element number (cell number)\n\n  IF (islocal) THEN\n    ans = obj%localElemNum\n  ELSE\n    ans = obj%globalElemNum\n  END IF\nEND FUNCTION Elemdata_GetCell\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotaledgedof",children:"Elemdata_GetTotalEdgeDOF"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the total number of edge dof on the edge of an element. It does not return the edge dof on the boundary of the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_GetTotalEdgeDOF(obj, ii, order, baseContinuity, &\n                                  baseInterpolation) RESULT(ans)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  !! Element data object\n  INTEGER(I4B), INTENT(IN) :: ii\n  !! Local edge number\n  INTEGER(I4B), INTENT(IN) :: order\n  !! Order on the edge\n  CHARACTER(*), INTENT(IN) :: baseContinuity\n  !! base continuity: H1, HDiv, HCurl\n  CHARACTER(*), INTENT(IN) :: baseInterpolation\n  !! base interpolation type\n  INTEGER(I4B) :: ans\n  !! Total number of dof on edge\n  ans = MAX(order - 2, 0_I4B)\nEND FUNCTION Elemdata_GetTotalEdgeDOF\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotalfacedof",children:"Elemdata_GetTotalFaceDOF"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the total number of face dofs on the face of an element.\nAll dofs are internal to face, that is edge and vertex dof are not included."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_GetTotalFaceDOF(obj, ii, order, baseContinuity, &\n                                  baseInterpolation) RESULT(ans)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  !! Element data object\n  INTEGER(I4B), INTENT(IN) :: ii\n  !! Local face number\n  INTEGER(I4B), INTENT(IN) :: order\n  !! Order on the edge\n  CHARACTER(*), INTENT(IN) :: baseContinuity\n  !! base continuity: H1, HDiv, HCurl\n  CHARACTER(*), INTENT(IN) :: baseInterpolation\n  !! base interpolation type\n  INTEGER(I4B) :: ans\n  !! Total number of dof on edge\nEND FUNCTION Elemdata_GetTotalFaceDOF\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotalcelldof",children:"Elemdata_GetTotalCellDOF"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the total number of cell dofs on the cell of an element. All dofs are internal to cell, that is edge and vertex dof are not included."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_GetTotalCellDOF(obj, order, baseContinuity, &\n                                  baseInterpolation) RESULT(ans)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  !! Element data object\n  INTEGER(I4B), INTENT(IN) :: order\n  !! Order on the edge\n  CHARACTER(*), INTENT(IN) :: baseContinuity\n  !! base continuity: H1, HDiv, HCurl\n  CHARACTER(*), INTENT(IN) :: baseInterpolation\n  !! base interpolation type\n  INTEGER(I4B) :: ans\n  !! Total number of dof on edge\nEND FUNCTION Elemdata_GetTotalCellDOF\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getelementtoelements1",children:"Elemdata_GetElementToElements1"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the global element number of elements which surrounds the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_GetElementToElements1(obj, ans, tsize)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\n  !! Element to element, it should be allocated by user before calling\n  INTEGER(I4B), INTENT(OUT) :: tsize\n  !! The size of data written to ans\nEND SUBROUTINE Elemdata_GetElementToElements1\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getelementtoelements2",children:"Elemdata_GetElementToElements2"}),"\n",(0,t.jsx)(n.p,{children:"Get the element to element mapping including the local face number of the element and its neighbor."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_GetElementToElements2(obj, ans, nrow, ncol, &\n                                          includeBoundaryElement)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: ans(:, :)\n  !! Element to element, it should be allocated by user before calling\n  !! each row denotes the information of a neighbor element.\n  !! Therefore nrow is the total number of neighboring elements\n  !! number of columns is 3. \n  !! The first column is global element of the neighbor element\n  !! The second column is local face number of parent element (this element)\n  !! The third column is local face number of neighbor element\n  INTEGER(I4B), INTENT(OUT) :: nrow\n  !! Number of rows written to ans\n  INTEGER(I4B), INTENT(OUT) :: ncol\n  !! Number of columns written to ans\n  LOGICAL(LGT), OPTIONAL, INTENT(IN) :: includeBoundaryElement\n  !! If includeBoundaryElement is present and true, \n  !! then the boundary element data is included in ans\n  !! In this case the current element is considered as the boundary element\n  !! ans(nrow, 1) contains the global element number of the current element\n  !! ans(nrow, 2) contains the boundary data (local face number which coincides with\n  !! the mesh boundary)\n  !! ans(nrow, 3) is set to 0\nEND SUBROUTINE Elemdata_GetElementToElements2\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getedgeconnectivity",children:"Elemdata_GetEdgeConnectivity"}),"\n",(0,t.jsx)(n.p,{children:"Get the connectivity of the local edge."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_GetEdgeConnectivity(obj, ans, tsize, ii)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  !! Element data object\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\n  !! edge connectivity, node numbers are global\n  INTEGER(I4B), INTENT(OUT) :: tsize\n  !! total data written to ans\n  INTEGER(I4B), INTENT(IN) :: ii\n  !! Edge number (local)\nEND SUBROUTINE\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_isactive",children:"Elemdata_isActive"}),"\n",(0,t.jsx)(n.p,{children:"This function return true if the element is active, false otherwise."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_isActive(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  LOGICAL(LGT) :: ans\n  ans = obj%isActive\nEND FUNCTION Elemdata_isActive\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_globalelemnum",children:"Elemdata_globalElemNum"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the global element number of the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_globalElemNum(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = obj%globalElemNum\nEND FUNCTION Elemdata_globalElemNum\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_localelemnum",children:"Elemdata_localElemNum"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the local element number of the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_localElemNum(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = obj%localElemNum\nEND FUNCTION Elemdata_localElemNum\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_name",children:"Elemdata_name"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the name of the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_name(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = obj%name\nEND FUNCTION Elemdata_name\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_toponame",children:"Elemdata_topoName"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the topology name of the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_topoName(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = obj%topoName\nEND FUNCTION Elemdata_topoName\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_topoindx",children:"Elemdata_topoIndx"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the topology index of the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_topoIndx(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = GetElementIndex(obj%topoName)\nEND FUNCTION Elemdata_topoIndx\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_meshid",children:"Elemdata_meshid"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the mesh id of the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_meshid(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = obj%meshid\nEND FUNCTION Elemdata_meshid\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotalmaterial",children:"Elemdata_GetTotalMaterial"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the total number of materials in the element (that is material assigned the element)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_GetTotalMaterial(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = SIZE(obj%material)\nEND FUNCTION Elemdata_GetTotalMaterial\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotalglobalnodes",children:"Elemdata_GetTotalGlobalNodes"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the total number of global nodes in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_GetTotalGlobalNodes(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = SIZE(obj%globalNodes)\nEND FUNCTION Elemdata_GetTotalGlobalNodes\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotalglobaledges",children:"Elemdata_GetTotalGlobalEdges"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the total number of global edges in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_GetTotalGlobalEdges(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = SIZE(obj%globalEdges)\nEND FUNCTION Elemdata_GetTotalGlobalEdges\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotaledgeorient",children:"Elemdata_GetTotalEdgeOrient"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the size of edgeOrient array."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_GetTotalEdgeOrient(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = SIZE(obj%edgeOrient)\nEND FUNCTION Elemdata_GetTotalEdgeOrient\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotalglobalfaces",children:"Elemdata_GetTotalGlobalFaces"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the size of globalFaces array."}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotalfaceorient",children:"Elemdata_GetTotalFaceOrient"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the size of faceOrient array."}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotalglobalelements",children:"Elemdata_GetTotalGlobalElements"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the size of globalElements array."}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_gettotalboundarydata",children:"Elemdata_GetTotalBoundaryData"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the size of boundaryData array."}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getmaterial",children:"Elemdata_GetMaterial"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the materials assigned to the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE SUBROUTINE Elemdata_GetMaterial(obj, ans, tsize)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\n  INTEGER(I4B), INTENT(OUT) :: tsize\nEND SUBROUTINE Elemdata_GetMaterial\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getglobalnodes",children:"Elemdata_GetGlobalNodes"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the list of global nodes in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE SUBROUTINE Elemdata_GetGlobalNodes(obj, ans, tsize)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\n  INTEGER(I4B), INTENT(OUT) :: tsize\nEND SUBROUTINE Elemdata_GetGlobalNodes\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getglobaledges",children:"Elemdata_GetGlobalEdges"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the list of global edges in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE SUBROUTINE Elemdata_GetGlobalEdges(obj, ans, tsize)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\n  INTEGER(I4B), INTENT(OUT) :: tsize\nEND SUBROUTINE Elemdata_GetGlobalEdges\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getglobalfaces",children:"Elemdata_GetGlobalFaces"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the list of global faces in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE SUBROUTINE Elemdata_GetGlobalFaces(obj, ans, tsize)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\n  INTEGER(I4B), INTENT(OUT) :: tsize\nEND SUBROUTINE Elemdata_GetGlobalFaces\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getglobalfacenumber",children:"Elemdata_GetGlobalFaceNumber"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the global face number from a local face number."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_GetGlobalFaceNumber(obj, localFaceNumber) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B), INTENT(IN) :: localFaceNumber\n  !! local face number\n  INTEGER(I4B) :: ans\n  !! global face number\nEND FUNCTION Elemdata_GetGlobalFaceNumber\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getglobaledgenumber",children:"Elemdata_GetGlobalEdgeNumber"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the global edge number from a local edge number."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_GetGlobalEdgeNumber(obj, localEdgeNumber) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B), INTENT(IN) :: localEdgeNumber\n  !! local edge number\n  INTEGER(I4B) :: ans\n  !! global edge number\nEND FUNCTION Elemdata_GetGlobalEdgeNumber\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getglobalelements",children:"Elemdata_GetGlobalElements"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the list of globalElements in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE SUBROUTINE Elemdata_GetGlobalElements(obj, ans, tsize)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\n  INTEGER(I4B), INTENT(OUT) :: tsize\nEND SUBROUTINE Elemdata_GetGlobalElements\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["This routine returns all the entries of globalElements, so you should look at the meaning of globalElements in the ",(0,t.jsx)(n.a,{href:"#structure",children:"Structure"})," section."]})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getboundarydata",children:"Elemdata_GetBoundaryData"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the list of boundaryData in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE SUBROUTINE Elemdata_GetBoundaryData(obj, ans, tsize)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\n  !! boundary data, see the boundaryData in the type definition\n  INTEGER(I4B), INTENT(OUT) :: tsize\nEND SUBROUTINE Elemdata_GetBoundaryData\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getglobalnodespointer",children:"Elemdata_GetGlobalNodesPointer"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the pointer to the globalNodes in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_GetGlobalNodesPointer(obj) RESULT(ans)\n  TYPE(Elemdata_), TARGET, INTENT(IN) :: obj\n  INTEGER(I4B), POINTER :: ans(:)\n  ans => obj%globalNodes\nEND FUNCTION Elemdata_GetGlobalNodesPointer\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getedgeorient",children:"Elemdata_GetEdgeOrient"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the list of edgeOrient vector in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE SUBROUTINE Elemdata_GetEdgeOrient(obj, ans, tsize)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\n  INTEGER(I4B), INTENT(OUT) :: tsize\nEND SUBROUTINE Elemdata_GetEdgeOrient\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getfaceorient",children:"Elemdata_GetFaceOrient"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the list of faceOrient vector in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE SUBROUTINE Elemdata_GetFaceOrient(obj, ans, nrow, ncol)\n  TYPE(Elemdata_), INTENT(in) :: obj\n  INTEGER(I4B), INTENT(INOUT) :: ans(:, :)\n  INTEGER(I4B), INTENT(OUT) :: nrow, ncol\nEND SUBROUTINE Elemdata_GetFaceOrient\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_getorientation",children:"Elemdata_GetOrientation"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine returns the orientation related vectors in the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE SUBROUTINE Elemdata_GetOrientation(obj, cellOrient, faceOrient, &\n                            edgeOrient, tCellOrient, tFaceOrient, tEdgeOrient)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  !! element dataa\n  INTEGER(I4B), INTENT(INOUT) :: cellOrient(:)\n  !! cell connectivity of element\n  INTEGER(I4B), INTENT(INOUT) :: faceOrient(:, :)\n  !! face connectivity of element\n  INTEGER(I4B), INTENT(INOUT) :: edgeOrient(:)\n  !! edge connectivity of element\n  INTEGER(I4B), INTENT(OUT) :: tCellOrient\n  !! size of data written in cellCon\n  INTEGER(I4B), INTENT(OUT) :: tFaceOrient(2)\n  !! size of data written in faceCon\n  INTEGER(I4B), INTENT(OUT) :: tEdgeOrient\n  !! size of data written in edgecon\nEND SUBROUTINE Elemdata_GetOrientation\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_findface",children:"Elemdata_FindFace"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine finds the local face number of the element which contains the given face. The given face is described by its connectivity of the vertices."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_FindFace(obj, faceCon, isFace, &\n                             localFaceNumber, onlyBoundaryElement)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n    !! abstract mesh\n  INTEGER(I4B), INTENT(IN) :: faceCon(:)\n    !! vertex connectivity of face\n  LOGICAL(LGT), INTENT(OUT) :: isFace\n    !! if faceCon is a face of globalElement then it is true, else false\n  INTEGER(I4B), INTENT(OUT) :: localFaceNumber\n    !! local face number if found, else 0\n  LOGICAL(LGT), INTENT(IN) :: onlyBoundaryElement\n    !! if true then we will search if the element is boundary element\nEND SUBROUTINE Elemdata_FindFace\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_findedge",children:"Elemdata_FindEdge"}),"\n",(0,t.jsx)(n.p,{children:"This subroutine finds the local edge number of the element which contains the given edge. The given edge is described by its connectivity of the vertices."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"SUBROUTINE Elemdata_FindEdge(obj, edgeCon, isEdge, localEdgeNumber, &\n                             onlyBoundaryElement)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  !! abstract mesh\n  INTEGER(I4B), INTENT(IN) :: edgeCon(:)\n  !! vertex connectivity of Edge\n  LOGICAL(LGT), INTENT(OUT) :: isEdge\n  !! if EdgeCon is a Edge of globalElement then it is true, else false\n  INTEGER(I4B), INTENT(OUT) :: localEdgeNumber\n  !! local Edge number if found, else 0\n  LOGICAL(LGT), INTENT(IN) :: onlyBoundaryElement\n  !! if true then we will search if the element is boundary element\nEND SUBROUTINE Elemdata_FindEdge\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_isboundaryelement",children:"Elemdata_IsBoundaryElement"}),"\n",(0,t.jsx)(n.p,{children:"This function returns true if the element is a boundary element, false otherwise."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"FUNCTION Elemdata_IsBoundaryElement(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  LOGICAL(LGT) :: ans\n  ans = (obj%elementType .EQ. TypeElem%boundary) .OR. &\n        (obj%elementType .EQ. TypeElem%domainBoundary)\nEND FUNCTION Elemdata_IsBoundaryElement\n"})}),"\n",(0,t.jsx)(n.h2,{id:"elemdata_order",children:"Elemdata_Order"}),"\n",(0,t.jsx)(n.p,{children:"This function returns the order of the element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PURE FUNCTION Elemdata_Order(obj) RESULT(ans)\n  TYPE(Elemdata_), INTENT(IN) :: obj\n  INTEGER(I4B) :: ans\n  ans = ElementOrder(obj%name)\nEND FUNCTION Elemdata_Order\n"})})]})}function E(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},54213:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>i});var l=a(36672);const t={},d=l.createContext(t);function o(e){const n=l.useContext(d);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),l.createElement(d.Provider,{value:n},e.children)}}}]);