"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[71244],{9764:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"AbstractDomain/AbstractDomain_","title":"Structure","description":"The structure of AbstractDomain is given below.","source":"@site/docs/docs-api/AbstractDomain/AbstractDomain_.md","sourceDirName":"AbstractDomain","slug":"/AbstractDomain/AbstractDomain_","permalink":"/docs-api/AbstractDomain/AbstractDomain_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AbstractDomain/AbstractDomain_.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"AbstractDomain","permalink":"/docs-api/AbstractDomain/"},"next":{"title":"AbstractFE","permalink":"/docs-api/AbstractFE/"}}');var i=t(23420),o=t(54213);const r={sidebar_position:2},a="Structure",m={},l=[{value:"What is the difference between domain and mesh",id:"what-is-the-difference-between-domain-and-mesh",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"structure",children:"Structure"})}),"\n",(0,i.jsxs)(n.p,{children:["The structure of ",(0,i.jsx)(n.code,{children:"AbstractDomain"})," is given below."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"TYPE, ABSTRACT :: AbstractDomain_\n  PRIVATE\n  LOGICAL(LGT) :: isInitiated = .FALSE.\n    !! flag\n  TYPE(String) :: engine\n    !! Engine used for generating the meshes\n  INTEGER(I4B) :: majorVersion = 0\n    !! Major version\n  INTEGER(I4B) :: minorVersion = 0\n    !! Minor version\n  REAL(DFP) :: version = 0.0_DFP\n    !! Version  MajorVersion.MinorVersion\n  INTEGER(I4B) :: nsd = 0_I4B\n    !! number of spatial dimension\n  INTEGER(I4B) :: maxNptrs = 0\n    !! Largest node number in the domain\n  INTEGER(I4B) :: minNptrs = 0\n    !! Smallest node number in the domain\n  INTEGER(I4B) :: tNodes = 0\n    !! Total number of nodes in the mesh\n  LOGICAL(I4B) :: isNodeNumberSparse = .FALSE.\n    !! True if node numbers are not continuous\n  INTEGER(I4B) :: maxElemNum = 0\n    !! Largest element number in the domain\n  INTEGER(I4B) :: minElemNum = 0\n    !! Smallest element number in the domain\n  LOGICAL(LGT) :: isElemNumberSparse = .FALSE.\n    !! True if element numbers are sparse\n  INTEGER(I4B) :: tEntitiesForNodes = 0\n    !! Total number of entities required for reading nodes\n  INTEGER(I4B) :: tEntitiesForElements = 0\n    !! Total number of entities required for reading elements\n  INTEGER(I4B) :: tElements(0:3) = [0, 0, 0, 0]\n    !! Total number of elements inside the domain\n    !! tElements( 0 ) = total number of point elements\n    !! tElements( 1 ) = total number of line elements\n    !! tElements( 2 ) =  total number of surface elements\n    !! tElements( 3 ) = total number of volume/cell elements\n  INTEGER(I4B) :: tEntities(0:3) = [0, 0, 0, 0]\n    !! Total number of entities inside the domain\n    !! tEntities( 0 ) = total number of point mesh entities, mesh of Points\n    !! tEntities( 1 ) = total number of line mesh entities, mesh of Edge\n    !! tEntities( 2 ) = total number of surface mesh entities, mesh Boundary\n    !! tEntities( 3 ) = total number of volume mesh entities, Omega\n  REAL(DFP), ALLOCATABLE :: nodeCoord(:, :)\n    !! Nodal coordinates in XiJ format\n    !! Number of rows are 3, and number of columns is total nodes\n\n  CLASS(AbstractMesh_), POINTER :: meshVolume => NULL()\n    !! meshVolume list of meshes of volume entities\n  CLASS(AbstractMesh_), POINTER :: meshSurface => NULL()\n    !! meshSurface list of meshes of surface entities\n  CLASS(AbstractMesh_), POINTER :: meshCurve => NULL()\n    !! meshCurve list of meshes of curve entities\n  CLASS(AbstractMesh_), POINTER :: meshPoint => NULL()\n    !! meshPoint list of meshes of point entities\n\n  TYPE(CSRSparsity_) :: meshMap\n  !! Sparse mesh data in CSR format\n\nEND TYPE AbstractDomain_\n"})}),"\n",(0,i.jsx)(n.h2,{id:"what-is-the-difference-between-domain-and-mesh",children:"What is the difference between domain and mesh"}),"\n",(0,i.jsx)(n.p,{children:"A mesh is a collection of same topological order, that is,"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"a mesh of volume elements"}),"\n",(0,i.jsx)(n.li,{children:"a mesh of surface elements"}),"\n",(0,i.jsx)(n.li,{children:"a mesh of curve elements"}),"\n",(0,i.jsx)(n.li,{children:"a mesh of point elements"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The element number and the node number in the mesh can be sparse. Therefore, we need to create a mapping from local numbering to global numbering. The mesh data does not contain any node coordinate information. The node coordinate data is available in ",(0,i.jsx)(n.code,{children:"Domain"}),". It is stored inside ",(0,i.jsx)(n.code,{children:"nodeCoord"})," array in ",(0,i.jsx)(n.code,{children:"xij"})," format. We need global node number to access the entries in nodeCoord. These global node numbers are stored inside the mesh."]})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},54213:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(36672);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);