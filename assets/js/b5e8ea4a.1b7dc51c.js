"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[73668],{68527:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"AbstractSteadyStokes/AbstractSteadyStokes_","title":"Structure","description":"The structure of AbstractSteadyStokes_ is given below.","source":"@site/docs/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_.md","sourceDirName":"AbstractSteadyStokes","slug":"/AbstractSteadyStokes/AbstractSteadyStokes_","permalink":"/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"AbstractSteadyStokes","permalink":"/docs-api/AbstractSteadyStokes/"},"next":{"title":"AppendUtility","permalink":"/docs-api/AppendUtility/"}}');var i=r(23420),t=r(54213);const a={},l="Structure",o={},d=[{value:"ConstructorMethods",id:"constructormethods",level:2},{value:"setAbstractSteadyStokesParam",id:"setabstractsteadystokesparam",level:3},{value:"AddSurrogate",id:"addsurrogate",level:3},{value:"Deallocate",id:"deallocate",level:3},{value:"CheckEssentialParam",id:"checkessentialparam",level:3},{value:"Initiate",id:"initiate",level:3},{value:"IOMethods",id:"iomethods",level:2},{value:"Import",id:"import",level:3},{value:"Export",id:"export",level:3},{value:"Display",id:"display",level:3},{value:"WriteData_hdf5",id:"writedata_hdf5",level:3},{value:"WriteData_vtk",id:"writedata_vtk",level:3},{value:"MaterialMethods",id:"materialmethods",level:2},{value:"AddFluidMaterial",id:"addfluidmaterial",level:3},{value:"BCMethods",id:"bcmethods",level:2},{value:"AddPressureDirichletBC",id:"addpressuredirichletbc",level:3},{value:"AddVelocityDirichletBC",id:"addvelocitydirichletbc",level:3},{value:"AddPressureNeumannBC",id:"addpressureneumannbc",level:3},{value:"AddVelocityNeumannBC",id:"addvelocityneumannbc",level:3},{value:"SetMethods",id:"setmethods",level:2},{value:"Set",id:"set",level:3},{value:"GetMethods",id:"getmethods",level:2},{value:"GetPressureDirichletBCPointer",id:"getpressuredirichletbcpointer",level:3},{value:"GetVelocityDirichletBCPointer",id:"getvelocitydirichletbcpointer",level:3},{value:"GetPressureNeumannBCPointer",id:"getpressureneumannbcpointer",level:3},{value:"GetVelocityNeumannBCPointer",id:"getvelocityneumannbcpointer",level:3},{value:"ConvergenceMethods",id:"convergencemethods",level:2},{value:"IsSteadyState",id:"issteadystate",level:3},{value:"IsConverged",id:"isconverged",level:3},{value:"InitiateFieldMethods",id:"initiatefieldmethods",level:2},{value:"InitiateFields",id:"initiatefields",level:3},{value:"ApplyDirichletBCMethods",id:"applydirichletbcmethods",level:2},{value:"ApplyDirichletBC",id:"applydirichletbc",level:3},{value:"SolveMethods",id:"solvemethods",level:2},{value:"Solve",id:"solve",level:3},{value:"UpdateMethods",id:"updatemethods",level:2},{value:"Update",id:"update",level:3},{value:"AssembleTanmatMethods",id:"assembletanmatmethods",level:2},{value:"AssembleTanmat",id:"assembletanmat",level:3},{value:"AssembleTanmat_InternalFacet",id:"assembletanmat_internalfacet",level:3},{value:"AssembleTanMat_NeumanFacet",id:"assembletanmat_neumanfacet",level:3},{value:"AssembleMethods",id:"assemblemethods",level:2},{value:"Assemble",id:"assemble",level:3},{value:"AssembleRHSMethods",id:"assemblerhsmethods",level:2},{value:"AssembleRHS",id:"assemblerhs",level:3},{value:"RunMethods",id:"runmethods",level:2},{value:"Run",id:"run",level:3}];function c(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",math:"math",mi:"mi",mrow:"mrow",msub:"msub",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"structure",children:"Structure"})}),"\n",(0,i.jsxs)(n.p,{children:["The structure of ",(0,i.jsx)(n.code,{children:"AbstractSteadyStokes_"})," is given below."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"TYPE, ABSTRACT, EXTENDS(AbstractKernel_) :: AbstractSteadyStokes_\n  LOGICAL(LGT) :: isConservativeForm = .TRUE.\n  LOGICAL(LGT) :: isCommonDomain = .TRUE.\n  LOGICAL(LGT) :: isSubscalePressure = .TRUE.\n  LOGICAL(LGT) :: isBoundarySubscale = .FALSE.\n  INTEGER(I4B) :: stabParamOption = 1\n  REAL(DFP) :: rtoleranceForPressure = 1.0D-6\n  REAL(DFP) :: rtoleranceForVelocity = 1.0D-6\n  REAL(DFP) :: atoleranceForPressure = 1.0D-6\n  REAL(DFP) :: atoleranceForVelocity = 1.0D-6\n  REAL(DFP) :: toleranceForSteadyState = 1.0E-8\n  REAL(DFP) :: pressureError0 = 0.0_DFP\n  REAL(DFP) :: velocityError0 = 0.0_DFP\n  REAL(DFP) :: pressureError = 0.0_DFP\n  REAL(DFP) :: velocityError = 0.0_DFP\n  LOGICAL(LGT) :: ismaterialInterfaces = .FALSE.\n  INTEGER(I4B) :: refPressureNode = 0\n  REAL(DFP) :: refPressure = 0.0_DFP\n  INTEGER(I4B), ALLOCATABLE :: materialInterfaces(:)\n  TYPE(DomainConnectivity_), ALLOCATABLE :: matIfaceConnectData(:)\n  TYPE(String) :: domainFileForPressure\n  TYPE(String) :: domainFileForVelocity\n  INTEGER(I4B) :: tFluidMaterials = 0\n  TYPE(FluidMaterialPointer_), ALLOCATABLE :: fluidMaterial(:)\n  TYPE(MeshSelection_), ALLOCATABLE :: FluidMaterialToMesh(:)\n  TYPE(String) :: baseContinuityForPressure\n  TYPE(String) :: baseInterpolationForPressure\n  TYPE(String) :: quadratureTypeForPressure\n  TYPE(String) :: baseContinuityForVelocity\n  TYPE(String) :: baseInterpolationForVelocity\n  TYPE(String) :: quadratureTypeForVelocity\n  TYPE(DirichletBCPointer_), ALLOCATABLE :: DBCForPressure(:)\n  TYPE(DirichletBCPointer_), ALLOCATABLE :: DBCForVelocity(:)\n  TYPE(NeumannBCPointer_), ALLOCATABLE :: NBCForPressure(:)\n  TYPE(NeumannBCPointer_), ALLOCATABLE :: NBCForVelocity(:)\n  CLASS(Domain_), POINTER :: domForPressure => NULL()\n  CLASS(Domain_), POINTER :: domForVelocity => NULL()\n  CLASS(DomainConnectivity_), POINTER :: domConnect => NULL()\n  TYPE(ScalarMeshField_), ALLOCATABLE :: tausups_cell(:)\n  TYPE(ScalarMeshField_), ALLOCATABLE :: nulsic_cell(:)\n  TYPE(ScalarMeshField_), ALLOCATABLE :: hv_cell(:)\n  TYPE(ScalarMeshField_), ALLOCATABLE :: hp_cell(:)\n  TYPE(ScalarMeshField_), ALLOCATABLE :: hmax_cell(:)\n  TYPE(ScalarMeshField_), ALLOCATABLE :: hmin_cell(:)\n  TYPE(ScalarMeshField_), ALLOCATABLE :: dynamicViscosity(:)\n  TYPE(ScalarMeshField_), ALLOCATABLE :: massDensity(:)\n  CLASS(BlockNodeField_), POINTER :: rhs => NULL()\n  CLASS(BlockNodeField_), POINTER :: sol => NULL()\n  CLASS(VectorField_), POINTER :: nodeCoord => NULL()\n  CLASS(VectorField_), POINTER :: nodeCoordForPressure => NULL()\n  CLASS(VectorField_), POINTER :: nodeCoordForVelocity => NULL()\n  CLASS(ScalarField_), POINTER :: pressure => NULL()\n  CLASS(ScalarField_), POINTER :: pressure0 => NULL()\n  CLASS(VectorField_), POINTER :: velocity => NULL()\n  CLASS(VectorField_), POINTER :: velocity0 => NULL()\n  PROCEDURE(ComputeStabParam), POINTER, PASS(obj) :: &\n    & ComputeStabParam => NULL()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Description of these variables is given below."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isConservativeForm"})," True if we are using conservative form"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isCommonDomain"})," True if the domain is common for pressure and velocity, which means equal order interpolation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isSubscalePressure"}),", Only required when Variational Multiscale Methods are used for Equal order interpolations. If, True then we use subscale for pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isBoundarySubscale"}),", Only needed when VMS is used for stabilized FEM. If true then we use subscale at the interelement boundary"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stabParamOption"}),", Only needed when equal order interpolation is used. This option is for definition of stabilization parameter (",(0,i.jsx)(n.code,{children:"tau_supg"}),", ",(0,i.jsx)(n.code,{children:"nuLSIC"}),", etc.)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rtoleranceForPressure"})," relative tolerance for convergence in pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rtoleranceForVelocity"})," relative tolerance for convergence in velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"atoleranceForPressure"})," absolute tolerance for pressure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"atoleranceForVelocity"})," absolute tolerance for velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"toleranceForSteadyState"})," tolerance for checking steady state"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pressureError0"})," initial error for checking convergence in pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"velocityError0"})," initial error for checking convergence in velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pressureError"})," current error for checking convergence in pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"velocityError"})," current error for checking convergence in velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ismaterialInterfaces"})," True if materialInterfaces are allocated. We can have multiple fluids"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"refPressureNode"})," reference pressure node"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"refPressure"})," reference pressure at reference pressure node"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"materialInterfaces"})," Mesh ID of material interfaces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"matIfaceConnectData"})," Facet to cell data for each materialInterface mesh. The size of matIfaceConnectData is same as the size of materialInterfaces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"domainFileForPressure"})," domain file name for pressure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"domainFileForVelocity"})," domain file name for velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tFluidMaterials"})," Total number of fluid materials"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fluidMaterial"})," Pointer to the fluid materials"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"FluidMaterialToMesh"})," Map porous media to the mesh subregion. The size of FluidMaterialToMesh is equal to tFluidMaterials"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseContinuityForPressure"})," Continuity of basis function for pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseInterpolationForPressure"})," Interpolation of shape function for pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"quadratureTypeForPressure"})," Quadrature type for pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseContinuityForVelocity"})," Continuity of basis function for velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseInterpolationForVelocity"})," Interpolation of shape function for velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"quadratureTypeForVelocity"})," Quadrature type for velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DBCForPressure"})," Dirichlet boundary condition for pressure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DBCForVelocity"})," Dirichlet boundary condition for velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"NBCForPressure"})," Neumann boundary condition for pressure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"NBCForVelocity"})," Dirichlet boundary condition for velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"domForPressure"})," Domain for pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"domForVelocity"})," Domain for velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"domConnect"})," Domain connectivity, it contains cell to cell and node to node mapping between two domains."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tausups_cell"})," stabilization parameter for cell"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nulsic_cell"})," ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsxs)(n.msub,{children:[(0,i.jsx)(n.mi,{children:"\u03bd"}),(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"L"}),(0,i.jsx)(n.mi,{children:"S"}),(0,i.jsx)(n.mi,{children:"I"}),(0,i.jsx)(n.mi,{children:"C"})]})]})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\nu_{LSIC}"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.5806em",verticalAlign:"-0.15em"}}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.06366em"},children:"\u03bd"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.3283em"},children:(0,i.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.0637em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsxs)(n.span,{className:"mord mtight",children:[(0,i.jsx)(n.span,{className:"mord mathnormal mtight",children:"L"}),(0,i.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.05764em"},children:"S"}),(0,i.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.07847em"},children:"I"}),(0,i.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.07153em"},children:"C"})]})})]})}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(n.span,{})})})]})})]})]})})]})," stabilization parameter for cell"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"hv_cell"})," element size, hRGN for velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"hp_cell"})," hRPGN for cell"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"hmax_cell"})," hmax for cell"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"hmin_cell"})," hmin for cell"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dynamicViscosity"})," Dynamic viscosity (mu) of fluids"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"massDensity"})," mass density"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rhs"})," Block vector field for containing generalized force terms of mass and linear momentum conservation equations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"sol"})," Block vector field for space-time vectors and multi-physics apps"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nodeCoord"})," Vector field for nodal coordinates for pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nodeCoordForPressure"})," Vector field for nodal coordinates for pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nodeCoordForVelocity"})," Vector field for nodal cozordinates for velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pressure"})," Nodal values of current pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"pressure0"})," Converged nodal values of pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"velocity"})," Nodal values of current pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"velocity0"})," Converged nodal values of velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ComputeStabParam"})," This procedure pointer computes the stabilization parameter. Depending upon the value of stabParamOption the target of the pointer is decided. The interface is given below."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"ABSTRACT INTERFACE\n  SUBROUTINE ComputeStabParam(obj)\n    IMPORT :: AbstractSteadyStokes_\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE ComputeStabParam\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"constructormethods",children:"ConstructorMethods"}),"\n",(0,i.jsx)(n.h3,{id:"setabstractsteadystokesparam",children:"setAbstractSteadyStokesParam"}),"\n",(0,i.jsx)(n.p,{children:"This subroutine sets the essential parameter in the kernel"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE setAbstractSteadyStokesParam( &\n    & param, &\n    & prefix, &\n    & name, &\n    & isCommonDomain, &\n    & isConservativeForm, &\n    & gravity, &\n    & isSubscalePressure, &\n    & isBoundarySubscale, &\n    & stabParamOption, &\n    & domainFile, &\n    & domainFileForPressure, &\n    & domainFileForVelocity, &\n    & materialInterfaces, &\n    & engine, &\n    & coordinateSystem, &\n    & nnt, &\n    & dt, &\n    & startTime, &\n    & endTime, &\n    & maxIter, &\n    & rtoleranceForPressure, &\n    & rtoleranceForVelocity, &\n    & atoleranceForPressure, &\n    & atoleranceForVelocity, &\n    & toleranceForSteadyState, &\n    & tFluidMaterials, &\n    & tDirichletBCForPressure, &\n    & tDirichletBCForVelocity, &\n    & tNeumannBCForPressure, &\n    & tNeumannBCForVelocity, &\n    & baseInterpolationForSpace, &\n    & baseContinuityForSpace, &\n    & quadratureTypeForSpace, &\n    & baseInterpolationForPressure, &\n    & baseContinuityForPressure, &\n    & quadratureTypeForPressure, &\n    & baseInterpolationForVelocity, &\n    & baseContinuityForVelocity, &\n    & quadratureTypeForVelocity, &\n    & baseContinuityForTime,&\n    & baseInterpolationForTime, &\n    & quadratureTypeForTime, &\n    & postProcessOpt, &\n    & refPressureNode, &\n    & refPressure)\n    !!\n    TYPE(ParameterList_), INTENT(INOUT) :: param\n    CHARACTER(LEN=*), INTENT(IN) :: prefix\n    CHARACTER(LEN=*), INTENT(IN) :: name\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: isCommonDomain\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: isConservativeForm\n    REAL(DFP), OPTIONAL, INTENT(IN) :: gravity(3)\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: isSubscalePressure\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: isBoundarySubscale\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: stabParamOption\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: domainFile\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: domainFileForPressure\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: domainFileForVelocity\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: materialInterfaces(:)\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: engine\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: coordinateSystem\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: nnt\n    REAL(DFP), OPTIONAL, INTENT(IN) :: dt\n    REAL(DFP), OPTIONAL, INTENT(IN) :: startTime\n    REAL(DFP), OPTIONAL, INTENT(IN) :: endTime\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: maxIter\n    REAL(DFP), OPTIONAL, INTENT(IN) :: rtoleranceForPressure\n    REAL(DFP), OPTIONAL, INTENT(IN) :: rtoleranceForVelocity\n    REAL(DFP), OPTIONAL, INTENT(IN) :: atoleranceForPressure\n    REAL(DFP), OPTIONAL, INTENT(IN) :: atoleranceForVelocity\n    REAL(DFP), OPTIONAL, INTENT(IN) :: toleranceForSteadyState\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: tFluidMaterials\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: tDirichletBCForPressure\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: tDirichletBCForVelocity\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: tNeumannBCForPressure\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: tNeumannBCForVelocity\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: baseInterpolationForPressure\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: baseContinuityForPressure\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: quadratureTypeForPressure\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: baseInterpolationForVelocity\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: baseContinuityForVelocity\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: quadratureTypeForVelocity\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: baseInterpolationForSpace\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: baseContinuityForSpace\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: quadratureTypeForSpace\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: baseInterpolationForTime\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: baseContinuityForTime\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: quadratureTypeForTime\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: postProcessOpt\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: refPressureNode\n    REAL(DFP), OPTIONAL, INTENT(IN) :: refPressure\n  END SUBROUTINE setAbstractSteadyStokesParam\nEND INTERFACE\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"param"})," param stores the parameters"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"prefix"})," prefix is like name of directory inside param ",(0,i.jsx)(n.code,{children:"xyz"})," variable will be stored inside ",(0,i.jsx)(n.code,{children:"prefix/xyz"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"name"})," name of the kernel"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isCommonDomain"})," true if the domain for pressure and velocity are the same."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isConservativeForm"})," True if we are using conservative form"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"gravity"})," Acceleration due to gravity, default is zero. If gravity is zero then we use piezometric pressure. If gravity is nonzero then we use thermodynamic pressure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isSubscalePressure"})," If true then we consider the subscale pressure in stabilization"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"isBoundarySubscale"})," If true then we consider the subscale at interelement boundary"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stabParamOption"})," Option for calculating stabilization-parameter tau ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mi,{children:"\u03c4"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\tau"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.1132em"},children:"\u03c4"})]})})]}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"domainFile"})," Mesh/domain file for velocity and pressure. Use when pressure and velocity have common domain"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"domainFileForPressure"})," Mesh/domain file for pressure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"domainFileForVelocity"})," Mesh/domain file for velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"materialInterfaces"})," Mesh-id for material interfaces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"engine"})," name of engine"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"coordinateSystem"})," Coordinate system"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nnt"})," Number of nodes in time, default 1, has no effect, so ignore."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dt"})," Initial time step size, useful in case of nonlinear stokes flow"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"startTime"})," Starting time t0 of simulation, default=0.0"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"endTime"})," Final time of simulation, default is 0.0_DFP"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"maxIter"})," maximum iteration for Newton-method"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rtoleranceForPressure"})," relative tolerance for pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rtoleranceForVelocity"})," relative tolerance for velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"atoleranceForPressure"})," absolute tolerance for pressure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"atoleranceForVelocity"})," absolute tolerance for velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"toleranceForSteadyState"})," tolerance for steady state"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tFluidMaterials"})," Total number of fluid materials; default=1"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tDirichletBCForPressure"})," Total number of Dirichlet domain for pressure, default=0"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tDirichletBCForVelocity"})," Total number of Dirichlet domain for velocity, default=0"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tNeumannBCForPressure"})," Total number of Neumann domain for pressure, default=0"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tNeumannBCForVelocity"})," Total number of Neumann domain for velocity, default=0"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseInterpolationForPressure"})," Type of interpolation function used for basis function"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseContinuityForPressure"})," Type of continuity of basis function for pressure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"quadratureTypeForPressure"})," Type of quadrature for pressure field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseInterpolationForVelocity"})," Type of interpolation function used for velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseContinuityForVelocity"})," Type of continuity of basis function for velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"quadratureTypeForVelocity"})," Type of quadrature for velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseInterpolationForSpace"})," Type of interpolation function used for velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseContinuityForSpace"})," Type of continuity of basis function for velocity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"quadratureTypeForSpace"})," Type of quadrature for velocity field"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseInterpolationForTime"})," Type of interpolation function used for Time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"baseContinuityForTime"})," Type of continuity of basis function for Time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"quadratureTypeForTime"})," Type of quadrature for time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"postProcessOpt"})," Postprocessing option"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"refPressureNode"})," reference node number for pressure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"refPressure"})," reference value of pressure."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"addsurrogate",children:"AddSurrogate"}),"\n",(0,i.jsxs)(n.p,{children:["Add surrogate to the module ",(0,i.jsx)(n.a,{href:"/docs-api/ExceptionHandler/ExceptionHandler_",children:"ExceptionHandler_"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE addSurrogate(obj, UserObj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    TYPE(ExceptionHandler_), INTENT(IN) :: UserObj\n  END SUBROUTINE addSurrogate\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE AbstractSteadyStokesAddSurrogate\n  MODULE PROCEDURE addSurrogate\nEND INTERFACE AbstractSteadyStokesAddSurrogate\n"})}),"\n",(0,i.jsx)(n.h3,{id:"deallocate",children:"Deallocate"}),"\n",(0,i.jsx)(n.p,{children:"This routine deallocates the data stored inside the kernel"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE Deallocate(obj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE Deallocate\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE AbstractSteadyStokesDeallocate\n  MODULE PROCEDURE Deallocate\nEND INTERFACE AbstractSteadyStokesDeallocate\n"})}),"\n",(0,i.jsx)(n.h3,{id:"checkessentialparam",children:"CheckEssentialParam"}),"\n",(0,i.jsx)(n.p,{children:"Check the essential parameters for defining the kernel."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE checkEssentialParam(obj, param, prefix)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    TYPE(ParameterList_), INTENT(IN) :: param\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: prefix\n  END SUBROUTINE checkEssentialParam\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"initiate",children:"Initiate"}),"\n",(0,i.jsx)(n.p,{children:"Initiate the kernel."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE Initiate(obj, param, dom, domains)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    TYPE(ParameterList_), INTENT(IN) :: param\n    CLASS(Domain_), OPTIONAL, TARGET, INTENT(INOUT) :: dom\n    TYPE(DomainPointer_), OPTIONAL, TARGET, INTENT(INOUT) :: domains(:)\n  END SUBROUTINE Initiate\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE AbstractSteadyStokesInitiate(obj, param, prefix, &\n    & dom, domains)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    TYPE(ParameterList_), INTENT(IN) :: param\n    CHARACTER(LEN=*), INTENT(IN) :: prefix\n    CLASS(Domain_), OPTIONAL, TARGET, INTENT(INOUT) :: dom\n    TYPE(DomainPointer_), OPTIONAL, TARGET, INTENT(INOUT) :: domains(:)\n  END SUBROUTINE AbstractSteadyStokesInitiate\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"iomethods",children:"IOMethods"}),"\n",(0,i.jsx)(n.h3,{id:"import",children:"Import"}),"\n",(0,i.jsxs)(n.p,{children:["This rotuine imports the properties of the kernel, and then builds it. All the properties are mentioned in the HDF5 file. Domain ",(0,i.jsx)(n.code,{children:"dom"})," is used as a target for kernel's domain pointer."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE Import(obj, hdf5, group, dom)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    TYPE(HDF5File_), INTENT(INOUT) :: hdf5\n    CHARACTER(LEN=*), INTENT(IN) :: group\n    CLASS(Domain_), TARGET, INTENT(INOUT) :: dom\n  END SUBROUTINE Import\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"export",children:"Export"}),"\n",(0,i.jsxs)(n.p,{children:["This routine exports the kernel to ",(0,i.jsx)(n.a,{href:"/docs-api/HDF5File/HDF5File_",children:"HDF5File_"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE Export(obj, hdf5, group)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    TYPE(HDF5File_), INTENT(INOUT) :: hdf5\n    CHARACTER(LEN=*), INTENT(IN) :: group\n  END SUBROUTINE Export\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"display",children:"Display"}),"\n",(0,i.jsx)(n.p,{children:"This routine displays the content of the kernel on the screen"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE Display(obj, msg, unitNo)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    CHARACTER(LEN=*), INTENT(IN) :: msg\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: unitNo\n  END SUBROUTINE Display\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"writedata_hdf5",children:"WriteData_hdf5"}),"\n",(0,i.jsx)(n.p,{children:"This routine writes the data in the hdf5 file. Following data is written."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"velocity0"}),"\n",(0,i.jsx)(n.li,{children:"pressure0"}),"\n",(0,i.jsx)(n.li,{children:"tausups_cell"}),"\n",(0,i.jsx)(n.li,{children:"nulsic_cell"}),"\n",(0,i.jsx)(n.li,{children:"hv_cell"}),"\n",(0,i.jsx)(n.li,{children:"hp_cell"}),"\n",(0,i.jsx)(n.li,{children:"hmax_cell"}),"\n",(0,i.jsx)(n.li,{children:"hmin_cell"}),"\n",(0,i.jsx)(n.li,{children:"dynamicViscosity"}),"\n",(0,i.jsx)(n.li,{children:"massDensity"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE WriteData_hdf5(obj, hdf5, group)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    TYPE(HDF5File_), INTENT(INOUT) :: hdf5\n    CHARACTER(LEN=*), INTENT(IN) :: group\n  END SUBROUTINE WriteData_hdf5\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"writedata_vtk",children:"WriteData_vtk"}),"\n",(0,i.jsx)(n.p,{children:"This routine writes the data in the vtk file"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE WriteData_vtk(obj, vtk, group)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    TYPE(VTKFile_), INTENT(INOUT) :: vtk\n    CHARACTER(LEN=*), INTENT(IN) :: group\n  END SUBROUTINE WriteData_vtk\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"materialmethods",children:"MaterialMethods"}),"\n",(0,i.jsx)(n.h3,{id:"addfluidmaterial",children:"AddFluidMaterial"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This routine adds Fluid material to the ",(0,i.jsx)(n.code,{children:"AbstractSteadyStokes_:fluidMaterial"})]}),"\n",(0,i.jsxs)(n.li,{children:["It also prepares ",(0,i.jsx)(n.code,{children:"obj%FluidMaterialToMesh(materialNo)"})," and ",(0,i.jsx)(n.code,{children:"obj%fluidMaterial(materialNo)"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"param"})," contains the parameters for constructing a FluidMaterial."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"materialName"})," is the name of material, it should be ",(0,i.jsx)(n.code,{children:"fluidMaterial"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"region"})," is an instance of ",(0,i.jsx)(n.a,{href:"/docs-api/MeshSelection/MeshSelection_",children:"MeshSelection_"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"materialNo"})," should be lesser than or equal to the total number of Fluid materials."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE addFluidMaterial(obj, materialNo, materialName, &\n    & param, region)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: materialNo\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: materialName\n    TYPE(ParameterList_), OPTIONAL, INTENT(IN) :: param\n    TYPE(MeshSelection_), OPTIONAL, INTENT(IN) :: region\n  END SUBROUTINE addFluidMaterial\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"bcmethods",children:"BCMethods"}),"\n",(0,i.jsx)(n.h3,{id:"addpressuredirichletbc",children:"AddPressureDirichletBC"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This routine sets the Dirichlet boundary condition for pressure field in ",(0,i.jsx)(n.a,{href:"/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_",children:"AbstractSteadyStokes_"})," kernel."]}),"\n",(0,i.jsxs)(n.li,{children:["It also makes the ",(0,i.jsx)(n.code,{children:"obj%DBCForPressure(dbcNo)"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dbcNo"})," should be lesser than total dirichlet boundary condition for pressure field."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE addPressureDirichletBC(obj, dbcNo, param, boundary)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: dbcNo\n    !! Dirichlet boundary nunber\n    TYPE(ParameterList_), INTENT(IN) :: param\n    !! parameter for constructing [DirichletBC_](DirichletBC_.md).\n    TYPE(MeshSelection_), INTENT(IN) :: boundary\n    !! Boundary region\n  END SUBROUTINE addPressureDirichletBC\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"addvelocitydirichletbc",children:"AddVelocityDirichletBC"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This routine sets the Dirichlet boundary condition for Velocity field in ",(0,i.jsx)(n.a,{href:"/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_",children:"AbstractSteadyStokes_"})," kernel."]}),"\n",(0,i.jsxs)(n.li,{children:["It makes ",(0,i.jsx)(n.code,{children:"obj%DBCForVelocity(dbcNo)"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dbcNo"})," should be lesser than total dirichlet boundary condition for velocity field."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE addVelocityDirichletBC(obj, dbcNo, param, boundary)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: dbcNo\n    !! Dirichlet boundary nunber\n    TYPE(ParameterList_), INTENT(IN) :: param\n    !! parameter for constructing [DirichletBC_](DirichletBC_.md).\n    TYPE(MeshSelection_), INTENT(IN) :: boundary\n    !! Boundary region\n  END SUBROUTINE addVelocityDirichletBC\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"addpressureneumannbc",children:"AddPressureNeumannBC"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This routine sets the Neumann boundary condition for pressure field in ",(0,i.jsx)(n.a,{href:"/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_",children:"AbstractSteadyStokes_"})," kernel."]}),"\n",(0,i.jsxs)(n.li,{children:["It makes ",(0,i.jsx)(n.code,{children:"obj%NBCForPressure(nbcNo)"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nbcNo"})," should be lesser than total Neumann boundary condition for pressure field."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE addPressureNeumannBC(obj, nbcNo, param, boundary)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nbcNo\n    !! Neumann boundary nunber\n    TYPE(ParameterList_), INTENT(IN) :: param\n    !! parameter for constructing [DirichletBC_](DirichletBC_.md).\n    TYPE(MeshSelection_), INTENT(IN) :: boundary\n    !! Boundary region\n  END SUBROUTINE addPressureNeumannBC\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"addvelocityneumannbc",children:"AddVelocityNeumannBC"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This routine sets the Neumann boundary condition for Velocity field in ",(0,i.jsx)(n.a,{href:"/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_",children:"AbstractSteadyStokes_"})," kernel."]}),"\n",(0,i.jsxs)(n.li,{children:["It makes ",(0,i.jsx)(n.code,{children:"obj%NBCForVelocity(nbcNo)"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nbcNo"})," should be lesser than total Neumann boundary condition for velocity field."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE addVelocityNeumannBC(obj, nbcNo, param, boundary)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nbcNo\n    !! Neumann boundary nunber\n    TYPE(ParameterList_), INTENT(IN) :: param\n    !! parameter for constructing [NeumannBC_](NeumannBC_).\n    TYPE(MeshSelection_), INTENT(IN) :: boundary\n    !! Boundary region\n  END SUBROUTINE addVelocityNeumannBC\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"setmethods",children:"SetMethods"}),"\n",(0,i.jsx)(n.h3,{id:"set",children:"Set"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"This routine is the most important one"}),"\n",(0,i.jsx)(n.li,{children:"This routine should be called before starting the main computation."}),"\n",(0,i.jsx)(n.li,{children:"After initiating the kernel, we have all the information to construct the state of the kernel"}),"\n",(0,i.jsx)(n.li,{children:"This routine checks all the options"}),"\n",(0,i.jsx)(n.li,{children:"This routine, then sets pointer to the appropriate pointers."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This routine calls InitiateFields method"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE Set(obj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE Set\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE AbstractSteadyStokesSet\n  MODULE PROCEDURE Set\nEND INTERFACE AbstractSteadyStokesSet\n"})}),"\n",(0,i.jsx)(n.h2,{id:"getmethods",children:"GetMethods"}),"\n",(0,i.jsx)(n.h3,{id:"getpressuredirichletbcpointer",children:"GetPressureDirichletBCPointer"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This routine returns the pointer to Dirichlet boundary condition of pressure field in ",(0,i.jsx)(n.a,{href:"/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_",children:"AbstractSteadyStokes_"})," kernel, that is ",(0,i.jsx)(n.code,{children:"obj%DBCForPressure(dbcNo)%ptr"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"After obtaining the Dirichlet boundary condition pointer, user can set the\nboundary condition"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dbcNo"})," should be lesser than total dirichlet boundary condition."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE FUNCTION getPressureDirichletBCPointer(obj, dbcNo) RESULT(ans)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: dbcNo\n    !! Dirichlet boundary nunber\n    CLASS(DirichletBC_), POINTER :: ans\n  END FUNCTION getPressureDirichletBCPointer\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getvelocitydirichletbcpointer",children:"GetVelocityDirichletBCPointer"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This routine returns the pointer to Dirichlet boundary condition of Velocity field in ",(0,i.jsx)(n.a,{href:"/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_",children:"AbstractSteadyStokes_"})," kernel, that is ",(0,i.jsx)(n.code,{children:"obj%DBCForVelocity(dbcNo)%ptr"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"After obtaining the Dirichlet boundary condition pointer, user can set the boundary condition"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dbcNo"})," should be lesser than total dirichlet boundary condition."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE FUNCTION getVelocityDirichletBCPointer(obj, dbcNo) RESULT(ans)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: dbcNo\n    !! Dirichlet boundary nunber\n    CLASS(DirichletBC_), POINTER :: ans\n  END FUNCTION getVelocityDirichletBCPointer\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getpressureneumannbcpointer",children:"GetPressureNeumannBCPointer"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This routine returns the pointer to Neumann boundary condition of pressure field in ",(0,i.jsx)(n.a,{href:"/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_",children:"AbstractSteadyStokes_"})," kernel, that is ",(0,i.jsx)(n.code,{children:"obj%NBCForPressure(nbcNo)%ptr"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"After obtaining the Neumann boundary condition pointer, user can set the boundary condition"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nbcNo"})," should be lesser than total Neumann boundary condition."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE FUNCTION getPressureNeumannBCPointer(obj, nbcNo) RESULT(ans)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nbcNo\n    !! Neumann boundary nunber\n    CLASS(NeumannBC_), POINTER :: ans\n  END FUNCTION getPressureNeumannBCPointer\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"getvelocityneumannbcpointer",children:"GetVelocityNeumannBCPointer"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This routine returns the pointer to Neumann boundary condition of Velocity field in ",(0,i.jsx)(n.a,{href:"/docs-api/AbstractSteadyStokes/AbstractSteadyStokes_",children:"AbstractSteadyStokes_"})," kernel, that is ",(0,i.jsx)(n.code,{children:"obj%NBCForVelocity(nbcNo)%ptr"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"After obtaining the Neumann boundary condition pointer, user can set the boundary condition"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"nbcNo"})," should be lesser than total Neumann boundary condition."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE FUNCTION getVelocityNeumannBCPointer(obj, nbcNo) RESULT(ans)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nbcNo\n    !! Neumann boundary nunber\n    CLASS(NeumannBC_), POINTER :: ans\n  END FUNCTION getVelocityNeumannBCPointer\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"convergencemethods",children:"ConvergenceMethods"}),"\n",(0,i.jsx)(n.h3,{id:"issteadystate",children:"IsSteadyState"}),"\n",(0,i.jsx)(n.p,{children:"Returns true if steady state is achieved."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE FUNCTION isSteadyState(obj) RESULT(Ans)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    LOGICAL(LGT) :: ans\n  END FUNCTION isSteadyState\nEND INTERFACE\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"isconverged",children:"IsConverged"}),"\n",(0,i.jsx)(n.p,{children:"Returns true if steady state is achieved."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE FUNCTION isConverged(obj) RESULT(Ans)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    LOGICAL(LGT) :: ans\n  END FUNCTION isConverged\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"initiatefieldmethods",children:"InitiateFieldMethods"}),"\n",(0,i.jsx)(n.h3,{id:"initiatefields",children:"InitiateFields"}),"\n",(0,i.jsx)(n.p,{children:"This routine initiates the field variable, deferred type."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE InitiateFields(obj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE InitiateFields\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"applydirichletbcmethods",children:"ApplyDirichletBCMethods"}),"\n",(0,i.jsx)(n.h3,{id:"applydirichletbc",children:"ApplyDirichletBC"}),"\n",(0,i.jsx)(n.p,{children:"Apply Dirichlet boundary conditions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE applyDirichletBC(obj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE applyDirichletBC\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"solvemethods",children:"SolveMethods"}),"\n",(0,i.jsx)(n.h3,{id:"solve",children:"Solve"}),"\n",(0,i.jsx)(n.p,{children:"This subroutine solves the system of linear equation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE Solve(obj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE Solve\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"updatemethods",children:"UpdateMethods"}),"\n",(0,i.jsx)(n.p,{children:"This subroutine Updates the system of linear equation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE Update(obj, reset)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    LOGICAL(LGT), INTENT(IN) :: reset\n  END SUBROUTINE Update\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"update",children:"Update"}),"\n",(0,i.jsx)(n.p,{children:"This subroutine update the state of the kernel"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE UpdateIteration(obj, reset)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    LOGICAL(LGT), INTENT(IN) :: reset\n  END SUBROUTINE UpdateIteration\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"assembletanmatmethods",children:"AssembleTanmatMethods"}),"\n",(0,i.jsx)(n.h3,{id:"assembletanmat",children:"AssembleTanmat"}),"\n",(0,i.jsx)(n.p,{children:"This procedure pointer assembles the global tangent matrix."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE AssembleTanmat(obj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE AssembleTanmat\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"assembletanmat_internalfacet",children:"AssembleTanmat_InternalFacet"}),"\n",(0,i.jsx)(n.p,{children:"Assemble tangent matrix internal facet."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE AssembleTanmat_InternalFacet(obj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE AssembleTanmat_InternalFacet\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h3,{id:"assembletanmat_neumanfacet",children:"AssembleTanMat_NeumanFacet"}),"\n",(0,i.jsx)(n.p,{children:"Assemble tangent matrix internal facet."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE AssembleTanmat_NeumanFacet(obj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE AssembleTanmat_NeumanFacet\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"assemblemethods",children:"AssembleMethods"}),"\n",(0,i.jsx)(n.h3,{id:"assemble",children:"Assemble"}),"\n",(0,i.jsx)(n.p,{children:"This procedure pointer assembles the problem"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE Assemble(obj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE Assemble\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"assemblerhsmethods",children:"AssembleRHSMethods"}),"\n",(0,i.jsx)(n.h3,{id:"assemblerhs",children:"AssembleRHS"}),"\n",(0,i.jsx)(n.p,{children:"This procedure pointer assembles the right-hand-side vector."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE AssembleRHS(obj)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n  END SUBROUTINE AssembleRHS\nEND INTERFACE\n"})}),"\n",(0,i.jsx)(n.h2,{id:"runmethods",children:"RunMethods"}),"\n",(0,i.jsx)(n.h3,{id:"run",children:"Run"}),"\n",(0,i.jsx)(n.p,{children:"Run the simulation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE Run(obj, param)\n    CLASS(AbstractSteadyStokes_), INTENT(INOUT) :: obj\n    TYPE(ParameterList_), INTENT(IN) :: param\n  END SUBROUTINE Run\nEND INTERFACE\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},54213:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var s=r(36672);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);