"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[71186],{37748:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>E,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>N});const i=JSON.parse('{"id":"FEDomainConnectivity/InitiateNodeToNodeData","title":"InitiateNodeToNodeData","description":"This routine initiates nodeToNode data (mapping) between two domains or parts of domains.","source":"@site/docs/docs-api/FEDomainConnectivity/InitiateNodeToNodeData.md","sourceDirName":"FEDomainConnectivity","slug":"/FEDomainConnectivity/InitiateNodeToNodeData","permalink":"/docs-api/FEDomainConnectivity/InitiateNodeToNodeData","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/FEDomainConnectivity/InitiateNodeToNodeData.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"InitiateFacetToCellData","permalink":"/docs-api/FEDomainConnectivity/InitiateFacetToCellData"},"next":{"title":"MasterCellNumber","permalink":"/docs-api/FEDomainConnectivity/MasterCellNumber"}}');var a=o(23420),d=o(54213);function t(n){const e={code:"code",pre:"pre",...(0,d.R)(),...n.components};return(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-fortran",children:'PROGRAM main\n\nUSE GlobalData\nUSE Test_Method\nUSE ApproxUtility\nUSE FEDomainConnectivity_Class\nUSE FEDomain_Class\nUSE HDF5File_Class\n\nIMPLICIT NONE\n\nCHARACTER(*), PARAMETER :: domain1_filename = &\n                           "../../Mesh/examples/meshdata/small_tri3_mesh.h5"\nCHARACTER(*), PARAMETER :: domain2_filename = &\n                           "../../Mesh/examples/meshdata/small_tri3_mesh.h5"\nCHARACTER(*), PARAMETER :: test_name = "InitiateNodeToNodeData test 1"\nINTEGER(I4B), PARAMETER :: nsd = 2\n\nTYPE(FEDomainConnectivity_) :: obj\n\nTYPE(FEDomain_) :: domain1, domain2\n\nTYPE(HDF5File_) :: domain1_meshfile, domain2_meshfile\n\nINTEGER(I4B), POINTER :: nodeToNode(:)\n\nREAL(DFP) :: x1(3), x2(3)\n\nINTEGER(I4B) :: ii, tnodes, jj\nLOGICAL(LGT) :: isok\n\nCALL domain1_meshfile%Initiate(fileName=domain1_filename, MODE="READ")\nCALL domain1_meshfile%OPEN()\nCALL domain1%Initiate(domain1_meshfile, "")\nCALL domain1_meshfile%DEALLOCATE()\n\nCALL domain2_meshfile%Initiate(fileName=domain2_filename, MODE="READ")\nCALL domain2_meshfile%OPEN()\nCALL domain2%Initiate(domain2_meshfile, "")\nCALL domain2_meshfile%DEALLOCATE()\n\n! node to node mapping\n! local node number of domain1 are mapped to global node number of domain2\nCALL obj%InitiateNodeToNodeData(domain1=domain1, domain2=domain2)\n\nnodeToNode => obj%GetNodeToNodePointer()\n\ntnodes = domain1%GetTotalNodes()\n\nDO ii = 1, tnodes\n\n  CALL domain1%GetNodeCoord(nodecoord=x1, globalNode=ii, islocal=.TRUE.)\n\n  jj = nodeToNode(ii)\n\n  if(jj .eq. 0) cycle\n\n  CALL domain2%GetNodeCoord(nodecoord=x2, globalNode=jj, islocal=.FALSE.)\n\n  isok = ALL(x1(1:nsd) .APPROXEQ.x2(1:nsd))\n  IF (.NOT. isok) THEN\n    EXIT\n  END IF\nEND DO\n\nCALL OK(isok, test_name)\n\nCALL domain1%DEALLOCATE()\nCALL domain2%DEALLOCATE()\nCALL obj%DEALLOCATE()\n\nEND PROGRAM main\n'})})}function m(n={}){const{wrapper:e}={...(0,d.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(t,{...n})}):t(n)}function s(n){const e={code:"code",pre:"pre",...(0,d.R)(),...n.components};return(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-fortran",children:'PROGRAM main\n\nUSE GlobalData\nUSE Test_Method\nUSE ApproxUtility\nUSE FEDomainConnectivity_Class\nUSE FEDomain_Class\nUSE HDF5File_Class\n\nIMPLICIT NONE\n\nCHARACTER(*), PARAMETER :: domain1_filename = &\n                           "../../Mesh/examples/meshdata/small_tri3_mesh.h5"\nCHARACTER(*), PARAMETER :: domain2_filename = &\n                           "../../Mesh/examples/meshdata/small_tri6_mesh.h5"\nCHARACTER(*), PARAMETER :: test_name = "InitiateNodeToNodeData test 2"\nINTEGER(I4B), PARAMETER :: nsd = 2\n\nTYPE(FEDomainConnectivity_) :: obj\n\nTYPE(FEDomain_) :: domain1, domain2\n\nTYPE(HDF5File_) :: domain1_meshfile, domain2_meshfile\n\nINTEGER(I4B), POINTER :: nodeToNode(:)\n\nREAL(DFP) :: x1(3), x2(3)\n\nINTEGER(I4B) :: ii, tnodes, jj\nLOGICAL(LGT) :: isok\n\nCALL domain1_meshfile%Initiate(fileName=domain1_filename, MODE="READ")\nCALL domain1_meshfile%OPEN()\nCALL domain1%Initiate(domain1_meshfile, "")\nCALL domain1_meshfile%DEALLOCATE()\n\nCALL domain2_meshfile%Initiate(fileName=domain2_filename, MODE="READ")\nCALL domain2_meshfile%OPEN()\nCALL domain2%Initiate(domain2_meshfile, "")\nCALL domain2_meshfile%DEALLOCATE()\n\n! node to node mapping\n! local node number of domain1 are mapped to global node number of domain2\nCALL obj%InitiateNodeToNodeData(domain1=domain1, domain2=domain2)\n\nnodeToNode => obj%GetNodeToNodePointer()\n\ntnodes = domain1%GetTotalNodes()\n\nDO ii = 1, tnodes\n\n  CALL domain1%GetNodeCoord(nodecoord=x1, globalNode=ii, islocal=.TRUE.)\n\n  jj = nodeToNode(ii)\n\n  IF (jj .EQ. 0) CYCLE\n\n  CALL domain2%GetNodeCoord(nodecoord=x2, globalNode=jj, islocal=.FALSE.)\n\n  isok = ALL(x1(1:nsd) .APPROXEQ.x2(1:nsd))\n  IF (.NOT. isok) THEN\n    EXIT\n  END IF\nEND DO\n\nCALL OK(isok, test_name)\n\nCALL domain1%DEALLOCATE()\nCALL domain2%DEALLOCATE()\nCALL obj%DEALLOCATE()\n\nEND PROGRAM main\n'})})}function l(n={}){const{wrapper:e}={...(0,d.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(s,{...n})}):s(n)}const r={},c="InitiateNodeToNodeData",E={},N=[{value:"Interface 1",id:"interface-1",level:2},{value:"Interface 2",id:"interface-2",level:2},{value:"More examples",id:"more-examples",level:2}];function T(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,d.R)(),...n.components},{TabItem:o,Tabs:i}=e;return o||A("TabItem",!0),i||A("Tabs",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"initiatenodetonodedata",children:"InitiateNodeToNodeData"})}),"\n",(0,a.jsx)(e.p,{children:"This routine initiates nodeToNode data (mapping) between two domains or parts of domains."}),"\n",(0,a.jsx)(e.h2,{id:"interface-1",children:"Interface 1"}),"\n",(0,a.jsxs)(i,{children:[(0,a.jsxs)(o,{value:"interface",label:"Interface",default:!0,children:[(0,a.jsx)(e.p,{children:"This subroutine generates the node to node connectivity between two meshes"}),(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"obj%nodeToNode"})," will be initiated"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"domain1"})," main domain"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"domain2"})," secondary domain"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"dim1, entitynum1"})," dimension and entity number of mesh in ",(0,a.jsx)(e.code,{children:"domain1"})]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"dim2, entitynum2"})," dimension and entity number of mesh in ",(0,a.jsx)(e.code,{children:"domain2"})]}),"\n"]}),(0,a.jsx)(e.admonition,{type:"caution",children:(0,a.jsxs)(e.p,{children:["In this case bounds of ",(0,a.jsx)(e.code,{children:"nodeToNode"})," will be from 1 to ",(0,a.jsx)(e.code,{children:"mesh1%maxNptrs"}),"."]})}),(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE dc_InitiateNodeToNodeData1(obj, domain1, domain2, &\n    & dim1, dim2, entityNum1, entityNum2)\n    CLASS(DomainConnectivity_), INTENT(INOUT) :: obj\n    !! Domain connectivity object,\n    !! [[DomainConnectivity:nodeToNode]] will be initiated\n    CLASS(Domain_), INTENT(IN) :: domain1\n    !! Primary domain, in nodeToNode(i), i denotes the\n    !! global node number in domain1 domain.\n    CLASS(Domain_), INTENT(IN) :: domain2\n    !! secondary domain, => nodeToNode(i) denotes the\n    !! global node number in `domain2` domain.\n    INTEGER(I4B), INTENT(IN) :: dim1\n    !! dimension of mesh in domain1\n    INTEGER(I4B), INTENT(IN) :: dim2\n    !! dimension of mesh in domain2\n    INTEGER(I4B), INTENT(IN) :: entityNum1\n    !! entity num of mesh in domain1\n    INTEGER(I4B), INTENT(IN) :: entityNum2\n    !! entity num of mesh in domain2\n  END SUBROUTINE dc_InitiateNodeToNodeData1\nEND INTERFACE\n"})})]}),(0,a.jsx)(o,{value:"example",label:"example",children:(0,a.jsx)(m,{})}),(0,a.jsx)(o,{value:"close",label:"\u21a2 close"})]}),"\n",(0,a.jsx)(e.h2,{id:"interface-2",children:"Interface 2"}),"\n",(0,a.jsxs)(i,{children:[(0,a.jsx)(o,{value:"interface",label:"Interface",default:!0,children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE dc_InitiateNodeToNodeData2(obj, domain1, domain2)\n    CLASS(DomainConnectivity_), INTENT(INOUT) :: obj\n    !! Domain connectivity object\n    CLASS(Domain_), INTENT(IN) :: domain1\n    !! Primary domain, in nodeToNode(i), i denotes the\n    !! global node number in domain1 domain.\n    CLASS(Domain_), INTENT(IN) :: domain2\n    !! Secondary domain => nodeToNode(i) denotes the\n    !! global node number in domain2 domain.\n  END SUBROUTINE dc_InitiateNodeToNodeData2\nEND INTERFACE\n"})})}),(0,a.jsx)(o,{value:"example",label:"example",children:(0,a.jsx)(l,{})}),(0,a.jsx)(o,{value:"close",label:"\u21a2 close"})]}),"\n",(0,a.jsx)(e.h2,{id:"more-examples",children:"More examples"})]})}function h(n={}){const{wrapper:e}={...(0,d.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(T,{...n})}):T(n)}function A(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}},54213:(n,e,o)=>{o.d(e,{R:()=>t,x:()=>m});var i=o(36672);const a={},d=i.createContext(a);function t(n){const e=i.useContext(d);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function m(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:t(n.components),i.createElement(d.Provider,{value:e},n.children)}}}]);