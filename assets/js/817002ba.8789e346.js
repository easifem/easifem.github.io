"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[17238],{58467:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"SuperLU/options","title":"Options","description":"The options argument is the input argument to control the behaviour of the library. The user can tell the solver how the linear systems should be solved based on some known characteristics of the system. For example, for diagonally dominant matrices, choosing the diagonal pivots ensures stability; there is no need for numerical pivoting (i.e., Pr can be an Identity matrix). In another situation where a sequence of matrices with the same sparsity pattern need be factorized, the column permutation Pc (and also the row permutation Pr, if the numerical values are similar) need be computed only once, and reused thereafter. In these cases, the solvers\u2019 performance can be much improved over using the default settings. Options is implemented as a C structure containing the following fields:","source":"@site/docs/docs-api/SuperLU/options.md","sourceDirName":"SuperLU","slug":"/SuperLU/options","permalink":"/docs-api/SuperLU/options","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/SuperLU/options.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Formats","permalink":"/docs-api/SuperLU/formats"},"next":{"title":"SwapUtility","permalink":"/docs-api/SwapUtility/"}}');var t=n(23420),r=n(54213);const a={},l="Options",c={},o=[{value:"Fact",id:"fact",level:2},{value:"Equil",id:"equil",level:2},{value:"ColPerm",id:"colperm",level:2},{value:"Trans",id:"trans",level:2},{value:"IterRefine",id:"iterrefine",level:2},{value:"DiagPivotThresh",id:"diagpivotthresh",level:2},{value:"SymmetricMode",id:"symmetricmode",level:2},{value:"PivotGrowth",id:"pivotgrowth",level:2},{value:"ConditionNumber",id:"conditionnumber",level:2},{value:"RowPerm",id:"rowperm",level:2},{value:"ILU_DropRule",id:"ilu_droprule",level:2},{value:"ILU_DropTol",id:"ilu_droptol",level:2},{value:"ILU_FillFactor",id:"ilu_fillfactor",level:2},{value:"ILU_MILU",id:"ilu_milu",level:2},{value:"PrintStat",id:"printstat",level:2}];function h(e){const s={annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"options",children:"Options"})}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"options"})," argument is the input argument to control the behaviour of the library. The user can tell the solver how the linear systems should be solved based on some known characteristics of the system. For example, for diagonally dominant matrices, choosing the diagonal pivots ensures stability; there is no need for numerical pivoting (i.e., Pr can be an Identity matrix). In another situation where a sequence of matrices with the same sparsity pattern need be factorized, the column permutation Pc (and also the row permutation Pr, if the numerical values are similar) need be computed only once, and reused thereafter. In these cases, the solvers\u2019 performance can be much improved over using the default settings. Options is implemented as a C structure containing the following fields:"]}),"\n",(0,t.jsx)(s.h2,{id:"fact",children:"Fact"}),"\n",(0,t.jsx)(s.p,{children:"Specifies whether the factored form of the matrix A is supplied on entry, and if not, how the matrix A will be factorized base on the previous history, such as factor from scratch, reuse Pc and/or Pr, or reuse the data structures of L and U. fact can be one of:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"DOFACT"})," the matrix A will be factorized from scratch."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SamePattern"})," the matrix A will be factorized assuming that a factorization of a matrix with the same sparsity pattern was performed prior to this one. Therefore, this factorization will reuse column permutation vector perm c."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SampPattern_SameRowPerm"})," the matrix A will be factorized assuming that a factorization of a matrix with the same sparsity pattern and similar numerical values was performed prior to this one. Therefore, this factorization will reuse both row and column permutation vectors ",(0,t.jsx)(s.code,{children:"perm_r"})," and ",(0,t.jsx)(s.code,{children:"perm_c"}),", both row and column scaling factors Dr and Dc, and the distributed data structure set up from the previous symbolic factorization."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"FACTORED"})," the factored form of A is input."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"equil",children:"Equil"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"YES"}),"\n",(0,t.jsx)(s.li,{children:"NO"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Specifies whether to equilibrate the system (scale A\u2019s rows and columns to have unit norm)."}),"\n",(0,t.jsx)(s.h2,{id:"colperm",children:"ColPerm"}),"\n",(0,t.jsx)(s.p,{children:"Specifies how to permute the columns of the matrix for sparsity preservation."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"NATURAL: natural ordering."}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"MMD_ATA"}),": minimum degree ordering on the structure of ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsxs)(s.msup,{children:[(0,t.jsx)(s.mi,{children:"A"}),(0,t.jsx)(s.mi,{children:"T"})]}),(0,t.jsx)(s.mo,{children:"\u22c5"}),(0,t.jsx)(s.mi,{children:"A"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"A^{T} \\cdot A"})]})})}),(0,t.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.8413em"}}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mord mathnormal",children:"A"}),(0,t.jsx)(s.span,{className:"msupsub",children:(0,t.jsx)(s.span,{className:"vlist-t",children:(0,t.jsx)(s.span,{className:"vlist-r",children:(0,t.jsx)(s.span,{className:"vlist",style:{height:"0.8413em"},children:(0,t.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,t.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(s.span,{className:"mord mtight",children:(0,t.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.13889em"},children:"T"})})})]})})})})})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(s.span,{className:"mbin",children:"\u22c5"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"A"})]})]})]}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"MMD_AT_PLUS_A"}),": minimum degree ordering on the structure of ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsxs)(s.msup,{children:[(0,t.jsx)(s.mi,{children:"A"}),(0,t.jsx)(s.mi,{children:"T"})]}),(0,t.jsx)(s.mo,{children:"+"}),(0,t.jsx)(s.mi,{children:"A"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"A^{T} + A"})]})})}),(0,t.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.9247em",verticalAlign:"-0.0833em"}}),(0,t.jsxs)(s.span,{className:"mord",children:[(0,t.jsx)(s.span,{className:"mord mathnormal",children:"A"}),(0,t.jsx)(s.span,{className:"msupsub",children:(0,t.jsx)(s.span,{className:"vlist-t",children:(0,t.jsx)(s.span,{className:"vlist-r",children:(0,t.jsx)(s.span,{className:"vlist",style:{height:"0.8413em"},children:(0,t.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,t.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,t.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,t.jsx)(s.span,{className:"mord mtight",children:(0,t.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.13889em"},children:"T"})})})]})})})})})]}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(s.span,{className:"mbin",children:"+"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"A"})]})]})]}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"COLAMD"}),": approximate minimum degree column ordering."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"MY_PERMC"}),": use the ordering given in perm c input by the user."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"trans",children:"Trans"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"NOTRANS"}),"\n",(0,t.jsx)(s.li,{children:"TRANS"}),"\n",(0,t.jsx)(s.li,{children:"CONJ"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Specifies whether to solve the transposed system."}),"\n",(0,t.jsx)(s.h2,{id:"iterrefine",children:"IterRefine"}),"\n",(0,t.jsx)(s.p,{children:"Specifies whether to perform iterative refinement, and in what precision to compute the residual."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"NO: no iterative refinement"}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SLU_SINGLE"}),": perform iterative refinement in single precision"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SLU_DOUBLE"}),": perform iterative refinement in double precision"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SLU_EXTRA"}),": perform iterative refinement in extra precision"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"diagpivotthresh",children:"DiagPivotThresh"}),"\n",(0,t.jsxs)(s.p,{children:["Specifies the threshold used for a diagonal entry to be an acceptable pivot. It lies in ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mo,{stretchy:"false",children:"["}),(0,t.jsx)(s.mn,{children:"0"}),(0,t.jsx)(s.mo,{separator:"true",children:","}),(0,t.jsx)(s.mn,{children:"1.0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"]"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"[0, 1.0]"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mopen",children:"["}),(0,t.jsx)(s.span,{className:"mord",children:"0"}),(0,t.jsx)(s.span,{className:"mpunct",children:","}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord",children:"1.0"}),(0,t.jsx)(s.span,{className:"mclose",children:"]"})]})})]})]}),"\n",(0,t.jsx)(s.h2,{id:"symmetricmode",children:"SymmetricMode"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"YES"}),"\n",(0,t.jsx)(s.li,{children:"NO"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Specifies whether to use the symmetric mode. Symmetric mode gives preference to diagonal pivots, and uses a ",(0,t.jsx)(s.code,{children:"(AT + A)"})," based column-permutation algorithm."]}),"\n",(0,t.jsx)(s.h2,{id:"pivotgrowth",children:"PivotGrowth"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"YES"}),"\n",(0,t.jsx)(s.li,{children:"NO"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Specifies whether to compute the reciprocal pivot growth."}),"\n",(0,t.jsx)(s.h2,{id:"conditionnumber",children:"ConditionNumber"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"YES"}),"\n",(0,t.jsx)(s.li,{children:"NO"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Specifies whether to compute the reciprocal condition number."}),"\n",(0,t.jsx)(s.h2,{id:"rowperm",children:"RowPerm"}),"\n",(0,t.jsx)(s.p,{children:"(only for ILU or SuperLU DIST)\nSpecifies whether to permute the rows of the original matrix."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"NO: not to permute the rows"}),"\n",(0,t.jsx)(s.li,{children:"LargeDiag MC64: use a serial, weighted bipartite matching algorithm implemented in\nMC64 to permute the rows to make the diagonal large relative to the off-diagonal [11]."}),"\n",(0,t.jsx)(s.li,{children:"LargeDiag AWPM: use a parallel, approximate weighted bipartite matching algorithm\nimplemented in CombBLAS to permute the rows to make the diagonal large relative to\nthe off-diagonal [3]."}),"\n",(0,t.jsx)(s.li,{children:"MY PERMR: use the permutation given by the user."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"ilu_droprule",children:"ILU_DropRule"}),"\n",(0,t.jsx)(s.p,{children:"Specifies the dropping rule for ILU: (Default: DROP BASIC | DROP AREA)"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"DROP_BASIC"}),": Basic dropping rule, supernodal based ILUTP(\u03c4)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"DROP_PROWS"}),": Supernodal based ILUTP(p, \u03c4), p = \u03b3 \xb7 nnz(A)/n."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"DROP_COLUMN"}),": Variant of ILUTP(p, \u03c4), for j-th column, p = \u03b3 \xb7 nnz(A(:, j))."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"DROP_AREA"}),": Variation of ILUTP, for j-th column, use nnz(F (:, 1 : j))/nnz(A(:, 1 : j)) to control memory."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"DROP_DYNAMIC"}),": Dynamically adjust the threshold \u03c4 during factorizaion:"]}),"\n"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-txt",children:"If nnz(L(:, 1 : j))/nnz(A(:, 1 : j)) > \u03b3, \u03c4L (j) := min(\u03c40, \u03c4L (j \u2212 1) \xb7 2); Otherwise \u03c4L (j) :=\nmax(\u03c40 , \u03c4L (j \u2212 1)/2). \u03c4U (j) uses the similar rule.\n"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"DROP_INTERP"}),": Compute the second dropping threshold by interpolation instead of quick select (default). In this case, the actual fill ratio is not guaranteed to be smaller than gamma."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"ilu_droptol",children:"ILU_DropTol"}),"\n",(0,t.jsxs)(s.p,{children:["Specifies the numerical dropping threshold for ILU. It belongs to ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mo,{stretchy:"false",children:"["}),(0,t.jsx)(s.mn,{children:"0.0"}),(0,t.jsx)(s.mo,{separator:"true",children:","}),(0,t.jsx)(s.mn,{children:"1.0"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"]"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"[0.0, 1.0]"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mopen",children:"["}),(0,t.jsx)(s.span,{className:"mord",children:"0.0"}),(0,t.jsx)(s.span,{className:"mpunct",children:","}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord",children:"1.0"}),(0,t.jsx)(s.span,{className:"mclose",children:"]"})]})})]}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"ilu_fillfactor",children:"ILU_FillFactor"}),"\n",(0,t.jsx)(s.p,{children:"(\u2265 1.0)\nSpecifies the expected fill ratio upper bound, \u03b3, for ILU."}),"\n",(0,t.jsx)(s.h2,{id:"ilu_milu",children:"ILU_MILU"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"SILU"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"SMILU_1"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"SMILU_2"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"SMILU_3"})}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Specifies which version of modified ILU to use."}),"\n",(0,t.jsx)(s.h2,{id:"printstat",children:"PrintStat"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"YES"}),"\n",(0,t.jsx)(s.li,{children:"NO"}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Specifies whether to print the solver\u2019s statistics."})]})}function d(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},54213:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>l});var i=n(36672);const t={},r=i.createContext(t);function a(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);