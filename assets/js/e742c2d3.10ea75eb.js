"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[51149],{41943:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"AbstractMesh/AbstractMesh_","title":"Structure","description":"AbstractMesh_ datatype is simply a collection of finite elements and nodes.","source":"@site/docs/docs-api/AbstractMesh/AbstractMesh_.md","sourceDirName":"AbstractMesh","slug":"/AbstractMesh/AbstractMesh_","permalink":"/docs-api/AbstractMesh/AbstractMesh_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AbstractMesh/AbstractMesh_.md","tags":[],"version":"current","lastUpdatedAt":1746862724000,"sidebarPosition":2,"frontMatter":{"title":"Structure","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"AbstractMesh","permalink":"/docs-api/AbstractMesh/"},"next":{"title":"ElemData","permalink":"/docs-api/AbstractMesh/ElemData_"}}');var s=i(23420),d=i(54213);const l={title:"Structure",sidebar_position:2},a=void 0,o={},r=[{value:"Type definition",id:"type-definition",level:2},{value:"showTime",id:"showtime",level:3},{value:"readFromFile",id:"readfromfile",level:3},{value:"isInitiated",id:"isinitiated",level:3},{value:"isNodeToElementsInitiated",id:"isnodetoelementsinitiated",level:3},{value:"isNodeToNodesInitiated",id:"isnodetonodesinitiated",level:3},{value:"isExtraNodeToNodesInitiated",id:"isextranodetonodesinitiated",level:3},{value:"isElementToElementsInitiated",id:"iselementtoelementsinitiated",level:3},{value:"isEdgeConnectivityInitiated",id:"isedgeconnectivityinitiated",level:3},{value:"isFaceConnectivityInitiated",id:"isfaceconnectivityinitiated",level:3},{value:"isBoundaryDataInitiated",id:"isboundarydatainitiated",level:3},{value:"isFacetDataInitiated",id:"isfacetdatainitiated",level:3},{value:"uid",id:"uid",level:3},{value:"xidim",id:"xidim",level:3},{value:"tElements_topology_wise",id:"telements_topology_wise",level:3},{value:"tElemTopologies and elemTopologies",id:"telemtopologies-and-elemtopologies",level:3},{value:"maxNNE",id:"maxnne",level:3},{value:"nsd",id:"nsd",level:3},{value:"xidim",id:"xidim-1",level:3},{value:"maxNptrs",id:"maxnptrs",level:3},{value:"minNptrs",id:"minnptrs",level:3},{value:"maxElemNum",id:"maxelemnum",level:3},{value:"minElemNum",id:"minelemnum",level:3},{value:"tNodes",id:"tnodes",level:3},{value:"tEdges",id:"tedges",level:3},{value:"tFaces",id:"tfaces",level:3},{value:"tElements",id:"telements",level:3},{value:"minX, maxX, minY, maxY, minZ, maxZ",id:"minx-maxx-miny-maxy-minz-maxz",level:3},{value:"x, y, z",id:"x-y-z",level:3},{value:"boundingEntity",id:"boundingentity",level:3},{value:"local_elemNumber and local_Nptrs",id:"local_elemnumber-and-local_nptrs",level:3},{value:"quality",id:"quality",level:3},{value:"facetElementType",id:"facetelementtype",level:3},{value:"nodeData",id:"nodedata",level:3},{value:"elementData",id:"elementdata",level:3},{value:"internalFacetData",id:"internalfacetdata",level:3},{value:"boundaryFacetData",id:"boundaryfacetdata",level:3},{value:"elementDataList",id:"elementdatalist",level:3},{value:"elementDataBinaryTree",id:"elementdatabinarytree",level:3},{value:"nodeDataList",id:"nodedatalist",level:3},{value:"nodeDataBinaryTree",id:"nodedatabinarytree",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AbstractMesh_"})," datatype is simply a collection of finite elements and nodes."]}),"\n",(0,s.jsxs)(n.p,{children:["This is an abstract class, which will be extended by ",(0,s.jsx)(n.code,{children:"Mesh_"})," and ",(0,s.jsx)(n.code,{children:"FEMesh_"})," class."]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.mdxAdmonitionTitle,{children:["Difference between ",(0,s.jsx)(n.code,{children:"Mesh"})," and ",(0,s.jsx)(n.code,{children:"FEMesh"})]}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Mesh"})," class is older version and ",(0,s.jsx)(n.code,{children:"FEMesh"})," is a newer version. In future, ",(0,s.jsx)(n.code,{children:"Mesh"})," class will be merged with ",(0,s.jsx)(n.code,{children:"FEMesh"})," class."]}),"\n",(0,s.jsx)(n.li,{children:"In EASIFEM mesh is a homogeneous collection of reference elements. All elements in mesh should be of same type (i.e., triangle, quadrangle, tetrahedron, etc.)."}),"\n",(0,s.jsx)(n.li,{children:"Two meshes can have different types of elements. For example, we can define a mesh of triangle element or a mesh of tetrahedron element."}),"\n",(0,s.jsxs)(n.li,{children:["However, in ",(0,s.jsx)(n.code,{children:"FEMesh"})," elements can have different topology but they all should have same co-dimension. That is in ",(0,s.jsx)(n.code,{children:"FEMesh"})," all elements need to be either ",(0,s.jsx)(n.code,{children:"volume"}),", or ",(0,s.jsx)(n.code,{children:"surface"}),", or ",(0,s.jsx)(n.code,{children:"curve"}),", or ",(0,s.jsx)(n.code,{children:"point"}),"."]}),"\n"]})]}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["The support for Mesh class is deprecated and will be removed in future. Please use ",(0,s.jsx)(n.code,{children:"FEMesh"})," class instead. In the future Mesh class and FEMesh class will be the same."]})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["You can learn about the structure of ",(0,s.jsx)(n.code,{children:"FEMesh"})," ",(0,s.jsx)(n.a,{href:"/docs-api/FEMesh/FEMesh_",children:"Here"})]}),"\n",(0,s.jsxs)(n.li,{children:["You can learn about the structure of ",(0,s.jsx)(n.code,{children:"ElemData"})," ",(0,s.jsx)(n.a,{href:"/docs-api/AbstractMesh/ElemData_",children:"Here"})]}),"\n",(0,s.jsxs)(n.li,{children:["You can learn about the structure of ",(0,s.jsx)(n.code,{children:"NodeData"})," ",(0,s.jsx)(n.a,{href:"/docs-api/AbstractMesh/NodeData_",children:"Here"})]}),"\n",(0,s.jsxs)(n.li,{children:["The information of ",(0,s.jsx)(n.code,{children:"BoundaryFacetData"})," is given ",(0,s.jsx)(n.a,{href:"/docs-api/AbstractMesh/BoundaryFacetData_",children:"Here"})]}),"\n",(0,s.jsxs)(n.li,{children:["The information of ",(0,s.jsx)(n.code,{children:"InternalFacetData"})," is given ",(0,s.jsx)(n.a,{href:"/docs-api/AbstractMesh/InternalFacetData_",children:"Here"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"type-definition",children:"Type definition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fortran",children:"TYPE, ABSTRACT :: AbstractMesh_\n  PRIVATE\n  LOGICAL(LGT) :: showTime = .FALSE.\n    !! If true, then we show the time taken by various mesh operations\n    !! This is for checking the performance of a subclass\n  LOGICAL(LGT) :: readFromFile = .TRUE.\n    !! True if the mesh is read from a file\n  LOGICAL(LGT) :: isInitiated = .FALSE.\n    !! logical flag denoting for whether mesh data is Initiated or not\n  LOGICAL(LGT) :: isNodeToElementsInitiated = .FALSE.\n    !! Node to elements mapping\n  LOGICAL(LGT) :: isNodeToNodesInitiated = .FALSE.\n    !! Node to nodes mapping\n  LOGICAL(LGT) :: isExtraNodeToNodesInitiated = .FALSE.\n    !! Node to nodes mapping\n  LOGICAL(LGT) :: isElementToElementsInitiated = .FALSE.\n    !! Element to elements mapping\n  LOGICAL(LGT) :: isEdgeConnectivityInitiated = .FALSE.\n    !! This is Set to true when edge connectivity is initiated\n    !! See InitiateEdgeConnectivity method\n  LOGICAL(LGT) :: isFaceConnectivityInitiated = .FALSE.\n    !! This is Set to true when face connectivity is initiated\n    !! See InitiateFaceConnectivity method\n  LOGICAL(LGT) :: isBoundaryDataInitiated = .FALSE.\n    !! Boundary data\n  LOGICAL(LGT) :: isFacetDataInitiated = .FALSE.\n    !! FacetData\n  INTEGER(I4B) :: uid = 0\n    !! Unique id of the mesh\n    !! In case of Mesh_ it is entityNumber of the mesh\n  INTEGER(I4B) :: tElements_topology_wise(8) = 0\n    !! point, line, triangle, quadrangle, tetrahedron, hexahedron, prism,\n    !! pyramid (it is calculated in the postprocessing step)\n  INTEGER(I4B) :: tElemTopologies = 0, elemTopologies(8) = 0\n    !! total element topologies, name of element topologies are stored in\n    !! elemTopologies(1:tElemTopologies)\n    !! this info is computed in a postprocessing step\n  INTEGER(I4B) :: maxNNE = 0\n    !! maximum number of nodes in element\n  INTEGER(I4B) :: nsd = 0\n    !! number of spatial dimension of the mesh\n  INTEGER(I4B) :: xidim = 0\n    !! xidimension of elements present inside the mesh\n    !! for point xidim = 0\n    !! for line/curve xidim = 1\n    !! for surface xidim = 2\n    !! for volume xidim = 3\n  INTEGER(I4B) :: maxNptrs = 0\n    !! largest node number present inside the mesh\n  INTEGER(I4B) :: minNptrs = 0\n    !! minimum node number present inside the mesh\n  INTEGER(I4B) :: maxElemNum = 0\n    !! largest element number present inside the mesh\n  INTEGER(I4B) :: minElemNum = 0\n    !! minimum element number present inside the mesh\n  INTEGER(I4B) :: tNodes = 0\n    !! total number of nodes present inside the mesh\n  INTEGER(I4B) :: tEdges = 0\n    !! total number of internal nodes inside the mesh\n  INTEGER(I4B) :: tFaces = 0\n    !! total number of internal nodes inside the mesh\n  INTEGER(I4B) :: tElements = 0\n    !! total number of elements present inside the mesh\n    !! It is the size of elemNumber vector\n  REAL(DFP) :: minX = 0.0\n    !! minimum value of x coordinate\n  REAL(DFP) :: maxX = 0.0\n    !! maximum value of x coordinate\n  REAL(DFP) :: minY = 0.0\n    !! minimum value of y coordinate\n  REAL(DFP) :: maxY = 0.0\n    !! maximum value of y coordinate\n  REAL(DFP) :: minZ = 0.0\n    !! minimum value of z coordinate\n  REAL(DFP) :: maxZ = 0.0\n    !! maximum value of z coordinate\n  REAL(DFP) :: x = 0.0\n    !! x coorindate of centroid\n  REAL(DFP) :: y = 0.0\n    !! y coordinate of centroid\n  REAL(DFP) :: z = 0.0\n    !! z coordinate of centroid\n  INTEGER(I4B), ALLOCATABLE :: boundingEntity(:)\n    !! Bounding entity numbers of the current entity\n  INTEGER(I4B), ALLOCATABLE :: local_elemNumber(:)\n    !! List of local element numbers, the lowerbound is `minElemNum`\n    !! and upper bound is `maxElemNum`. In this way, local_elemNumber(iel)\n    !! returns the local element number of global element number iel.\n\n  INTEGER(I4B), ALLOCATABLE :: local_Nptrs(:)\n    !! Returns local node number from a global node number\n    !! Its length is from 1 to maxNptrs\n    !! Helpul in finding if a global node is present inside the mesh or not\n\n  REAL(DFP), ALLOCATABLE :: quality(:, :)\n    !! number of rows are meshquality\n    !! number of columns are elements\n\n  INTEGER(I4B), ALLOCATABLE :: facetElementType(:, :)\n    !! Number of rows of this array is same as the total number of\n    !! facets present in the mesh-reference elements\n    !! Number of columns of this array is equal to the total number of\n    !! elements inside the mesh\n    !! facetElementType(ii, iel) can be\n    !! INTERNAL_ELEMENT, BOUNDARY_ELEMENT, DOMAIN_BOUNDARY_ELEMENT\n    !! If the face is a part of the mesh boundary then it will be called\n    !! the BOUNDARY_ELEMENT\n\n  TYPE(NodeData_), ALLOCATABLE :: nodeData(:)\n    !! Node data\n\n  TYPE(ElemData_), ALLOCATABLE :: elementData(:)\n    !! element data\n\n  TYPE(InternalFacetData_), ALLOCATABLE :: internalFacetData(:)\n    !! Internal facet data\n    !! INFO: This data is initiated by InitiateFacetElements method\n\n  TYPE(BoundaryFacetData_), PUBLIC, ALLOCATABLE :: boundaryFacetData(:)\n    !! Domain Facet Data\n    !! INFO: This data is initiated by InitiateFacetElements method\n\n  TYPE(ElemDataList_) :: elementDataList\n  !! ElemData list\n  TYPE(ElemDataBinaryTree_) :: elementDataBinaryTree\n  !! ElemData binary tree\n  TYPE(NodeDataList_) :: nodeDataList\n  !! NodeData list\n  TYPE(NodeDataBinaryTree_) :: nodeDataBinaryTree\n  !! NodeData binary tree\n\nEND TYPE AbstractMesh_\n"})}),"\n",(0,s.jsx)(n.h3,{id:"showtime",children:"showTime"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"showTime"})," is true if the time taken by various mesh operations is shown."]}),"\n",(0,s.jsx)(n.h3,{id:"readfromfile",children:"readFromFile"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"readFromFile"})," is true if the mesh is read from a file."]}),"\n",(0,s.jsx)(n.h3,{id:"isinitiated",children:"isInitiated"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"isInitiated"})," is logical flag denoting whether mesh data is initiated or not."]}),"\n",(0,s.jsx)(n.h3,{id:"isnodetoelementsinitiated",children:"isNodeToElementsInitiated"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"isNodeToElementsInitiated"})," is true if node to elements mapping is initiated."]}),"\n",(0,s.jsx)(n.h3,{id:"isnodetonodesinitiated",children:"isNodeToNodesInitiated"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"isNodeToNodesInitiated"})," is true of node to nodes mapping is initiated."]}),"\n",(0,s.jsx)(n.h3,{id:"isextranodetonodesinitiated",children:"isExtraNodeToNodesInitiated"}),"\n",(0,s.jsx)(n.p,{children:"It is true if extra information of node to nodes is initiated. Extra node to nodes is necessary for edge based FEM."}),"\n",(0,s.jsx)(n.h3,{id:"iselementtoelementsinitiated",children:"isElementToElementsInitiated"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"isElementToElementsInitiated"})," is true if element to elements mapping available."]}),"\n",(0,s.jsx)(n.h3,{id:"isedgeconnectivityinitiated",children:"isEdgeConnectivityInitiated"}),"\n",(0,s.jsx)(n.p,{children:"If is true if edge connectivity is initiated."}),"\n",(0,s.jsx)(n.h3,{id:"isfaceconnectivityinitiated",children:"isFaceConnectivityInitiated"}),"\n",(0,s.jsx)(n.p,{children:"It is true when face connectivity is initiated."}),"\n",(0,s.jsx)(n.h3,{id:"isboundarydatainitiated",children:"isBoundaryDataInitiated"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"isBoundaryDataInitiated"})," is true if boundary data is available."]}),"\n",(0,s.jsx)(n.h3,{id:"isfacetdatainitiated",children:"isFacetDataInitiated"}),"\n",(0,s.jsx)(n.p,{children:"It is true when the facet data is initiated."}),"\n",(0,s.jsx)(n.h3,{id:"uid",children:"uid"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"uid"})," denotes the unique-id of the mesh. It is read from the mesh file, if present."]}),"\n",(0,s.jsx)(n.h3,{id:"xidim",children:"xidim"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"xidim"})," denotes the ",(0,s.jsx)(n.code,{children:"xidimension"})," of elements present inside the mesh, ",(0,s.jsx)(n.code,{children:"xidim"})," = (0,1,2,3) for (point, line, surface, volume) elements."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"telements_topology_wise",children:"tElements_topology_wise"}),"\n",(0,s.jsx)(n.p,{children:"It denotes the total number of elements present in the mesh. It is calculated in the post-processing step."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"index"}),(0,s.jsx)(n.th,{children:"element tyep"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"point"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"line"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"triangle"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"quadrangle"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:"tetrahedron"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"6"}),(0,s.jsx)(n.td,{children:"hexahedron"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"7"}),(0,s.jsx)(n.td,{children:"prism"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"8"}),(0,s.jsx)(n.td,{children:"pyramid"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"telemtopologies-and-elemtopologies",children:"tElemTopologies and elemTopologies"}),"\n",(0,s.jsxs)(n.p,{children:["Total number of topologies stored in the mesh. For example, in a mesh of lines, we will have ",(0,s.jsx)(n.code,{children:"tElemTopolies=1"}),". In the case of mesh of surfaces we can have ",(0,s.jsx)(n.code,{children:"tElemTopologies=2"}),". The name of the topolgoy is stored in ",(0,s.jsx)(n.code,{children:"elemTopologies(1:tElemTopolies)"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"maxnne",children:"maxNNE"}),"\n",(0,s.jsx)(n.p,{children:"Maximum number of nodes in an element."}),"\n",(0,s.jsx)(n.h3,{id:"nsd",children:"nsd"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"nsd"})," denotes the number of spatial dimension of the mesh."]}),"\n",(0,s.jsx)(n.h3,{id:"xidim-1",children:"xidim"}),"\n",(0,s.jsx)(n.p,{children:"The codimension of the mesh. It is 0 for point, 1 for line, 2 for surface, 3 for volume."}),"\n",(0,s.jsx)(n.h3,{id:"maxnptrs",children:"maxNptrs"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"maxNptrs"})," stands for the largest node number present inside the mesh."]}),"\n",(0,s.jsx)(n.h3,{id:"minnptrs",children:"minNptrs"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"minNptrs"})," stands for the smallest node number present inside the mesh."]}),"\n",(0,s.jsx)(n.h3,{id:"maxelemnum",children:"maxElemNum"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"maxElemNum"})," denotes the largest element number present inside the mesh."]}),"\n",(0,s.jsx)(n.h3,{id:"minelemnum",children:"minElemNum"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"minElemNum"})," denotes the smallest element number present inside the mesh."]}),"\n",(0,s.jsx)(n.h3,{id:"tnodes",children:"tNodes"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tNodes"})," is the total number of (local) nodes present inside the mesh."]}),"\n",(0,s.jsx)(n.h3,{id:"tedges",children:"tEdges"}),"\n",(0,s.jsx)(n.p,{children:"Total number of edges present inside the mesh."}),"\n",(0,s.jsx)(n.h3,{id:"tfaces",children:"tFaces"}),"\n",(0,s.jsx)(n.p,{children:"Total number of faces present inside the mesh."}),"\n",(0,s.jsx)(n.h3,{id:"telements",children:"tElements"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tElements"})," is the total number of elements present inside the mesh. It is the size of ",(0,s.jsx)(n.code,{children:"elemNumber"})," vector."]}),"\n",(0,s.jsx)(n.h3,{id:"minx-maxx-miny-maxy-minz-maxz",children:"minX, maxX, minY, maxY, minZ, maxZ"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"minX"})," denotes the minimum value of x coordinate of ",(0,s.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxX"})," denotes the maximum value of x coordinate of ",(0,s.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"minY"})," is the minimum value of y coordinate of ",(0,s.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxY"})," is the maximum value of y coordinate of ",(0,s.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"minZ"})," is the minimum value of z coordinate of ",(0,s.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxZ"})," is the maximum value of z coordinate of ",(0,s.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"x-y-z",children:"x, y, z"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"x"})," is the x coordinate of center of mesh."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"y"})," is the y coordinate of center of mesh."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"z"})," is the z coordinate of center of mesh."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"boundingentity",children:"boundingEntity"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"boundingEntity"})," denotes the bounding entity numbers of the current entity"]}),"\n",(0,s.jsx)(n.h3,{id:"local_elemnumber-and-local_nptrs",children:"local_elemNumber and local_Nptrs"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"local_elemNumber"})," denotes the list of local element numbers, the lower bound is ",(0,s.jsx)(n.code,{children:"minElemNum"})," and upper bound is ",(0,s.jsx)(n.code,{children:"maxElemNum"}),". In this way, ",(0,s.jsx)(n.code,{children:"local_elemNumber(iel)"})," returns the local element number of global element number ",(0,s.jsx)(n.code,{children:"iel"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"local_Nptrs"})," returns the local node number from a global node number. Its length is from 1 to ",(0,s.jsx)(n.code,{children:"maxNptrs"}),". Helpful in finding if a global node is present inside the mesh or not."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"quality",children:"quality"}),"\n",(0,s.jsx)(n.p,{children:"Denotes the quality of elements."}),"\n",(0,s.jsx)(n.h3,{id:"facetelementtype",children:"facetElementType"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Number of rows of this array is same as the total number of facets present in the mesh\u2019s reference-element."}),"\n",(0,s.jsx)(n.li,{children:"Number of columns of this array is equal to the total number of elements inside the mesh."}),"\n",(0,s.jsxs)(n.li,{children:["In this way, ",(0,s.jsx)(n.code,{children:"facetElementType(ii, iel)"})," denotes the ",(0,s.jsx)(n.code,{children:"ii"}),"th facet\u2019s type of element local element number ",(0,s.jsx)(n.code,{children:"iel"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"facetElementType"})," can be","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"INTERNAL_ELEMENT"}),","]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BOUNDARY_ELEMENT"}),","]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DOMAIN_BOUNDARY_ELEMENT"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["If the face is a part of the mesh boundary then it will be called the ",(0,s.jsx)(n.code,{children:"BOUNDARY_ELEMENT"})]}),"\n",(0,s.jsxs)(n.li,{children:["If the face is part of domain boundary, then it is a ",(0,s.jsx)(n.code,{children:"DOMAIN_BOUNDARY_ELEMENT"})]}),"\n",(0,s.jsxs)(n.li,{children:["If the facet is internal to a mesh, then it is a ",(0,s.jsx)(n.code,{children:"INTERNAL_ELEMENT"})]}),"\n",(0,s.jsxs)(n.li,{children:["Note that every, ",(0,s.jsx)(n.code,{children:"DOMAIN_BOUNDARY_ELEMENT"})," is ",(0,s.jsx)(n.code,{children:"BOUNDARY_ELEMENT"})," but not vice-versa."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"nodedata",children:"nodeData"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"nodeData"})," node data"]}),"\n",(0,s.jsx)(n.h3,{id:"elementdata",children:"elementData"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"elementData"})," element data"]}),"\n",(0,s.jsx)(n.h3,{id:"internalfacetdata",children:"internalFacetData"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"internalFacetData"})," internal facet data"]}),"\n",(0,s.jsx)(n.h3,{id:"boundaryfacetdata",children:"boundaryFacetData"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"boundaryFacetData"})," boundary facet Data"]}),"\n",(0,s.jsx)(n.h3,{id:"elementdatalist",children:"elementDataList"}),"\n",(0,s.jsx)(n.p,{children:"Linked list of element data"}),"\n",(0,s.jsx)(n.h3,{id:"elementdatabinarytree",children:"elementDataBinaryTree"}),"\n",(0,s.jsx)(n.p,{children:"Binary tree of element data."}),"\n",(0,s.jsx)(n.h3,{id:"nodedatalist",children:"nodeDataList"}),"\n",(0,s.jsx)(n.p,{children:"Linked list of node data"}),"\n",(0,s.jsx)(n.h3,{id:"nodedatabinarytree",children:"nodeDataBinaryTree"}),"\n",(0,s.jsx)(n.p,{children:"Binary tree of node data."})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},54213:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var t=i(36672);const s={},d=t.createContext(s);function l(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);