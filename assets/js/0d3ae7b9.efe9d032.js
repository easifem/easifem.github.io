"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[41660],{84981:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>m,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"AbstractBC/ImportFromToml","title":"ImportFromToml","description":"Initiate an instance of AbstractBC_ from toml configuration.","source":"@site/docs/docs-api/AbstractBC/ImportFromToml.md","sourceDirName":"AbstractBC","slug":"/AbstractBC/ImportFromToml","permalink":"/docs-api/AbstractBC/ImportFromToml","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AbstractBC/ImportFromToml.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Import","permalink":"/docs-api/AbstractBC/Import"},"next":{"title":"Initiate","permalink":"/docs-api/AbstractBC/Initiate"}}');var i=o(23420),a=o(54213);const s={},r="ImportFromToml",m={},l=[{value:"Interface 1",id:"interface-1",level:2},{value:"Interface 2",id:"interface-2",level:2},{value:"TOML configuration",id:"toml-configuration",level:2}];function c(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...n.components},{Details:o}=e;return o||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"importfromtoml",children:"ImportFromToml"})}),"\n",(0,i.jsxs)(e.p,{children:["Initiate an instance of ",(0,i.jsx)(e.code,{children:"AbstractBC_"})," from toml configuration."]}),"\n",(0,i.jsx)(e.h2,{id:"interface-1",children:"Interface 1"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-fortran",children:"INTERFACE AbstractBCImportFromToml\n  MODULE SUBROUTINE bc_ImportFromToml1(obj, table, dom)\n    CLASS(AbstractBC_), INTENT(INOUT) :: obj\n    TYPE(toml_table), INTENT(INOUT) :: table\n    CLASS(Domain_), TARGET, INTENT(IN) :: dom\n  END SUBROUTINE bc_ImportFromToml1\nEND INTERFACE AbstractBCImportFromToml\n"})}),"\n",(0,i.jsx)(e.admonition,{type:"info",children:(0,i.jsx)(e.p,{children:"This method is mainly for internal use."})}),"\n",(0,i.jsx)(e.h2,{id:"interface-2",children:"Interface 2"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-fortran",children:"INTERFACE AbstractBCImportFromToml\n  MODULE SUBROUTINE bc_ImportFromToml2(obj, dom, tomlName, afile,  &\n    & filename, printToml)\n    CLASS(AbstractBC_), INTENT(INOUT) :: obj\n    CLASS(Domain_), TARGET, INTENT(IN) :: dom\n    CHARACTER(*), INTENT(IN) :: tomlName\n    TYPE(TxtFile_), OPTIONAL, INTENT(INOUT) :: afile\n    CHARACTER(*), OPTIONAL, INTENT(IN) :: filename\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: printToml\n  END SUBROUTINE bc_ImportFromToml2\nEND INTERFACE AbstractBCImportFromToml\n"})}),"\n",(0,i.jsx)(e.h2,{id:"toml-configuration",children:"TOML configuration"}),"\n",(0,i.jsxs)(o,{children:[(0,i.jsx)("summary",{children:"Click here to see the toml-configuration file"}),(0,i.jsx)("div",{children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-toml",children:'[bc]\nname = "DirichletBC"\n# Name of the boundary condition\nidof = 1\n# idof denotes the degree of freedom where\n# we apply the contraint,\n# For x component idof is 1\n# For y component idof is 2\n# For z component idof is 3\n\nnodalValueType = "Constant" # Time, SpaceTime, Space\n# Other option: Constant, Time, Space,  SpaceTime\n# nodalValuetype denotes the type of boundary condition\n# It can take following values\n# Constant: It means the boundary condition is constant in\n#           space and time.\n# Space:    It means the boundary condition is variable in\n#           space but constant in time.\n# Time:     It means the boundary condition is variable in\n#           in time but constant in Space\n# SpaceTime:It means the boundary condition is variable in\n#           both space and time.\n\nvalue = 20.0\n# Value of boundary condition\n# The shape of value depends upon the nodalValueType as explained below.\n# For nodalValueType="Constant", value should be a scalar real value\n# For nodalValueType="Space", value should be a vector of real values\n# value=[1.0, 2.0, 3.0, 4.0]\n# For nodalValueType="Time", value should  be a vector of real values\n# value=[1.0, 2.0, 3.0, 4.0]\n# For nodalValueType="SpaceTime", value should be two dimensional array of\n# real values\n# value=[[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0]]\n\nisUserFunction = false\nisNormal = false\nisTangent = false\nuseExternal = false\n\n[bc.function]\nname = "boundaryFunction"\n# name of the function\n\nreturnType = "Scalar"\n# returnType must be "Scalar"\n\nnumReturns = 1\n# number of returns must be 1\n\nargType = "Space"\n# argumen type of function, It can take following values\n# "Constant", when the user function is constant\n# "Space", when the user function is space dependent only.\n# "Time", when the user function is time dependent only.\n# "SpaceTime", when the user function is space-time dependent.\n\nnumArgs = 3\n# number of arguments\n# number of arguments should be 0, when argType is "Constant"\n# number of arguments should be 1, when argType is "Time"\n# number of arguments should be 3, when argType is "Space"\n# number of arguments should be 4, when argType is "SpaceTime"\n\nvalue = 1.0\n# if lua script and luaFunctionName are absent then this\n# variable must be given.\n# When this is given, then argType must be Constant, and\n# numArgs should be 0.\n\nluaScript = "./hello.lua"\n# name of the lua script which contains the functions\n\nluaFunctionName = "hello"\n# which function in the lua script to be used for boundary condition\n\n[bc.boundary]\nisSelectionByMeshID = false\n# set isSelectionByMeshID to true when mesh selection is by meshID\n# if this variable is set to true then we should provide following\n# table\n[bc.boundary.meshID]\npoint = [1, 2, 3]\n# id of mesh of points\n# you can also give the filename\nline = [1, 2, 3, 4]\n# id of mesh of lines\n# you can also give the filename\nsurface = [1, 2, 3]\n# id of mesh of surfaces\n# you can also give the filename "filename.txt"\nvolume = [1, 2, 3]\n# id of mesh of volumes\n# you can also give the filename "filename.txt"\n\nisSelectionByElemNum = false\n# set isSelectionByElemNum to true when mesh selection is by\n# specifying element number\n# if this variable is set to true then we should provide following\n# table\n[bc.boundary.elemNum]\npoint = [1, 2, 3]\n# element number for points\nline = [1, 2, 3]\n# element number of lines\nsurface = [1, 2, 3]\n# element number of surfaces\nvolume = [1, 2, 3]\n# element number of volume\n\nisSelectionByBox = false\n# set isSelectionByBox to true when mesh selection is by\n# specifying the bounding boxes\n# if this variable is set to true then we should provide following\n# table\n[bc.boundary.box]\npoint = [\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 0.0, zmax = 1.0 },\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 2.0, zmax = 3.0 },\n]\n# boxes for mesh of points\nline = [\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 0.0, zmax = 1.0 },\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 2.0, zmax = 3.0 },\n]\n# boxes for mesh of lines\nsurface = [\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 0.0, zmax = 1.0 },\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 2.0, zmax = 3.0 },\n]\n# boxes for mesh of surfaces\nvolume = [\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 0.0, zmax = 1.0 },\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 2.0, zmax = 3.0 },\n]\n# boxes for mesh of volumes\n\nisSelectionByNodeNum = false\n# set isSelectionByNodeNum to true when mesh selection is by\n# by specifying the node number.\n# if this variable is set to true then we should provide following\n# table\n[bc.boundary.nodeNum]\npoint = [1, 2, 3]\nline = [1, 2, 3]\nsurface = [1, 2, 3]\nvolume = [1, 2, 3]\n'})})})]})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},54213:(n,e,o)=>{o.d(e,{R:()=>s,x:()=>r});var t=o(36672);const i={},a=t.createContext(i);function s(n){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);