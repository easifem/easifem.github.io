"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[43711],{68645:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"AbstractKernel/KernelMaterials","title":"KernelMaterials","description":"This class contains the materials of the kernel.","source":"@site/docs/docs-api/AbstractKernel/KernelMaterials.md","sourceDirName":"AbstractKernel","slug":"/AbstractKernel/KernelMaterials","permalink":"/docs-api/AbstractKernel/KernelMaterials","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AbstractKernel/KernelMaterials.md","tags":[],"version":"current","lastUpdatedAt":1735776220000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"KernelInitiateTangentMatrix","permalink":"/docs-api/AbstractKernel/KernelInitiateTangentMatrix"},"next":{"title":"KernelMeshFields","permalink":"/docs-api/AbstractKernel/KernelMeshFields"}}');var r=a(23420),i=a(54213);const s={},l="KernelMaterials",o={},c=[];function d(e){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"kernelmaterials",children:"KernelMaterials"})}),"\n",(0,r.jsx)(t.p,{children:"This class contains the materials of the kernel."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-fortran",children:"TYPE :: KernelMaterials_\n  LOGICAL(LGT) :: isConstantMatProp = .FALSE.\n  !! Set it to True if the material properties are constant\n\n  LOGICAL(LGT) :: isIsotropic = .FALSE.\n  !! Set it to True for isotropic medium\n\n  LOGICAL(LGT) :: isIncompressible = .FALSE.\n  !! TRUE if the material is incompressible\n\n  LOGICAL(LGT) :: isMaterialInterface = .FALSE.\n  !! True if materialInterfaces are allocated.\n  !! We can have multiple solids\n\n  INTEGER(I4B) :: tOverlappedMaterials = 1\n  !! Total overlapped materials (like fluid, soil, solid)\n\n  INTEGER(I4B) :: tSolidMaterials = 0\n  !! Total number of solid materials\n\n  INTEGER(I4B) :: SOLID_MATERIAL_ID = 0\n  !! solid material id\n\n  INTEGER(I4B) :: tMaterialInterfaces = 0\n  !! total number of material interfaces\n\n  TYPE(SolidMaterialPointer_), ALLOCATABLE :: solidMaterial(:)\n  !! Pointer to the solid material\n\n  TYPE(MeshSelection_), ALLOCATABLE :: solidMaterialToMesh(:)\n  !! Map solid material to the mesh portion\n  !! The size of solidMaterialToMesh is the same as `tSolidMaterials`\n  !! In this way, solidMaterialToMesh(i) gives the mesh region of ith element\n\n  TYPE(DomainConnectivity_), ALLOCATABLE :: matIfaceConnectData(:)\n  !! facet to cell data for each materialInterface mesh\n  !! The size of matIfaceConnectData is same as the size of\n  !! materialInterfaces\n\n  INTEGER(I4B), ALLOCATABLE :: materialInterfaces(:)\n  !! mesh id of material interfaces\n\nEND TYPE KernelMaterials_\n"})})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},54213:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>l});var n=a(36672);const r={},i=n.createContext(r);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);