"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[32237],{3971:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"CSRMatrix/MatrixMarketCoordinate","title":"Matrix Market Coordinate","description":"Reference","source":"@site/docs/docs-api/CSRMatrix/MatrixMarketCoordinate.md","sourceDirName":"CSRMatrix","slug":"/CSRMatrix/MatrixMarketCoordinate","permalink":"/docs-api/CSRMatrix/MatrixMarketCoordinate","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/CSRMatrix/MatrixMarketCoordinate.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"MatVec","permalink":"/docs-api/CSRMatrix/MatVec"},"next":{"title":"Permute","permalink":"/docs-api/CSRMatrix/Permute"}}');var i=t(23420),a=t(54213);const s={},o="Matrix Market Coordinate",c={},d=[{value:"Header",id:"header",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"matrix-market-coordinate",children:"Matrix Market Coordinate"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://math.nist.gov/MatrixMarket/formats.html#MMformat",children:"Reference"})}),"\n",(0,i.jsx)(n.p,{children:"This is the native exchange format for the Matrix Market."}),"\n",(0,i.jsx)(n.p,{children:"The Matrix Market (MM) exchange formats provide a simple mechanism to facilitate the exchange of matrix data. In particular, the objective has been to define a minimal base ASCII file format which can be very easily explained and parsed, but can easily adapted to applications with a more rigid structure, or extended to related data objects. The MM exchange format for matrices is really a collection of affiliated formats which share design elements. In our initial specification, two matrix formats are defined."}),"\n",(0,i.jsx)(n.p,{children:"A file format suitable for representing general sparse matrices. Only nonzero entries are provided, and the coordinates of each nonzero entry is given explicitly. This is illustrated in the example below."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Comment starts with ",(0,i.jsx)(n.code,{children:"%"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Consider the following ",(0,i.jsx)(n.code,{children:"5x5"})," matrix:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-txt",children:"1    0      0       6      0     \n0   10.5    0       0      0     \n0    0    .015      0      0     \n0  250.5    0     -280    33.32  \n0    0      0       0     12  \n"})}),"\n",(0,i.jsx)(n.p,{children:"In MM coordinate format this could be represented as follows."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-txt",children:"%%MatrixMarket matrix coordinate real general \n%=================================================================================\n%\n% This ASCII file represents a sparse MxN matrix with L \n% nonzeros in the following Matrix Market format:\n%\n% Indices are 1-based, i.e. A(1,1) is the first element.\n%\n%=================================================================================\n  5  5  8\n    1     1   1.000e+00\n    2     2   1.050e+01\n    3     3   1.500e-02\n    1     4   6.000e+00\n    4     2   2.505e+02\n    4     4  -2.800e+02\n    4     5   3.332e+01\n    5     5   1.200e+01\n"})}),"\n",(0,i.jsx)(n.h3,{id:"header",children:"Header"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-txt",children:"%%MatrixMarket ${1} ${2} ${3} ${4} ${5}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"${2}=matrix"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"${3}=coorindate|array"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"${4}=real|integer|complex|pattern|"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"${5}=general|symmetric|skew-symmetric|Hermitian"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The first line contains the type code. In this example, it indicates that the object being represented is a ",(0,i.jsx)(n.code,{children:"matrix"})," in ",(0,i.jsx)(n.code,{children:"coordinate"})," format and that the numeric data following is ",(0,i.jsx)(n.code,{children:"real"})," and represented in ",(0,i.jsx)(n.code,{children:"general"})," form. (By general we mean that the matrix format is not taking advantage of any symmetry properties.)"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Variants of the coordinate format are defined for matrices with complex and integer entries, as well as for those in which only the position of the nonzero entries is prescribed (pattern matrices). (These would be indicated by changing real to complex, integer, or pattern, respectively, on the header line)."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Additional variants are defined for cases in which symmetries can be used to significantly reduce the size of the data: symmetric, skew-symmetric and Hermitian. In these cases, only entries in the lower triangular portion need be supplied. In the skew-symmetric case the diagonal entries are zero, and hence they too are omitted. (These would be indicated by changing general to symmetric, skew-symmetric, or hermitian, respectively, on the header line)."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},54213:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(36672);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);