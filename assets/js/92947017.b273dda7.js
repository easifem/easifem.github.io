"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[62892],{69215:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"TriangleInterface/definition","title":"Definitions related to triangulation","description":"A Delaunay triangulation of a vertex set is a triangulation of the vertex set with the property that no vertex in the vertex set falls in the interior of the circumcircle (circle that passes through all three vertices) of any triangle in the triangulation.","source":"@site/docs/docs-api/TriangleInterface/definition.md","sourceDirName":"TriangleInterface","slug":"/TriangleInterface/definition","permalink":"/docs-api/TriangleInterface/definition","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/TriangleInterface/definition.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Boundary markers","permalink":"/docs-api/TriangleInterface/boundaryMarkers"},"next":{"title":"edge file","permalink":"/docs-api/TriangleInterface/edge"}}');var a=n(23420),o=n(54213);const r={},s="Definitions related to triangulation",l={},c=[];function d(e){const t={admonition:"admonition",h1:"h1",header:"header",img:"img",p:"p",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"definitions-related-to-triangulation",children:"Definitions related to triangulation"})}),"\n",(0,a.jsx)(t.admonition,{title:"Delaunay triangulation",type:"note",children:(0,a.jsx)(t.p,{children:"A Delaunay triangulation of a vertex set is a triangulation of the vertex set with the property that no vertex in the vertex set falls in the interior of the circumcircle (circle that passes through all three vertices) of any triangle in the triangulation."})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{src:"https://www.cs.cmu.edu/~quake/dots.node.gif",alt:"nodes"}),"\n",(0,a.jsx)(t.img,{src:"https://www.cs.cmu.edu/~quake/dots.1.ele.gif",alt:"Delaunay"})]}),"\n",(0,a.jsx)(t.admonition,{title:"Voronoi diagram",type:"note",children:(0,a.jsx)(t.p,{children:"A Voronoi diagram of a vertex set is a subdivision of the plane into polygonal regions (some of which may be infinite), where each region is the set of points in the plane that are closer to some input vertex than to any other input vertex. (The Voronoi diagram is the geometric dual of the Delaunay triangulation.)"})}),"\n",(0,a.jsx)(t.admonition,{title:"PSLG",type:"note",children:(0,a.jsx)(t.p,{children:"A Planar Straight Line Graph (PSLG) is a collection of vertices and segments. Segments are edges whose endpoints are vertices in the PSLG, and whose presence in any mesh generated from the PSLG is enforced."})}),"\n",(0,a.jsx)(t.admonition,{title:"Conforming Delaunay triangulation",type:"note",children:(0,a.jsx)(t.p,{children:"A conforming Delaunay triangulation (CDT) of a PSLG is a true Delaunay triangulation in which each PSLG segment may have been subdivided into several edges by the insertion of additional vertices, called Steiner points. Steiner points are necessary to allow the segments to exist in the mesh while maintaining the Delaunay property. Steiner points are also inserted to meet constraints on the minimum angle and maximum triangle area."})}),"\n",(0,a.jsx)(t.admonition,{title:"Constrained conforming Delaunay triangulation",type:"note",children:(0,a.jsx)(t.p,{children:"A constrained conforming Delaunay triangulation (CCDT) of a PSLG is a constrained Delaunay triangulation that includes Steiner points. It usually takes fewer vertices to make a good-quality CCDT than a good-quality CDT, because the triangles do not need to be Delaunay (although they still must be constrained Delaunay)."})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},54213:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var i=n(36672);const a={},o=i.createContext(a);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);