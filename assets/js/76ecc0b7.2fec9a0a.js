"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[13344],{91590:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"AbstractKernel/KernelOpt","title":"KernelOpt","description":"This class contains the options for the kernel.","source":"@site/docs/docs-api/AbstractKernel/KernelOpt.md","sourceDirName":"AbstractKernel","slug":"/AbstractKernel/KernelOpt","permalink":"/docs-api/AbstractKernel/KernelOpt","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AbstractKernel/KernelOpt.md","tags":[],"version":"current","lastUpdatedAt":1735776220000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"KernelMeshFields","permalink":"/docs-api/AbstractKernel/KernelMeshFields"},"next":{"title":"PostCheckError","permalink":"/docs-api/AbstractKernel/PostCheckError"}}');var r=t(23420),s=t(54213);const a={},l="KernelOpt",o={},d=[{value:"Structure",id:"structure",level:2},{value:"isInitiated",id:"isinitiated",level:3},{value:"isCommonDomain",id:"iscommondomain",level:3},{value:"showTime",id:"showtime",level:3},{value:"unifyVTK",id:"unifyvtk",level:3},{value:"createPVD",id:"createpvd",level:3},{value:"problemType",id:"problemtype",level:3},{value:"algorithm",id:"algorithm",level:3},{value:"vtkOutputFreq",id:"vtkoutputfreq",level:3},{value:"hdfOutputFreq",id:"hdfoutputfreq",level:3},{value:"coordinateSystem",id:"coordinatesystem",level:3},{value:"maxIter",id:"maxiter",level:3},{value:"timeDependency",id:"timedependency",level:3},{value:"nsd",id:"nsd",level:3},{value:"nnt",id:"nnt",level:3},{value:"tdof",id:"tdof",level:3},{value:"postProcessOpt",id:"postprocessopt",level:3},{value:"currentTimeStep",id:"currenttimestep",level:3},{value:"totalTimeStep",id:"totaltimestep",level:3},{value:"normRHS",id:"normrhs",level:3},{value:"dt",id:"dt",level:3},{value:"startTime",id:"starttime",level:3},{value:"endTime",id:"endtime",level:3},{value:"lengthScale",id:"lengthscale",level:3},{value:"gravity",id:"gravity",level:3},{value:"incrementScale",id:"incrementscale",level:3},{value:"dispError, velError, solError, resError",id:"disperror-velerror-solerror-reserror",level:3},{value:"name",id:"name",level:3},{value:"engine",id:"engine",level:3},{value:"tanmatProp",id:"tanmatprop",level:3},{value:"tanmatName",id:"tanmatname",level:3},{value:"outputPath",id:"outputpath",level:3},{value:"domainFile",id:"domainfile",level:3},{value:"basisForSpace, basisForTime, basisForPressure, basisForVelocity",id:"basisforspace-basisfortime-basisforpressure-basisforvelocity",level:3},{value:"iterData",id:"iterdata",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"kernelopt",children:"KernelOpt"})}),"\n",(0,r.jsx)(n.p,{children:"This class contains the options for the kernel."}),"\n",(0,r.jsx)(n.p,{children:"The structure of this class is given below."}),"\n",(0,r.jsx)(n.h2,{id:"structure",children:"Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-fortran",children:"TYPE KernelOpt_\n  LOGICAL(LGT) :: isInitiated = .FALSE.\n  !! This variable is Set to true when we initiate the kernel\n\n  LOGICAL(LGT) :: isCommonDomain = .TRUE.\n  !! This variable is True when the domain is common.\n  !! It is useful in the case of multi-physics simulations.\n  !! In multi-physics applications different fields can have different\n  !! type and order of shape functions. To construct such shape functions\n  !! we may have to use different finite element meshes (hence, domains).\n  !! For example, in the fluid mechanics, we often use Taylor-Hood element\n  !! Which employs different order of interpolation for pressure and velocity.\n\n  LOGICAL(LGT) :: showTime = .FALSE.\n  !! If it is set to true then we create a file called\n  !! KernelName_time_stat.csv\n  !! This file contains the statics of time taken by the kernel\n  !! It will be helpful in improving the kernel\n\n  LOGICAL(LGT) :: unifyVTK = .FALSE.\n  !! if it is true all data are exported into one vtu file\n  !! in WriteData_vtk method\n\n  LOGICAL(LGT) :: createPVD = .FALSE.\n  !! if true paraview data file is created\n  !! in WriteData_vtk method\n\n  INTEGER(I4B) :: problemType = TypeKernelProblemOpt%scalar\n  !! Kernel problem type\n  !! TypeKernelProblemOpt%scalar\n  !! TypeKernelProblemOpt%Vector\n  !! TypeKernelProblemOpt%MultiPhysics\n\n  INTEGER(I4B) :: algorithm = 1\n  !! algorithm\n\n  INTEGER(I4B) :: vtkOutputFreq = 0\n  !! frequency of output with WriteData_vtk\n\n  INTEGER(I4B) :: hdfOutputFreq = 0\n  !! frequency of output with WriteData_hdf\n\n  INTEGER(I4B) :: coordinateSystem = TypeKernelCoordOpt%default\n  !! Spatial coordinate system type. It can take following values\n  !! `KERNEL_CARTESIAN` for Cartesian coordinates\n  !! `KERNEL_CYLINDRICAL` for Cylinderical coordinates\n  !! `KERNEL_SPHERICAL` for Sperical coordinates\n  !! NOTE: These parameters are defined in the AbstractKernelParam module.\n\n  INTEGER(I4B) :: maxIter = 100\n  !! Maximum  number of iteration iterations\n  !! This is useful when when we use iterative solvers like\n  !! Newton method, Modified Newton method, or Iterative-predictor solvers.\n  !! NOTE: DEFAULT_maxIter is defined in AbstractKernelParam\n\n  INTEGER(I4B) :: timeDependency = TypeKernelTimeOpt%default\n  !! This variable indicates if the problem is time dependent or not.\n  !! It can take following values:\n  !! KERNEL_STEADY  or KERNEL_STATIC\n  !! KERNEL_PSEUDOSTATIC\n  !! KERNEL_TRANSIENT or KERNEL_DYNAMIC\n  !! NOTE: These variables are defined in AbstractKernelParam\n\n  INTEGER(I4B) :: nsd = 0\n  !! Spatial dimension of the problem,\n\n  INTEGER(I4B) :: nnt = 1\n  !! Number of nodes in time element\n  !! NOTE: This variables is used only in space-time finite element methods\n\n  INTEGER(I4B) :: tdof = 0\n  !! Total number of degree of freedom per node\n  !! NOTE: This variable is Set internally by each kernel while\n  !! Setting the kernel.\n\n  INTEGER(I4B) :: postProcessOpt = 1\n  !! Postprocessing options\n  !! INFO: The actual action depends upon the specific kernels\n\n  INTEGER(I4B) :: currentTimeStep = 1\n  !! Current time step number of the simulation.\n  !! NOTE: This varible is needed in the transient simulation only.\n\n  INTEGER(I4B) :: totalTimeStep = 0\n  !! Total number of time step number in the simulation.\n  !! NOTE: This varible is needed in the transient simulation only.\n\n  ! Reals\n\n  REAL(DFP) :: normRHS = 0.0_DFP\n  !! norm of the right-hand-side vector in the system of linear equations\n  !! NOTE: This variable is used internally\n\n  REAL(DFP) :: dt = 0.0_DFP\n  !! Time step size used in the pseudostatic and dynamic problems\n  !! Needed in transient case\n\n  REAL(DFP) :: startTime = 0.0\n  !! Starting time of simulation\n  !! NOTE: This varible is needed in the transient or pseudostatic simulation\n\n  REAL(DFP) :: endTime = 0.0\n  !! Final time of the simulation\n  !! NOTE: This varible is needed in the transient or pseudostatic simulation\n\n  REAL(DFP) :: currentTime = 0.0\n  !! The current time of the simulation\n  !! NOTE: This varible is needed in the transient simulation only.\n\n  REAL(DFP) :: lengthScale = 1.0_DFP\n  !! This variable denotes the length scale of the problem.\n  !! NOTE: This variable is for internal use only.\n\n  REAL(DFP) :: gravity(3) = 0.0_DFP\n  !! Acceleration vector due to gravity\n\n  REAL(DFP) :: incrementScale = 1.0_DFP\n  !! x = x + incrementScale * displacement\n\n  TYPE(KernelErrorOpt_) :: dispError\n  !! Displacement error\n\n  TYPE(KernelErrorOpt_) :: velError\n  !! Velocity error\n\n  TYPE(KernelErrorOpt_) :: solError\n  !! solution error\n\n  TYPE(KernelErrorOpt_) :: resError\n  !! Residual error\n\n  TYPE(String) :: name\n  !! This is the name of the kernel. It can be anything you want.\n\n  TYPE(String) :: engine\n  !! Which type of linear solver library (engine) we use to\n  !! solve system of linear equations. We can specify following\n  !! values.\n  !! `NATIVE_SERIAL`, `NATIVE_OMP`, `NATIVE_MPI`, `LIS_SERIAL`\n  !! `LIS_OMP`, `LIS_MPI`, `PETSC`\n\n  TYPE(String) :: tanmatProp\n  !! Symmetric or Unsymmetric tangent matrix\n\n  TYPE(String) :: tanmatName\n  !! MATRIX\n  !! BLOCKMATRIX\n\n  TYPE(String) :: outputPath\n  !! Path to put output files\n  !! Default is results\n\n  TYPE(String) :: domainFile\n  !! domain file name\n\n  TYPE(KernelBasisOpt_) :: basisForSpace\n  !! Basis function option for space\n\n  TYPE(KernelBasisOpt_) :: basisForTime\n  !! Basis function option for time\n\n  TYPE(KernelBasisOpt_) :: basisForPressure\n  !! Basis function option for pressure\n\n  TYPE(KernelBasisOpt_) :: basisForVelocity\n  !! Basis function option for velocity\n\n  TYPE(IterationData_) :: iterData\n  !! Iteration data\n  !! INFO: The actual action depends upon the specific kernels\n\nEND TYPE KernelOpt_\n"})}),"\n",(0,r.jsx)(n.h3,{id:"isinitiated",children:"isInitiated"}),"\n",(0,r.jsx)(n.p,{children:"This logical variable is set to true when we initiate the kernel."}),"\n",(0,r.jsx)(n.h3,{id:"iscommondomain",children:"isCommonDomain"}),"\n",(0,r.jsx)(n.p,{children:"This variable is True when the domain is common, that is, all physical variables are defined on the same domain."}),"\n",(0,r.jsx)(n.p,{children:"This variable is usually set to false in the multi-physics applications. In multi-physics applications different fields can have different type and order of shape functions. To construct such shape functions we may have to use different finite element meshes (hence, domains). For example, in the fluid mechanics, we often use Taylor-Hood element\nwhich employs different order of interpolation for pressure and velocity."}),"\n",(0,r.jsx)(n.h3,{id:"showtime",children:"showTime"}),"\n",(0,r.jsxs)(n.p,{children:["If it is set to true then we create a file called ",(0,r.jsx)(n.code,{children:"KernelName_time_stat.csv"}),". This file contains the statics of time taken by the kernel. It will be helpful in improving the kernel."]}),"\n",(0,r.jsx)(n.h3,{id:"unifyvtk",children:"unifyVTK"}),"\n",(0,r.jsxs)(n.p,{children:["If it is true then all the data are exported into one vtu file in ",(0,r.jsx)(n.code,{children:"WriteData_vtk"})," method."]}),"\n",(0,r.jsx)(n.h3,{id:"createpvd",children:"createPVD"}),"\n",(0,r.jsxs)(n.p,{children:["If it is true then a Paraview data file is created in ",(0,r.jsx)(n.code,{children:"WriteData_vtk"})," method."]}),"\n",(0,r.jsx)(n.h3,{id:"problemtype",children:"problemType"}),"\n",(0,r.jsx)(n.p,{children:"This variable is an integer code for the type of problem kernel is designed to solve. For example, scale, vector, or multi-physics problem."}),"\n",(0,r.jsxs)(n.p,{children:["You can access these variables from a global variable called ",(0,r.jsx)(n.code,{children:"TypeKernelProblemOpt"}),", for example see ",(0,r.jsx)(n.a,{href:"/docs-api/AbstractKernel/AbstractKernelParam",children:"AbstractKernelParam"})]}),"\n",(0,r.jsx)(n.h3,{id:"algorithm",children:"algorithm"}),"\n",(0,r.jsx)(n.p,{children:"This integer variable depends upon the kernel, and it denotes the specific algorithm used in the kernel."}),"\n",(0,r.jsx)(n.h3,{id:"vtkoutputfreq",children:"vtkOutputFreq"}),"\n",(0,r.jsxs)(n.p,{children:["This integer variable denotes the frequency of output with ",(0,r.jsx)(n.code,{children:"WriteData_vtk"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"hdfoutputfreq",children:"hdfOutputFreq"}),"\n",(0,r.jsxs)(n.p,{children:["This integer variable denotes the frequency of output with ",(0,r.jsx)(n.code,{children:"WriteData_hdf"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"coordinatesystem",children:"coordinateSystem"}),"\n",(0,r.jsxs)(n.p,{children:["This integer variable denotes the coordinate system in which the kernel solves the problem. Its value are defined in a global variable called ",(0,r.jsx)(n.code,{children:"TypeKernelCoordOpt"}),", which is defined in ",(0,r.jsx)(n.a,{href:"/docs-api/AbstractKernel/AbstractKernelParam",children:"AbstractKernelParam"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"maxiter",children:"maxIter"}),"\n",(0,r.jsx)(n.p,{children:"This integer variable denotes the maximum number of iterations. This is useful when we use iterative solvers like Newton method, Modified Newton method, or Iterative-predictor solvers."}),"\n",(0,r.jsx)(n.h3,{id:"timedependency",children:"timeDependency"}),"\n",(0,r.jsxs)(n.p,{children:["This integer variable denoted the time dependency of the kernel problem. Its values are defined in the global variable called ",(0,r.jsx)(n.code,{children:"TypeKernelTimeOpt"})," which is defined in the ",(0,r.jsx)(n.a,{href:"/docs-api/AbstractKernel/AbstractKernelParam",children:"AbstractKernelParam"})]}),"\n",(0,r.jsx)(n.h3,{id:"nsd",children:"nsd"}),"\n",(0,r.jsx)(n.p,{children:"This integer variable denotes the spatial dimension of the problem that the kernel solves."}),"\n",(0,r.jsx)(n.h3,{id:"nnt",children:"nnt"}),"\n",(0,r.jsx)(n.p,{children:"This integer variable denotes the number of time nodes in the space-time finite element method."}),"\n",(0,r.jsx)(n.h3,{id:"tdof",children:"tdof"}),"\n",(0,r.jsx)(n.p,{children:"This integer variable denotes the total number of degrees of freedom per node in the problem.\nThis variable is set by the kernel internally white setting the kernel."}),"\n",(0,r.jsx)(n.h3,{id:"postprocessopt",children:"postProcessOpt"}),"\n",(0,r.jsx)(n.p,{children:"This integer variable denotes the post-processing option. The actual action depends upon the specific kernels."}),"\n",(0,r.jsx)(n.h3,{id:"currenttimestep",children:"currentTimeStep"}),"\n",(0,r.jsx)(n.p,{children:"This integer variable denotes the current time step of the kernel. It is often used in the transient simulation."}),"\n",(0,r.jsx)(n.h3,{id:"totaltimestep",children:"totalTimeStep"}),"\n",(0,r.jsx)(n.p,{children:"This integer variable denotes the total number of time steps."}),"\n",(0,r.jsx)(n.h3,{id:"normrhs",children:"normRHS"}),"\n",(0,r.jsx)(n.p,{children:"This real variable stores the current norm of RHS."}),"\n",(0,r.jsx)(n.h3,{id:"dt",children:"dt"}),"\n",(0,r.jsx)(n.p,{children:"This real variable contains the current time step size."}),"\n",(0,r.jsx)(n.h3,{id:"starttime",children:"startTime"}),"\n",(0,r.jsx)(n.p,{children:"This real variable contains the starting time of the kernel."}),"\n",(0,r.jsx)(n.h3,{id:"endtime",children:"endTime"}),"\n",(0,r.jsx)(n.p,{children:"This real variable contains the final time of the kernel."}),"\n",(0,r.jsx)(n.h3,{id:"lengthscale",children:"lengthScale"}),"\n",(0,r.jsx)(n.p,{children:"Length scale is a real variable which denotes the length scale of the problem."}),"\n",(0,r.jsx)(n.h3,{id:"gravity",children:"gravity"}),"\n",(0,r.jsx)(n.p,{children:"Gravity vector."}),"\n",(0,r.jsx)(n.h3,{id:"incrementscale",children:"incrementScale"}),"\n",(0,r.jsx)(n.p,{children:"Increment scale for displacement."}),"\n",(0,r.jsx)(n.h3,{id:"disperror-velerror-solerror-reserror",children:"dispError, velError, solError, resError"}),"\n",(0,r.jsxs)(n.p,{children:["These are instances of ",(0,r.jsx)(n.code,{children:"KernelErrorOpt_"})," which contains the error information, you can find more information in ",(0,r.jsx)(n.a,{href:"/docs-api/AbstractKernel/AbstractKernelParam",children:"AbstractKernelParam"})]}),"\n",(0,r.jsx)(n.h3,{id:"name",children:"name"}),"\n",(0,r.jsx)(n.p,{children:"This is a string which contains the name of the kernel."}),"\n",(0,r.jsx)(n.h3,{id:"engine",children:"engine"}),"\n",(0,r.jsx)(n.p,{children:"This is a string which contains the name of the engine of the kernel."}),"\n",(0,r.jsx)(n.h3,{id:"tanmatprop",children:"tanmatProp"}),"\n",(0,r.jsx)(n.p,{children:"This string contains the property of the tangent matrix, such as Symmetric or Unsymmetric."}),"\n",(0,r.jsx)(n.h3,{id:"tanmatname",children:"tanmatName"}),"\n",(0,r.jsx)(n.p,{children:"Name of the tangent matrix."}),"\n",(0,r.jsx)(n.h3,{id:"outputpath",children:"outputPath"}),"\n",(0,r.jsx)(n.p,{children:"Path to put output files."}),"\n",(0,r.jsx)(n.h3,{id:"domainfile",children:"domainFile"}),"\n",(0,r.jsx)(n.p,{children:"Name of the domain file."}),"\n",(0,r.jsx)(n.h3,{id:"basisforspace-basisfortime-basisforpressure-basisforvelocity",children:"basisForSpace, basisForTime, basisForPressure, basisForVelocity"}),"\n",(0,r.jsxs)(n.p,{children:["These variables are instances of ",(0,r.jsx)(n.code,{children:"KernelBasisOpt_"})," which contains the basis function options for space, time, pressure, and velocity. You can find more information about them ",(0,r.jsx)(n.a,{href:"/docs-api/AbstractKernel/AbstractKernelParam",children:"AbstractKernelParam"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"iterdata",children:"iterData"}),"\n",(0,r.jsxs)(n.p,{children:["This is an instance of ",(0,r.jsx)(n.code,{children:"IterationData_"})," which is defined in the base module, see ",(0,r.jsx)(n.a,{href:"/docs-api/IterationData",children:"IterationData"}),"."]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},54213:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(36672);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);