"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[9109],{73140:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>E,contentTitle:()=>i,default:()=>T,frontMatter:()=>s,metadata:()=>t,toc:()=>N});const t=JSON.parse('{"id":"CSRMatrix/SetRow","title":"SetRow","description":"Calling example:","source":"@site/docs/docs-api/CSRMatrix/SetRow.md","sourceDirName":"CSRMatrix","slug":"/CSRMatrix/SetRow","permalink":"/docs-api/CSRMatrix/SetRow","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/CSRMatrix/SetRow.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"SetColumn","permalink":"/docs-api/CSRMatrix/SetColumn"},"next":{"title":"SetSparsity","permalink":"/docs-api/CSRMatrix/SetSparsity"}}');var r=o(23420),a=o(54213);const s={},i="SetRow",E={},N=[{value:"Interface",id:"interface",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"setrow",children:"SetRow"})}),"\n",(0,r.jsx)(e.p,{children:"Calling example:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, irow, value(:,:))"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum, idof, value(:,:))"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, irow, value)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum, idof, value)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum, ivar, idof, value)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum, ivar, idof, value(:))"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum, ivar, spacecompo, timecompo, value)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum, ivar, spacecompo, timecompo, value(:))"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum, ivar, spacecompo, timecompo(:), value)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum, ivar, spacecompo, timecompo(:), value(:))"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum, ivar, spacecompo(:), timecompo, value)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum, ivar, spacecompo(:), timecompo, value(:))"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum(:), ivar, spacecompo, timecompo(:), value)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum(:), ivar, spacecompo, timecompo(:), value(:))"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum(:), ivar, spacecompo(:), timecompo, value)"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"SetRow(obj, nodenum(:), ivar, spacecompo(:), timecompo, value(:))"})}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"interface",children:"Interface"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"MODULE CSRMatrix_SetRowMethods\nUSE GlobalData, ONLY: I4B, DFP, LGT\nUSE BaseType, ONLY: CSRMatrix_\nIMPLICIT NONE\nPRIVATE\n\nPUBLIC :: SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine sets the the row of a sparse matrix\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow1(obj, irow, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: irow\n    REAL(DFP), INTENT(IN) :: VALUE(:)\n  END SUBROUTINE csrMat_setRow1\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine sets the the row of a sparse matrix\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow1b(obj, irow, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: irow(:)\n    REAL(DFP), INTENT(IN) :: VALUE(:)\n  END SUBROUTINE csrMat_setRow1b\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is\n! calculated using the nodenum and idof.\n! - `nodenum` is the node number\n! - `idof` is the degree of freedom number\n! - `irow` calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow2(obj, nodenum, idof, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum\n    INTEGER(I4B), INTENT(IN) :: idof\n    REAL(DFP), INTENT(IN) :: VALUE(:)\n  END SUBROUTINE csrMat_setRow2\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine sets the the row of a sparse matrix\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow3(obj, irow, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: irow\n    REAL(DFP), INTENT(IN) :: VALUE\n  END SUBROUTINE csrMat_setRow3\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine sets the the row of a sparse matrix\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow3b(obj, irow, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: irow(:)\n    REAL(DFP), INTENT(IN) :: VALUE\n  END SUBROUTINE csrMat_setRow3b\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow4(obj, nodenum, idof, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum\n    INTEGER(I4B), INTENT(IN) :: idof\n    REAL(DFP), INTENT(IN) :: VALUE\n  END SUBROUTINE csrMat_setRow4\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow5(obj, nodenum, ivar, idof, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: idof\n    REAL(DFP), INTENT(IN) :: VALUE\n  END SUBROUTINE csrMat_setRow5\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow6(obj, nodenum, ivar, idof, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: idof\n    REAL(DFP), INTENT(IN) :: VALUE(:)\n  END SUBROUTINE csrMat_setRow6\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow7(obj, nodenum, ivar, &\n    & spacecompo, timecompo, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: spacecompo\n    INTEGER(I4B), INTENT(IN) :: timecompo\n    REAL(DFP), INTENT(IN) :: VALUE\n  END SUBROUTINE csrMat_setRow7\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow8(obj, nodenum, ivar, &\n    & spacecompo, timecompo, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: spacecompo\n    INTEGER(I4B), INTENT(IN) :: timecompo\n    REAL(DFP), INTENT(IN) :: VALUE(:)\n  END SUBROUTINE csrMat_setRow8\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow9(obj, nodenum, ivar, &\n    & spacecompo, timecompo, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: spacecompo\n    INTEGER(I4B), INTENT(IN) :: timecompo(:)\n    REAL(DFP), INTENT(IN) :: VALUE\n  END SUBROUTINE csrMat_setRow9\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow10(obj, nodenum, ivar, &\n    & spacecompo, timecompo, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: spacecompo\n    INTEGER(I4B), INTENT(IN) :: timecompo(:)\n    REAL(DFP), INTENT(IN) :: VALUE(:)\n  END SUBROUTINE csrMat_setRow10\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow11(obj, nodenum, ivar, &\n    & spacecompo, timecompo, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: spacecompo(:)\n    INTEGER(I4B), INTENT(IN) :: timecompo\n    REAL(DFP), INTENT(IN) :: VALUE\n  END SUBROUTINE csrMat_setRow11\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow12(obj, nodenum, ivar, &\n    & spacecompo, timecompo, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: spacecompo(:)\n    INTEGER(I4B), INTENT(IN) :: timecompo\n    REAL(DFP), INTENT(IN) :: VALUE(:)\n  END SUBROUTINE csrMat_setRow12\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow13(obj, nodenum, ivar, &\n    & spacecompo, timecompo, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum(:)\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: spacecompo\n    INTEGER(I4B), INTENT(IN) :: timecompo(:)\n    REAL(DFP), INTENT(IN) :: VALUE\n  END SUBROUTINE csrMat_setRow13\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow14(obj, nodenum, ivar, &\n    & spacecompo, timecompo, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum(:)\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: spacecompo\n    INTEGER(I4B), INTENT(IN) :: timecompo(:)\n    REAL(DFP), INTENT(IN) :: VALUE(:)\n  END SUBROUTINE csrMat_setRow14\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow15(obj, nodenum, ivar, &\n    & spacecompo, timecompo, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum(:)\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: spacecompo(:)\n    INTEGER(I4B), INTENT(IN) :: timecompo\n    REAL(DFP), INTENT(IN) :: VALUE\n  END SUBROUTINE csrMat_setRow15\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!                                                          setRow@Methods\n!----------------------------------------------------------------------------\n\n!> author: Vikas Sharma, Ph. D.\n! date: 24 July 2021\n! summary: This routine set the row of a sparse matrix\n!\n!# Introduction\n!\n! - This routine sets the row of a sparse matrix. The row index is calculated\n! using the nodenum and idof.\n! - nodenum is the node number\n! - idof is the degree of freedom number\n! - irow calculated from nodenum and idof depends upon the storageFMT.\n\nINTERFACE SetRow\n  MODULE SUBROUTINE csrMat_setRow16(obj, nodenum, ivar, &\n    & spacecompo, timecompo, VALUE)\n    TYPE(CSRMatrix_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: nodenum(:)\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: spacecompo(:)\n    INTEGER(I4B), INTENT(IN) :: timecompo\n    REAL(DFP), INTENT(IN) :: VALUE(:)\n  END SUBROUTINE csrMat_setRow16\nEND INTERFACE SetRow\n\n!----------------------------------------------------------------------------\n!\n!----------------------------------------------------------------------------\n\nEND MODULE CSRMatrix_SetRowMethods\n"})})]})}function T(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},54213:(n,e,o)=>{o.d(e,{R:()=>s,x:()=>i});var t=o(36672);const r={},a=t.createContext(r);function s(n){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);