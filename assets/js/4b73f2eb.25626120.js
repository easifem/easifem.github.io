"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[25302],{43521:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>m,frontMatter:()=>c,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"ARPACK/SymSmallestEigenval","title":"SymSmallestEigenVal","description":"This function calculates the smallest eigenvalue of a real sym dense matrix.","source":"@site/docs/docs-api/ARPACK/SymSmallestEigenval.md","sourceDirName":"ARPACK","slug":"/ARPACK/SymSmallestEigenval","permalink":"/docs-api/ARPACK/SymSmallestEigenval","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/ARPACK/SymSmallestEigenval.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"SymLargestEigenval","permalink":"/docs-api/ARPACK/SymLargestEigenval"},"next":{"title":"AbstractBC","permalink":"/docs-api/AbstractBC/"}}');var s=t(23420),l=t(54213),i=t(36492),r=t(92492);const c={},o="SymSmallestEigenVal",u={},d=[];function h(e){const n={admonition:"admonition",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"symsmallesteigenval",children:"SymSmallestEigenVal"})}),"\n",(0,s.jsx)(n.p,{children:"This function calculates the smallest eigenvalue of a real sym dense matrix."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It calls ARPACK SSAUPD or DSAUPD routine with MODE=3"}),"\n",(0,s.jsx)(n.li,{children:"Currently, there are four interfaces under this generic method."}),"\n",(0,s.jsx)(n.li,{children:"In this routine we use shift-inverted method to compute the smallest eigenvalue of a regular (standard) eigenvalue problem."}),"\n",(0,s.jsxs)(n.li,{children:["This is because ",(0,s.jsx)(n.code,{children:"ARPACK"})," is good at finding the largest eigenvalue."]}),"\n",(0,s.jsxs)(n.li,{children:["Internally this routine solves a system of linear equations: ",(0,s.jsx)(n.code,{children:"mat * y = x"})," by using LU decomposition."]}),"\n",(0,s.jsx)(n.li,{children:"In this routine we make a call to SymLUSolve and SymGetLU routine."}),"\n"]}),"\n","\n",(0,s.jsxs)(i.A,{children:[(0,s.jsxs)(r.A,{value:"interface1",label:"\u0700 Interface 1",default:!0,children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fortran",children:'INTERFACE\n  MODULE FUNCTION SymSmallestEigenVal(mat, sigma, which, NCV, maxIter, tol) &\n    & RESULT(ans)\n    REAL(DFP), INTENT(IN) :: mat(:, :)\n    !! dense matrix\n    REAL(DFP), OPTIONAL, INTENT(IN) :: sigma\n    !! Default value is 0.0\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: which\n    !! `which = "SM"` \u21e8 absolute smallest eigenvalue\n    !! `which = "SA"` \u21e8 algebraic smallest eigenvalue\n    !! default is "SA"\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: NCV\n    !! Number of Lanczos vectors generated\n    !! It must be greater than 1 and smaller than `size(mat,1)`\n    !! Default is `NCV = MIN(n, 20)`\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: maxIter\n    !! Maximum number of iteration default = `N*10`\n    REAL(DFP), OPTIONAL, INTENT(IN) :: tol\n    !! tolerance, default = 0.0\n    REAL(DFP) :: ans\n    !! maximum eigenvalue\n  END FUNCTION SymSmallestEigenVal\nEND INTERFACE\n'})}),(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsx)(n.p,{children:"This routine makes a copy of mat in mat0. Then, compute the LU decomposition of mat0."})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mat"})," dense matrix"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sigma"})," Default value is 0.0"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'which = "SM"'})," \u21e8 absolute smallest eigenvalue"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'which = "SA"'})," \u21e8 algebraic smallest eigenvalue"]}),"\n",(0,s.jsxs)(n.li,{children:["default value of ",(0,s.jsx)(n.code,{children:"which"}),' is "SA"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NCV"})," Number of Lanczos vectors generated. It must be greater than 1 and smaller than ",(0,s.jsx)(n.code,{children:"size(mat,1)"}),". Default is ",(0,s.jsx)(n.code,{children:"NCV = MIN(n, 20)"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxIter"})," Maximum number of iteration default = ",(0,s.jsx)(n.code,{children:"N*10"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tol"})," tolerance, default = 0.0"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ans"})," maximum eigenvalue."]}),"\n"]})]}),(0,s.jsxs)(r.A,{value:"interface2",label:"\u0700 Interface 2",default:!0,children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-fortran",children:'INTERFACE\n  MODULE FUNCTION SymSmallestEigenVal(mat, isFactor, ipiv, sigma, which, &\n    & NCV, maxIter, tol) RESULT(ans)\n    REAL(DFP), INTENT(INOUT) :: mat(:, :)\n    !!\n    !! Dense matrix\n    !! If isFactor is false, then this matrix will change on return\n    !!    in this case, it will contain LU decomposition\n    !! If isFactor is true, then this matrix will not change\n    !!\n    LOGICAL(LGT), INTENT(INOUT) :: isFactor\n    !! if mat is already factorized, the set isFactor to true\n    !! if mat is not factorized, then set isFactor to false\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: ipiv(:)\n    !! When `isFactor` is true, then `mat` represents the\n    !! `LU` factorization obtained by `SymGetLU` routine.\n    !! In this case `ipiv` is returned by `SymGetLU`.\n    REAL(DFP), OPTIONAL, INTENT(IN) :: sigma\n    !! Default value is 0.0\n    CHARACTER(LEN=*), OPTIONAL, INTENT(IN) :: which\n    !! `which = "SM"` \u21e8 absolute smallest eigenvalue\n    !! `which = "SA"` \u21e8 algebraic smallest eigenvalue\n    !! default is "SA"\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: NCV\n    !! Number of Lanczos vectors generated\n    !! It must be greater than 1 and smaller than `size(mat,1)`\n    !! Default is `NCV = MIN(n, 20)`\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: maxIter\n    !! Maximum number of iteration default = `N*10`\n    REAL(DFP), OPTIONAL, INTENT(IN) :: tol\n    !! tolerance, default = 0.0\n    REAL(DFP) :: ans\n    !! maximum eigenvalue\n  END FUNCTION SymSmallestEigenVal\nEND INTERFACE\n'})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mat"})," Dense matrix"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isFactor"})," if mat is already factorized, then set isFactor to true. if mat is not factorized, then set isFactor to false. If isFactor is false, then this matrix will change on return. In this case, it will contain LU decomposition computed by ",(0,s.jsx)(n.code,{children:"SymGetLU"}),". If ",(0,s.jsx)(n.code,{children:"isFactor"})," is true, then this matrix will not change, and matrix ",(0,s.jsx)(n.code,{children:"mat"})," should contain the ",(0,s.jsx)(n.code,{children:"LU"})," decomposition computed from ",(0,s.jsx)(n.code,{children:"SymGetLU"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ipiv"})," When ",(0,s.jsx)(n.code,{children:"isFactor"})," is true, then ",(0,s.jsx)(n.code,{children:"mat"})," represents the ",(0,s.jsx)(n.code,{children:"LU"})," factorization obtained by ",(0,s.jsx)(n.code,{children:"SymGetLU"})," routine. In this case ",(0,s.jsx)(n.code,{children:"ipiv"})," is returned by ",(0,s.jsx)(n.code,{children:"SymGetLU"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sigma"})," Default value is 0.0"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'which = "SM"'})," \u21e8 absolute smallest eigenvalue"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'which = "SA"'})," \u21e8 algebraic smallest eigenvalue"]}),"\n",(0,s.jsxs)(n.li,{children:["default value of ",(0,s.jsx)(n.code,{children:"which"}),' is "SA"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"NCV"})," Number of Lanczos vectors generated"]}),"\n",(0,s.jsxs)(n.li,{children:["It must be greater than 1 and smaller than ",(0,s.jsx)(n.code,{children:"size(mat,1)"})]}),"\n",(0,s.jsxs)(n.li,{children:["Default value of ",(0,s.jsx)(n.code,{children:"NCV"})," is ",(0,s.jsx)(n.code,{children:"NCV = MIN(n, 20)"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxIter"})," Maximum number of iteration default = ",(0,s.jsx)(n.code,{children:"N*10"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tol"})," tolerance, default = 0.0"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ans"}),", the smallest eigenvalue."]}),"\n"]})]}),(0,s.jsx)(r.A,{value:"close",label:"\u21a2 Close"})]})]})}function m(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},92492:(e,n,t)=>{t.d(n,{A:()=>i});t(36672);var a=t(28923);const s={tabItem:"tabItem_VSPN"};var l=t(23420);function i(e){let{children:n,hidden:t,className:i}=e;return(0,l.jsx)("div",{role:"tabpanel",className:(0,a.A)(s.tabItem,i),hidden:t,children:n})}},36492:(e,n,t)=>{t.d(n,{A:()=>v});var a=t(36672),s=t(28923),l=t(19929),i=t(85291),r=t(5581),c=t(80034),o=t(12715),u=t(62741);function d(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:s}}=e;return{value:n,label:t,attributes:a,default:s}}))}(t);return function(e){const n=(0,o.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function f(e){let{queryString:n=!1,groupId:t}=e;const s=(0,i.W6)(),l=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c.aZ)(l),(0,a.useCallback)((e=>{if(!l)return;const n=new URLSearchParams(s.location.search);n.set(l,e),s.replace({...s.location,search:n.toString()})}),[l,s])]}function x(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,l=h(e),[i,c]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:l}))),[o,d]=f({queryString:t,groupId:s}),[x,N]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,l]=(0,u.Dv)(t);return[s,(0,a.useCallback)((e=>{t&&l.set(e)}),[t,l])]}({groupId:s}),I=(()=>{const e=o??x;return m({value:e,tabValues:l})?e:null})();(0,r.A)((()=>{I&&c(I)}),[I]);return{selectedValue:i,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);c(e),d(e),N(e)}),[d,N,l]),tabValues:l}}var N=t(32111);const I={tabList:"tabList_csSQ",tabItem:"tabItem_Bcmo"};var p=t(23420);function b(e){let{className:n,block:t,selectedValue:a,selectValue:i,tabValues:r}=e;const c=[],{blockElementScrollPositionUntilNextRender:o}=(0,l.a_)(),u=e=>{const n=e.currentTarget,t=c.indexOf(n),s=r[t].value;s!==a&&(o(n),i(s))},d=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,p.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},n),children:r.map((e=>{let{value:n,label:t,attributes:l}=e;return(0,p.jsx)("li",{role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>{c.push(e)},onKeyDown:d,onClick:u,...l,className:(0,s.A)("tabs__item",I.tabItem,l?.className,{"tabs__item--active":a===n}),children:t??n},n)}))})}function g(e){let{lazy:n,children:t,selectedValue:l}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===l));return e?(0,a.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,p.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==l})))})}function j(e){const n=x(e);return(0,p.jsxs)("div",{className:(0,s.A)("tabs-container",I.tabList),children:[(0,p.jsx)(b,{...n,...e}),(0,p.jsx)(g,{...n,...e})]})}function v(e){const n=(0,N.A)();return(0,p.jsx)(j,{...e,children:d(e.children)},String(n))}},54213:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var a=t(36672);const s={},l=a.createContext(s);function i(e){const n=a.useContext(l);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(l.Provider,{value:n},e.children)}}}]);