"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[86911],{64794:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"TriangleInterface/switches","title":"Switches","description":"summary","source":"@site/docs/docs-api/TriangleInterface/switches.md","sourceDirName":"TriangleInterface","slug":"/TriangleInterface/switches","permalink":"/docs-api/TriangleInterface/switches","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/TriangleInterface/switches.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Refinement","permalink":"/docs-api/TriangleInterface/refinement"},"next":{"title":"triangulate","permalink":"/docs-api/TriangleInterface/triangulate"}}');var s=n(23420),r=n(54213);const a={},l="Switches",d={},o=[{value:"summary",id:"summary",level:2},{value:"<code>p</code>",id:"p",level:2},{value:"r",id:"r",level:2},{value:"q",id:"q",level:2},{value:"a",id:"a",level:2},{value:"A",id:"a-1",level:2},{value:"u",id:"u",level:2},{value:"c",id:"c",level:2}];function h(e){const i={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"switches",children:"Switches"})}),"\n",(0,s.jsx)(i.h2,{id:"summary",children:"summary"}),"\n",(0,s.jsx)(i.p,{children:"For some of the command line switches described below, you may click on the switch for detailed information."}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"switch"}),(0,s.jsx)(i.th,{children:"comment"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"p"})}),(0,s.jsxs)(i.td,{children:["Triangulates a Planar Straight Line Graph ",(0,s.jsx)(i.code,{children:"poly"})," file."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"r"})}),(0,s.jsx)(i.td,{children:"Refines a previously generated mesh."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"q"})}),(0,s.jsxs)(i.td,{children:["Quality mesh generation with no angles smaller than 20 degrees. An alternate minimum angle may be specified after the ",(0,s.jsx)(i.code,{children:"q"}),"."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"a"})}),(0,s.jsxs)(i.td,{children:["Imposes a maximum triangle area constraint. A fixed area constraint (that applies to every triangle) may be specified after the ",(0,s.jsx)(i.code,{children:"a"}),", or varying area constraints may be read from a poly file or area file."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"u"})}),(0,s.jsx)(i.td,{children:"Imposes a user-defined constraint on triangle size."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"A"})}),(0,s.jsx)(i.td,{children:"Assigns a regional attribute to each triangle that identifies what segment-bounded region it belongs to."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"c"})}),(0,s.jsx)(i.td,{children:"Encloses the convex hull with segments."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"D"})}),(0,s.jsx)(i.td,{children:"Conforming Delaunay: use this switch if you want all triangles in the mesh to be Delaunay, and not just constrained Delaunay; or if you want to ensure that all Voronoi vertices lie within the triangulation."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"j"})}),(0,s.jsx)(i.td,{children:"Jettisons vertices that are not part of the final triangulation from the output .node file (including duplicate input vertices and vertices eaten by holes)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"e"})}),(0,s.jsx)(i.td,{children:"Outputs (to an edge file) a list of edges of the triangulation."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"v"})}),(0,s.jsx)(i.td,{children:"Outputs the Voronoi diagram associated with the triangulation. Does not attempt to detect degeneracies, so some Voronoi vertices may be duplicated."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"n"})}),(0,s.jsx)(i.td,{children:"Outputs (to a .neigh file) a list of triangles neighboring each triangle."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"g"})}),(0,s.jsx)(i.td,{children:"Outputs the mesh to an Object File Format (.off) file, suitable for viewing with the Geometry Center's Geomview package."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"B"})}),(0,s.jsx)(i.td,{children:"Suppresses boundary markers in the output .node, .poly, and .edge output files."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"P"})}),(0,s.jsx)(i.td,{children:"Suppresses the output .poly Saves disk space, but you lose the ability to maintain constraining segments on later refinements of the mesh.file."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"N"})}),(0,s.jsx)(i.td,{children:"Suppresses the output .node file."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"E"})}),(0,s.jsx)(i.td,{children:"Suppresses the output .ele file."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"I"})}),(0,s.jsx)(i.td,{children:"Suppresses mesh iteration numbers."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"O"})}),(0,s.jsx)(i.td,{children:"Suppresses holes: ignores the holes in the .poly file."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"X"})}),(0,s.jsx)(i.td,{children:"Suppresses exact arithmetic."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"z"})}),(0,s.jsx)(i.td,{children:"Numbers all items starting from zero (rather than one)."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"o2"})}),(0,s.jsx)(i.td,{children:"Generates second-order subparametric elements with six nodes each."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Y"})}),(0,s.jsx)(i.td,{children:"Prohibits the insertion of Steiner points on the mesh boundary. If specified twice (-YY), it prohibits the insertion of Steiner points on any segment, including internal segments."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"S"})}),(0,s.jsx)(i.td,{children:"Specifies the maximum number of added Steiner points."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"i"})}),(0,s.jsx)(i.td,{children:"Uses the incremental algorithm for Delaunay triangulation, rather than the divide-and-conquer algorithm."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"F"})}),(0,s.jsx)(i.td,{children:"Uses Steven Fortune's sweepline algorithm for Delaunay triangulation, rather than the divide-and-conquer algorithm."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"l"})}),(0,s.jsx)(i.td,{children:"Uses only vertical cuts in the divide-and-conquer algorithm. By default, Triangle uses alternating vertical and horizontal cuts, which usually improve the speed except with vertex sets that are small or short and wide. This switch is primarily of theoretical interest."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"s"})}),(0,s.jsx)(i.td,{children:"Specifies that segments should be forced into the triangulation by recursively splitting them at their midpoints, rather than by generating a constrained Delaunay triangulation."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"C"})}),(0,s.jsx)(i.td,{children:"Check the consistency of the final mesh. Uses exact arithmetic for checking, even if the -X switch is used. Useful if you suspect Triangle is buggy."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"Q"})}),(0,s.jsx)(i.td,{children:"Quiet: Suppresses all explanation of what Triangle is doing, unless an error occurs."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"V"})}),(0,s.jsxs)(i.td,{children:["Verbose: Gives detailed information about what Triangle is doing. Add more ",(0,s.jsx)(i.code,{children:"V's for increasing amount of detail."}),"-V' gives information on algorithmic progress and detailed statistics."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"h"})}),(0,s.jsx)(i.td,{children:"Help: Displays complete instructions."})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"p",children:(0,s.jsx)(i.code,{children:"p"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Reads a Planar Straight Line Graph (.poly) file, which can specify points, segments, holes, regional attributes, and area constraints."}),"\n",(0,s.jsx)(i.li,{children:"Will generate a constraint Delaunay triangulation (CDT) fitting the input"}),"\n",(0,s.jsxs)(i.li,{children:["if ",(0,s.jsx)(i.code,{children:"-s"}),", ",(0,s.jsx)(i.code,{children:"-q"}),", ",(0,s.jsx)(i.code,{children:"-a"}),", or ",(0,s.jsx)(i.code,{children:"-u"})," is used, then it generates a conforming constrained Delaunay triangulation (CCDT)."]}),"\n",(0,s.jsxs)(i.li,{children:["If ",(0,s.jsx)(i.code,{children:"-D"})," is used, Triangle generates a conforming Delaunay triangulation, so every triangle is Delaunay."]}),"\n",(0,s.jsxs)(i.li,{children:["If ",(0,s.jsx)(i.code,{children:"-r"})," is used with -p, the refined mesh will preserve the segments of the coarse mesh it was generated from."]}),"\n",(0,s.jsxs)(i.li,{children:["If ",(0,s.jsx)(i.code,{children:"-p"})," is not used, Triangle reads a .node file by default."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"r",children:"r"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Refines a previously generated mesh."}),"\n",(0,s.jsx)(i.li,{children:"The mesh is read from a .node file and an .ele file."}),"\n",(0,s.jsx)(i.li,{children:"If -p is also used, a .poly file is read and used to constrain segments in the mesh."}),"\n",(0,s.jsx)(i.li,{children:"If -a is also used (with no number following), an .area file is read and used to impose area constraints on the mesh."}),"\n",(0,s.jsx)(i.li,{children:"The iteration number of the new mesh is one greater than that of the old mesh."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"q",children:"q"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Quality mesh generation by my variant of a hybrid of Jim Ruppert's Delaunay refinement algorithm and Paul Chew's Delaunay refinement algorithm. (Ruppert's paper describing his algorithm, and my papers describing my variations, are available from the Research Credit page.)"}),"\n",(0,s.jsx)(i.li,{children:"Adds vertices to the mesh to ensure that no angle smaller than 20o occurs. Clearly, small angles between input segments cannot be eliminated; usually, all other small angles are."}),"\n",(0,s.jsx)(i.li,{children:"An alternative minimum angle may be specified after the `q'. For instance, -q14.3 specifies a minimum angle of 14.3o. If the minimum angle is 20.7o or smaller, the triangulation algorithm is theoretically guaranteed to terminate (assuming infinite precision arithmetic - Triangle may fail to terminate if you run out of precision)."}),"\n",(0,s.jsx)(i.li,{children:"In practice, the algorithm often succeeds for minimum angles up to 33o. It usually doesn't terminate for angles above 34o."}),"\n",(0,s.jsx)(i.li,{children:"For some meshes, however, it may be necessary to reduce the minimum angle to well below 20o to avoid problems associated with insufficient floating-point precision."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"a",children:"a"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Imposes a maximum triangle area."}),"\n",(0,s.jsxs)(i.li,{children:["If a number follows the ",(0,s.jsx)(i.code,{children:"a"}),", no triangle will be generated whose area is larger than that number."]}),"\n",(0,s.jsxs)(i.li,{children:["For instance, ",(0,s.jsx)(i.code,{children:"-a2.5"})," specifies that no triangle should have area greater than 2.5."]}),"\n",(0,s.jsxs)(i.li,{children:["If no number is specified after the ",(0,s.jsx)(i.code,{children:"a"}),", an .area file (if -r is used) or .poly file (if -r is not used) specifies a set of maximum area constraints."]}),"\n",(0,s.jsx)(i.li,{children:"An .area file contains a separate area constraint for each triangle, and is useful for refining a finite element mesh based on a posteriori error estimates."}),"\n",(0,s.jsx)(i.li,{children:"A .poly file can optionally contain an area constraint for each segment-bounded region, thereby controlling triangle densities in a first triangulation of a PSLG."}),"\n",(0,s.jsx)(i.li,{children:"You can impose both a fixed area constraint and a varying area constraint by invoking the -a switch twice, once with and once without a number following."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"a-1",children:"A"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Assigns an additional attribute to each triangle that identifies what segment-bounded region each triangle belongs to. (See the .ele file format description for a description of triangle attributes.)"}),"\n",(0,s.jsx)(i.li,{children:"Attributes are assigned to regions by the .poly file; see the .poly file format description for details."}),"\n",(0,s.jsx)(i.li,{children:"If a region is not explicitly marked by the .poly file, triangles in that region are assigned an attribute of zero."}),"\n"]}),"\n",(0,s.jsx)(i.admonition,{type:"note",children:(0,s.jsx)(i.p,{children:"The -A switch has an effect only when the -p switch is used and the -r switch is not."})}),"\n",(0,s.jsx)(i.h2,{id:"u",children:"u"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Imposes a user-defined constraint on triangle size, somewhat like the -a switch, but you write C code that examines a triangle's coordinates and area, and decides whether to refine the triangle or not."}),"\n",(0,s.jsx)(i.li,{children:"There are two ways to use this feature. The first is to edit the triunsuitable() procedure in triangle.c to encode any constraint you like, then recompile Triangle."}),"\n",(0,s.jsx)(i.li,{children:"The second way to use this feature is to compile triangle.c with the EXTERNAL_TEST symbol set (compiler switch -DEXTERNAL_TEST), then link Triangle against a separate object file that implements triunsuitable()."}),"\n",(0,s.jsx)(i.li,{children:"In either case, the -u switch causes the user-defined test to be applied to every triangle."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"c",children:"c"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Creates segments on the convex hull of the triangulation."}),"\n",(0,s.jsx)(i.li,{children:"If you are triangulating a vertex set, this switch causes a .poly file to be written, containing all edges in the convex hull."}),"\n",(0,s.jsx)(i.li,{children:"If you are triangulating a PSLG, this switch specifies that the whole convex hull of the PSLG should be triangulated, regardless of what segments the PSLG has."}),"\n",(0,s.jsx)(i.li,{children:"If you do not use this switch when triangulating a PSLG, it is assumed that you have identified the region to be triangulated by surrounding it with segments of the input PSLG."}),"\n",(0,s.jsx)(i.li,{children:"Beware: if you are not careful, this switch can cause the introduction of an extremely thin angle between a PSLG segment and a convex hull segment, which can cause overrefinement."}),"\n",(0,s.jsx)(i.li,{children:"If you are refining a mesh, this switch works differently; it generates the set of boundary edges of the mesh, including boundaries of holes. (This is useful if no .poly file was read.)"}),"\n"]})]})}function c(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},54213:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>l});var t=n(36672);const s={},r=t.createContext(s);function a(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);