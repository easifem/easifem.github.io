"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[9091],{99579:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"MatrixField/MatrixField_","title":"Structure","description":"It handles the tangent-matrix in finite element computations.","source":"@site/docs/docs-api/MatrixField/MatrixField_.md","sourceDirName":"MatrixField","slug":"/MatrixField/MatrixField_","permalink":"/docs-api/MatrixField/MatrixField_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/MatrixField/MatrixField_.md","tags":[],"version":"current","lastUpdatedAt":1736823324000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"MatrixFieldCheckEssentialParam","permalink":"/docs-api/MatrixField/MatrixFieldCheckEssentialParam"},"next":{"title":"RectangleMatrixFieldCheckEssentialParam","permalink":"/docs-api/MatrixField/RectangleMatrixFieldCheckEssentialParam"}}');var r=i(23420),s=i(54213);const a={},o="Structure",d={},l=[];function c(e){const n={a:"a",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"structure",children:"Structure"})}),"\n",(0,r.jsx)(n.p,{children:"It handles the tangent-matrix in finite element computations."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"MatrixField_"})," is a child of ",(0,r.jsx)(n.a,{href:"/docs-api/AbstractMatrixField/AbstractMatrixField_",children:"AbstractMatrixField_"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["It uses ",(0,r.jsx)(n.code,{children:"NATIVE_SERIAL"})," engine."]}),"\n",(0,r.jsxs)(n.li,{children:["It also defines a data type for storing the precondition matrix. This data type is called ",(0,r.jsx)(n.code,{children:"MatrixFieldPrecondition_"}),", its header is given below."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-fortran",children:"TYPE :: MatrixFieldPrecondition_\nLOGICAL( LGT ) :: isInitiated = .FALSE.\nINTEGER( I4B ) :: PmatName = 0\nINTEGER( I4B ) :: nnz = 0\nINTEGER( I4B ) :: ncol = 0\nINTEGER( I4B ) :: nrow = 0\nINTEGER( I4B ) :: lfil = 0\nINTEGER( I4B ) :: mbloc = 0\nREAL( DFP ) :: alpha = 0.0_DFP\nREAL( DFP ) :: droptol = 0.0_DFP\nREAL( DFP ) :: permtol = 0.0_DFP\nREAL( DFP ), ALLOCATABLE :: A( : )\nINTEGER( I4B ), ALLOCATABLE :: JA( : )\nINTEGER( I4B ), ALLOCATABLE :: IA( : )\nINTEGER( I4B ), ALLOCATABLE :: JU( : )\nINTEGER( I4B ), ALLOCATABLE :: IPERM( : )\nINTEGER( I4B ), ALLOCATABLE :: LEVS( : )\nEND TYPE MatrixFieldPrecondition_\n"})}),"\n",(0,r.jsx)(n.p,{children:"The storage pattern of the precondition matrix depends upon the type of preconditioning. For example, Incomplete LU decomposition based preconditioners are stored in the modified sparse row (MSR) format, which is described by the Sparsekit library."}),"\n",(0,r.jsx)(n.p,{children:"The storage format of a precondition matrix depends upon the linear solver library or engine. That is why EASIFEM hides the preconditioner from user."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"MSR format"})," We have used Modified Sparse Row, which is used by Sparsekit lib to store the precondition matrix, this data type is meant to be used internally only."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"A(1:n)"})," contains the diagonal of the matrix."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"A(n+2:nnz)"})," contains the nondiagonal elements of the matrix, stored row-wise"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"JA(n+2:nnz)"})," contains their column indices"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"JA(1:n+1)"})," Contains the pointer array for the nondiagonal, elements in ",(0,r.jsx)(n.code,{children:"A(n+1:nnz)"})," and ",(0,r.jsx)(n.code,{children:"JA(n+2:nnz)"}),", i.e., for ",(0,r.jsx)(n.code,{children:"i .LE. n+1"})," ",(0,r.jsx)(n.code,{children:"JA(i)"})," points to beginning of row ",(0,r.jsx)(n.code,{children:"i"})," in arrays A, JA."]}),"\n",(0,r.jsx)(n.li,{children:"Here, nnz = number of nonzero elements+1"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-fortran",metastring:'title="MatrixField"',children:"TYPE, EXTENDS(AbstractMatrixField_) :: MatrixField_\n  LOGICAL(LGT) :: isRectangle = .FALSE.\n  TYPE(CSRMatrix_) :: mat\n  TYPE(MatrixFieldPrecondition_) :: Pmat\n#ifdef USE_LIS\n  INTEGER(I4B), ALLOCATABLE :: lis_ia(:)\n  INTEGER(I4B), ALLOCATABLE :: lis_ja(:)\n#endif\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If the matrix is square, then the storage format is ",(0,r.jsx)(n.code,{children:"FMT_NODES"})]}),"\n",(0,r.jsxs)(n.li,{children:["If the matrix is Rectangle, then the storage format is ",(0,r.jsx)(n.code,{children:"FMT_NODES"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},54213:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(36672);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);