"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[56737],{70164:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>h,contentTitle:()=>l,default:()=>a,frontMatter:()=>c,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"MeshSelection/MeshSelection_","title":"Structure","description":"MeshSelection class is designed to select parts of domain object.","source":"@site/docs/docs-api/MeshSelection/MeshSelection_.md","sourceDirName":"MeshSelection","slug":"/MeshSelection/MeshSelection_","permalink":"/docs-api/MeshSelection/MeshSelection_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/MeshSelection/MeshSelection_.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"IsNodeNumAllocated","permalink":"/docs-api/MeshSelection/IsNodeNumAllocated"},"next":{"title":"Set","permalink":"/docs-api/MeshSelection/Set"}}');var i=n(23420),o=n(54213);const c={},l="Structure",h={},d=[];function r(e){const s={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"structure",children:"Structure"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"MeshSelection_"})," class is designed to select parts of ",(0,i.jsx)(s.code,{children:"domain_"})," object."]}),"\n",(0,i.jsxs)(s.p,{children:["It selects the ",(0,i.jsx)(s.code,{children:"mesh_"})," by using ",(0,i.jsx)(s.code,{children:"meshID"})," , ",(0,i.jsx)(s.code,{children:"elemNum"}),", ",(0,i.jsx)(s.code,{children:"nodeNum"})," and/or ",(0,i.jsx)(s.code,{children:"boundingBox"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"This class can be used to map material properties to meshes. In general it can be used to tag mesh entities."}),"\n",(0,i.jsx)(s.p,{children:"![[MeshSelection_workflow.svg]]"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"TYPE :: MeshSelection_\n  PRIVATE\n  LOGICAL(LGT), PUBLIC :: isInitiated = .FALSE.\n  LOGICAL(LGT), PUBLIC :: isSelectionByMeshID = .FALSE.\n  LOGICAL(LGT), PUBLIC :: isSelectionByElemNum = .FALSE.\n  LOGICAL(LGT), PUBLIC :: isSelectionByBox = .FALSE.\n  LOGICAL(LGT), PUBLIC :: isSelectionByNodeNum = .FALSE.\n  TYPE(IntVector_) :: pointMeshID\n  TYPE(IntVector_) :: curveMeshID\n  TYPE(IntVector_) :: surfaceMeshID\n  TYPE(IntVector_) :: volumeMeshID\n  TYPE(IntVector_) :: pointElemNum\n  TYPE(IntVector_) :: curveElemNum\n  TYPE(IntVector_) :: surfaceElemNum\n  TYPE(IntVector_) :: volumeElemNum\n  TYPE(IntVector_) :: nodeNum\n"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"isInitiated"}),", True if an instance of MeshSelection is initiated"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"isSelectionByMeshID"}),", True if the mesh selection is done by specifying the mesh id"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"isSelectionByElemNum"}),", True if the mesh slection is done by specifying the global element number"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"isSelectionByBox"}),", True if the mesh selection is done by specifying the bounding box"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"isSelectionByNodeNum"}),", True if the mesh selection is done by specifying global node numbers"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"pointMeshID"}),", It denotes the IDs of mesh which has xidim=0, that is point mesh"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"curveMeshID"}),", It denotes the IDs of mesh which has xidim=1, that is, curve mesh"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"surfaceMeshID"}),", It denotes the IDs of mesh which has xidim=2, that is, surface mesh"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"volumeMeshID"}),", It denotes the IDs of mesh which has xidim=3, that is, volume mesh"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"pointElemNum"}),", It denotes the global element numbers that are used to select the mesh, and belongs to the point mesh"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"curveElemNum"}),", It denotes the global element numbers that are used to select the mesh, and belongs to the curve mesh"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"surfaceElemNum"}),", It denotes the global element numbers that are used to select the mesh, and belongs to the surface mesh"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"volumeElemNum"}),", It denotes the global element numbers that are used to select the mesh, and belongs to the volume mesh"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"nodeNum"}),", It denotes the global node number that are used to select the mesh"]}),"\n"]})]})}function a(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}},54213:(e,s,n)=>{n.d(s,{R:()=>c,x:()=>l});var t=n(36672);const i={},o=t.createContext(i);function c(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);