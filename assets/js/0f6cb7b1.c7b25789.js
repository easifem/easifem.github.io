"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[38606],{44545:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"AbstractFile/AbstractFile_","title":"AbstractFile","description":"This type is an abstract type, so it has no specific implementation. It exists only to provide a base for the extended types. It specifies the maximum lengths for the file path, name, and extension, some basic attributes of a file such as whether or not it is open and also if it is open for reading or writing are provided. Methods to interface to all attributes are also provided. Since this is an abstract type, it has no specific implementation so see one of it\'s extended types for examples on how it should be used.","source":"@site/docs/docs-api/AbstractFile/AbstractFile_.md","sourceDirName":"AbstractFile","slug":"/AbstractFile/AbstractFile_","permalink":"/docs-api/AbstractFile/AbstractFile_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AbstractFile/AbstractFile_.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"AbstractFile","permalink":"/docs-api/AbstractFile/"},"next":{"title":"Deallocate","permalink":"/docs-api/AbstractFile/Deallocate"}}');var s=n(23420),a=n(54213);const l={},r="AbstractFile",o={},d=[{value:"Structure",id:"structure",level:2},{value:"Deferred methods",id:"deferred-methods",level:2},{value:"Open",id:"open",level:3},{value:"Close",id:"close",level:3},{value:"Delete",id:"delete",level:3},{value:"ConstructorMethods",id:"constructormethods",level:2},{value:"AddSurrogate",id:"addsurrogate",level:3},{value:"Deallocate",id:"deallocate",level:3},{value:"SetMethods",id:"setmethods",level:2},{value:"SetFilePath",id:"setfilepath",level:3},{value:"SetFileName",id:"setfilename",level:3},{value:"SetFileExt",id:"setfileext",level:3},{value:"SetEOFStat",id:"seteofstat",level:3},{value:"SetOpenStat",id:"setopenstat",level:3},{value:"SetReadStat",id:"setreadstat",level:3},{value:"SetWriteStat",id:"setwritestat",level:3},{value:"GetMethods",id:"getmethods",level:2},{value:"GetFilePath",id:"getfilepath",level:3},{value:"GetFileName",id:"getfilename",level:3},{value:"GetFileExt",id:"getfileext",level:3},{value:"GetFileParts",id:"getfileparts",level:3},{value:"EnquireMethods",id:"enquiremethods",level:2},{value:"IsOpen",id:"isopen",level:3},{value:"IsEOF",id:"iseof",level:3},{value:"IsRead",id:"isread",level:3},{value:"IsWrite",id:"iswrite",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"abstractfile",children:"AbstractFile"})}),"\n",(0,s.jsx)(t.p,{children:"This type is an abstract type, so it has no specific implementation. It exists only to provide a base for the extended types. It specifies the maximum lengths for the file path, name, and extension, some basic attributes of a file such as whether or not it is open and also if it is open for reading or writing are provided. Methods to interface to all attributes are also provided. Since this is an abstract type, it has no specific implementation so see one of it's extended types for examples on how it should be used."}),"\n",(0,s.jsx)(t.admonition,{title:"Inspiration",type:"info",children:(0,s.jsxs)(t.p,{children:["The developement of this module is inspired from the ",(0,s.jsx)(t.code,{children:"FileType_Base.F90"})," of Futility package. The original source is located ",(0,s.jsx)(t.a,{href:"https://github.com/CASL/Futility/blob/master/src/FileType_Base.F90",children:"here"}),". The original code has been modified as per the code-standard of easifem library."]})}),"\n",(0,s.jsx)(t.h2,{id:"structure",children:"Structure"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"TYPE,ABSTRACT :: AbstractFile_\n  PRIVATE\n  INTEGER(I4B) :: pathlen=0\n    !! The length of the path string for this file\n  INTEGER(I4B) :: fnamelen=0\n    !! The length of the name string for this file\n  INTEGER(I4B) :: extlen=0\n    !! The length of the file name extension string for this file\n  TYPE(String) :: path\n    !! The path string to the file\n  TYPE(String) :: fileName\n    !! The name of the file (without the file extension)\n  TYPE(String) :: ext\n    !! The extension of the file name\n  LOGICAL(LGT) :: openstat=.FALSE.\n    !! Whether or not the file is open\n  LOGICAL(LGT) :: EOFstat=.FALSE.\n    !! Whether or not the end of file has been reached\n  LOGICAL(LGT) :: readstat=.FALSE.\n    !! Whether or not the file is open for reading\n  LOGICAL(LGT) :: writestat=.FALSE.\n    !! Whether or not the file is open for writing\n"})}),"\n",(0,s.jsx)(t.h2,{id:"deferred-methods",children:"Deferred methods"}),"\n",(0,s.jsx)(t.h3,{id:"open",children:"Open"}),"\n",(0,s.jsx)(t.p,{children:"Method to open the file. The generic interface is given below"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"ABSTRACT INTERFACE\n  SUBROUTINE Open(obj)\n    IMPORT :: AbstractFile_\n    CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  END SUBROUTINE Open\nEND INTERFACE\n"})}),"\n",(0,s.jsx)(t.h3,{id:"close",children:"Close"}),"\n",(0,s.jsx)(t.p,{children:"Method to close the file. The generic interface is given below."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"ABSTRACT INTERFACE\n  SUBROUTINE Close(obj)\n    IMPORT :: AbstractFile_\n    CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  END SUBROUTINE Close\nEND INTERFACE\n"})}),"\n",(0,s.jsx)(t.h3,{id:"delete",children:"Delete"}),"\n",(0,s.jsx)(t.p,{children:"Method to delete a file. The generic interface is given below."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"\nABSTRACT INTERFACE\n  SUBROUTINE Delete(obj)\n    IMPORT :: AbstractFile_\n    CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  END SUBROUTINE Delete\nEND INTERFACE\n"})}),"\n",(0,s.jsx)(t.h2,{id:"constructormethods",children:"ConstructorMethods"}),"\n",(0,s.jsx)(t.h3,{id:"addsurrogate",children:"AddSurrogate"}),"\n",(0,s.jsx)(t.p,{children:"Add surrogate to the module error handler."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"\nINTERFACE\nMODULE SUBROUTINE addSurrogate( obj, UserObj )\n  CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  TYPE( ExceptionHandler_ ), INTENT( IN ) :: UserObj\nEND SUBROUTINE addSurrogate\nEND INTERFACE\n\n"})}),"\n",(0,s.jsx)(t.h3,{id:"deallocate",children:"Deallocate"}),"\n",(0,s.jsx)(t.p,{children:"Deallocate the data stored inside an instance of file object. Also you can delete the existing file."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE SUBROUTINE Deallocate( obj, delete )\n  CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  LOGICAL( LGT ), OPTIONAL, INTENT( IN ) :: delete\nEND SUBROUTINE Deallocate\nEND INTERFACE\n\n"})}),"\n",(0,s.jsx)(t.h2,{id:"setmethods",children:"SetMethods"}),"\n",(0,s.jsx)(t.h3,{id:"setfilepath",children:"SetFilePath"}),"\n",(0,s.jsx)(t.p,{children:"Set the path of file."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE SUBROUTINE setFilePath( obj, path )\n  CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: path\nEND SUBROUTINE setFilePath\nEND INTERFACE\n"})}),"\n",(0,s.jsx)(t.h3,{id:"setfilename",children:"SetFileName"}),"\n",(0,s.jsx)(t.p,{children:"Set filename (without extension and dot)"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE SUBROUTINE setFileName( obj, fileName )\n  CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: fileName\nEND SUBROUTINE setFileName\nEND INTERFACE\n\n"})}),"\n",(0,s.jsx)(t.h3,{id:"setfileext",children:"SetFileExt"}),"\n",(0,s.jsx)(t.p,{children:"Set the file extension."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE SUBROUTINE setFileExt( obj, Ext )\n  CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  TYPE( String ), INTENT( IN ) :: Ext\nEND SUBROUTINE setFileExt\nEND INTERFACE\n"})}),"\n",(0,s.jsx)(t.h3,{id:"seteofstat",children:"SetEOFStat"}),"\n",(0,s.jsx)(t.p,{children:"Set the end of file status."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE SUBROUTINE setEOFstat( obj, stat )\n  CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  LOGICAL( LGT ), INTENT( IN ) :: stat\nEND SUBROUTINE setEOFstat\nEND INTERFACE\n"})}),"\n",(0,s.jsx)(t.h3,{id:"setopenstat",children:"SetOpenStat"}),"\n",(0,s.jsx)(t.p,{children:"Set the status of open or not."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE SUBROUTINE setOpenStat( obj, stat )\n  CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  LOGICAL( LGT ), INTENT( IN ) :: stat\nEND SUBROUTINE setOpenStat\nEND INTERFACE\n\n"})}),"\n",(0,s.jsx)(t.h3,{id:"setreadstat",children:"SetReadStat"}),"\n",(0,s.jsx)(t.p,{children:"Set the status for read access"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE SUBROUTINE setReadStat( obj, stat )\n  CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  LOGICAL( LGT ), INTENT( IN ) :: stat\nEND SUBROUTINE setReadStat\nEND INTERFACE\n\n"})}),"\n",(0,s.jsx)(t.h3,{id:"setwritestat",children:"SetWriteStat"}),"\n",(0,s.jsx)(t.p,{children:"Set the status for write access"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE SUBROUTINE setWriteStat( obj, stat )\n  CLASS( AbstractFile_ ), INTENT( INOUT ) :: obj\n  LOGICAL( LGT ), INTENT( IN ) :: stat\nEND SUBROUTINE setWriteStat\nEND INTERFACE\n\n"})}),"\n",(0,s.jsx)(t.h2,{id:"getmethods",children:"GetMethods"}),"\n",(0,s.jsx)(t.h3,{id:"getfilepath",children:"GetFilePath"}),"\n",(0,s.jsx)(t.p,{children:"Get the path of the file."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE FUNCTION getFilePath( obj ) RESULT( path )\n  CLASS( AbstractFile_ ), INTENT( IN ) :: obj\n  TYPE( String ) :: path\nEND FUNCTION getFilePath\nEND INTERFACE\n"})}),"\n",(0,s.jsx)(t.h3,{id:"getfilename",children:"GetFileName"}),"\n",(0,s.jsx)(t.p,{children:"Get the name of the file without extension"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE FUNCTION getFileName( obj ) RESULT( fileName )\n  CLASS( AbstractFile_ ), INTENT( IN ) :: obj\n  TYPE( String ) :: fileName\nEND FUNCTION getFileName\nEND INTERFACE\n\n"})}),"\n",(0,s.jsx)(t.h3,{id:"getfileext",children:"GetFileExt"}),"\n",(0,s.jsx)(t.p,{children:"Get the extension of the file."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE FUNCTION getFileExt( obj ) RESULT( Ext )\n  CLASS( AbstractFile_ ), INTENT( IN ) :: obj\n  TYPE( String ) :: Ext\nEND FUNCTION getFileExt\nEND INTERFACE\n\n"})}),"\n",(0,s.jsx)(t.h3,{id:"getfileparts",children:"GetFileParts"}),"\n",(0,s.jsx)(t.p,{children:"Get the path, name, and extension of the file."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE PURE SUBROUTINE getFileParts( obj, path, fileName, ext )\n  CLASS( AbstractFile_ ), INTENT( IN ) :: obj\n  TYPE( String ), INTENT( OUT ) :: path\n  TYPE( String ), INTENT( OUT ) :: fileName\n  TYPE( String ), INTENT( OUT ) :: ext\nEND SUBROUTINE getFileParts\nEND INTERFACE\n\n"})}),"\n",(0,s.jsx)(t.h2,{id:"enquiremethods",children:"EnquireMethods"}),"\n",(0,s.jsx)(t.h3,{id:"isopen",children:"IsOpen"}),"\n",(0,s.jsx)(t.p,{children:"Returns true if the file is open"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-forran",children:"INTERFACE\nMODULE FUNCTION isOpen( obj ) RESULT( ans )\n  CLASS( AbstractFile_ ), INTENT( IN ) :: obj\n  LOGICAL( LGT ) :: ans\nEND FUNCTION isOpen\nEND INTERFACE\n"})}),"\n",(0,s.jsx)(t.h3,{id:"iseof",children:"IsEOF"}),"\n",(0,s.jsx)(t.p,{children:"Returns true if end of file is reached."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE FUNCTION isEOF( obj ) RESULT( ans )\n  CLASS( AbstractFile_ ), INTENT( IN ) :: obj\n  LOGICAL( LGT ) :: ans\nEND FUNCTION isEOF\nEND INTERFACE\n"})}),"\n",(0,s.jsx)(t.h3,{id:"isread",children:"IsRead"}),"\n",(0,s.jsx)(t.p,{children:"Returns true if the file is opened with read access."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE FUNCTION isRead( obj ) RESULT( ans )\n  CLASS( AbstractFile_ ), INTENT( IN ) :: obj\n  LOGICAL( LGT ) :: ans\nEND FUNCTION isRead\nEND INTERFACE\n"})}),"\n",(0,s.jsx)(t.h3,{id:"iswrite",children:"IsWrite"}),"\n",(0,s.jsx)(t.p,{children:"Returns true if the file is opened with write access."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-fortran",children:"INTERFACE\nMODULE FUNCTION isWrite( obj ) RESULT( ans )\n  CLASS( AbstractFile_ ), INTENT( IN ) :: obj\n  LOGICAL( LGT ) :: ans\nEND FUNCTION isWrite\nEND INTERFACE\n\n"})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},54213:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>r});var i=n(36672);const s={},a=i.createContext(s);function l(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);