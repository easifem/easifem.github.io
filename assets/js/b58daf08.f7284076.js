"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[59601],{21226:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Kdtree2/Kdtree2_","title":"Structure","description":"The structure of Kdtree2_ is given below.","source":"@site/docs/docs-api/Kdtree2/Kdtree2_.md","sourceDirName":"Kdtree2","slug":"/Kdtree2/Kdtree2_","permalink":"/docs-api/Kdtree2/Kdtree2_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/Kdtree2/Kdtree2_.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Kdtree2","permalink":"/docs-api/Kdtree2/"},"next":{"title":"Kdtree2Node","permalink":"/docs-api/Kdtree2/Kdtree2Node_"}}');var o=n(23420),a=n(54213);const i={sidebar_position:2},s="Structure",d={},c=[];function u(e){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"structure",children:"Structure"})}),"\n",(0,o.jsxs)(t.p,{children:["The structure of ",(0,o.jsx)(t.code,{children:"Kdtree2_"})," is given below."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-fortran",children:"TYPE :: Kdtree2_\n  ! Global information about the tree, one per tree\n  INTEGER :: dimen = 0, n = 0\n  ! dimensionality and total # of points\n  REAL(kdkind), POINTER :: the_data(:, :) => NULL()\n  ! pointer to the actual data array\n  !\n  !  IMPORTANT NOTE:  IT IS DIMENSIONED   the_data(1:d,1:N)\n  !  which may be opposite of what may be conventional.\n  !  This is, because in Fortran, the memory layout is such that\n  !  the first dimension is in sequential order.  Hence, with\n  !  (1:d,1:N), all components of the vector will be in consecutive\n  !  memory locations.  The search time is dominated by the\n  !  evaluation of distances in the terminal nodes.  Putting all\n  !  vector components in consecutive memory location improves\n  !  memory cache locality, and hence search speed, and may enable\n  !  vectorization on some processors and compilers.\n\n  INTEGER, POINTER :: ind(:) => NULL()\n  ! permuted index into the data, so that indexes[l..u] of some\n  ! bucket represent the indexes of the actual points in that\n  ! bucket.\n  LOGICAL :: sort = .FALSE.\n  ! do we always sort output results?\n  LOGICAL :: rearrange = .FALSE.\n  REAL(kdkind), POINTER :: rearranged_data(:, :) => NULL()\n  ! if (rearrange .eqv. .true.) then rearranged_data has been\n  ! created so that rearranged_data(:,i) = the_data(:,ind(i)),\n  ! permitting search to use more cache-friendly rearranged_data, at\n  ! some initial computation and storage cost.\n  TYPE(Kdtree2Node_), POINTER :: root => NULL()\n  ! root pointer of the tree\nEND TYPE Kdtree2_\n"})})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},54213:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var r=n(36672);const o={},a=r.createContext(o);function i(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);