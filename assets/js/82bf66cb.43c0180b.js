"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[14762],{70856:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>c,default:()=>T,frontMatter:()=>m,metadata:()=>l,toc:()=>E});const l=JSON.parse('{"id":"FEDomainConnectivity/InitiateCellToCellData","title":"InitiateCellToCellData","description":"This routine initiates cellToCell data (mapping) between two Domain or Mesh.","source":"@site/docs/docs-api/FEDomainConnectivity/InitiateCellToCellData.md","sourceDirName":"FEDomainConnectivity","slug":"/FEDomainConnectivity/InitiateCellToCellData","permalink":"/docs-api/FEDomainConnectivity/InitiateCellToCellData","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/FEDomainConnectivity/InitiateCellToCellData.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"GlobalFacetID","permalink":"/docs-api/FEDomainConnectivity/GlobalFacetID"},"next":{"title":"InitiateFacetToCellData","permalink":"/docs-api/FEDomainConnectivity/InitiateFacetToCellData"}}');var o=i(23420),t=i(54213);function a(e){const n={code:"code",pre:"pre",...(0,t.R)(),...e.components};return(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-fortran",children:'PROGRAM main\nUSE GlobalData\nUSE Test_Method\nUSE Display_Method\nUSE HDF5File_Class\nUSE FEDomain_Class\nUSE FEDomainConnectivity_Class\nUSE ExceptionHandler_Class\n\nIMPLICIT NONE\n\nCHARACTER(*), PARAMETER :: domain1_filename = &\n                           "../../Mesh/examples/meshdata/small_tri6_mesh.h5"\n\nCHARACTER(*), PARAMETER :: domain2_filename = &\n                           "../../Mesh/examples/meshdata/small_tri3_mesh.h5"\n\nINTEGER(I4B), PARAMETER :: nsd = 2\n\nTYPE(FEDomainConnectivity_) :: obj\nTYPE(FEDomain_) :: domain2, domain1\nTYPE(HDF5File_) :: domain1_file, domain2_file\n\nINTEGER(I4B), POINTER :: cellToCell(:)\nINTEGER(I4B) :: ii, iel, telems\nLOGICAL(LGT) :: isok\n\n! Open the mesh file for pressure and velocity domain\n\nCALL e%SetQuietMode(EXCEPTION_INFORMATION, .TRUE.)\n\nCALL domain1_file%Initiate(domain1_filename, MODE="READ")\nCALL domain1_file%OPEN()\nCALL domain2_file%Initiate(domain2_filename, MODE="READ")\nCALL domain2_file%OPEN()\n\n! Initiate the domain for pressure and velocity\n\nCALL domain1%Initiate(domain1_file, "")\nCALL domain2%Initiate(domain2_file, "")\n\nCALL obj%InitiateCellToCellData(domain1=domain1, &\n                                domain2=domain2)\n\ncellToCell => obj%GetCellToCellPointer()\n\n! CALL Display(celltoCell, "cellToCEll", full=.TRUE.)\n\ntelems = domain1%GetTotalElements(dim=nsd)\n\nDO iel = 1, telems\n\n  isok = iel .LE. SIZE(cellToCell)\n  IF (.NOT. isok) THEN\n    CALL Fail("CellToCell: iel is out of bound")\n    RETURN\n  END IF\n\n  !! here i am checking if the cellToCell(iel) is present in\n  !! in the pressure domain or not.\n  !! If it is present then it should be a cell element.\n  ii = cellToCell(iel)\n\n  isok = ii .NE. 0\n  IF (.NOT. isok) THEN\n    CALL Fail("CellToCell: error code 1")\n    RETURN\n  END IF\n\n  isok = domain2%isElementPresent(globalElement=ii, islocal=.FALSE., dim=nsd)\n  IF (.NOT. isok) THEN\n    call Display(msg="global element = " // tostring(ii) // " is not present in domain2" )\n    CALL Fail("CellToCell: error code 2")\n    RETURN\n  END IF\n\nEND DO\nCALL PASS("InitiateCellToCellData()")\n\nCALL domain2_file%DEALLOCATE()\nCALL domain1_file%DEALLOCATE()\nCALL domain2%DEALLOCATE()\nCALL domain1%DEALLOCATE()\nCALL obj%DEALLOCATE()\nEND PROGRAM main\n'})})}function s(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}function d(e){const n={code:"code",pre:"pre",...(0,t.R)(),...e.components};return(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-fortran",children:'PROGRAM main\nUSE easifemBase\nUSE easifemClasses\nUSE FEDomain_Class\nUSE FEDomainConnectivity_Class\n\nIMPLICIT NONE\n\nCHARACTER(*), PARAMETER :: velocity_filename = &\n                           "../../Mesh/examples/meshdata/small_tri3_mesh.h5"\n\nCHARACTER(*), PARAMETER :: pressure_filename = &\n                           "../../Mesh/examples/meshdata/small_tri6_mesh.h5"\n\nTYPE(FEDomainConnectivity_) :: obj\nTYPE(FEDomain_) :: pressureDomain\nTYPE(FEDomain_) :: velocityDomain\nTYPE(HDF5File_) :: pressureMeshFile\nTYPE(HDF5File_) :: velocityMeshFile\n\nINTEGER(I4B), POINTER :: cellToCell(:)\nINTEGER(I4B) :: ii, iel, a, b\nLOGICAL(LGT) :: isok\n\n! Open the mesh file for pressure and velocity domain\n\nCALL e%SetQuietMode(EXCEPTION_INFORMATION, .TRUE.)\n\nCALL velocityMeshFile%Initiate(velocity_filename, MODE="READ")\nCALL velocityMeshFile%OPEN()\nCALL pressureMeshFile%Initiate(pressure_filename, MODE="READ")\nCALL pressureMeshFile%OPEN()\n\n! Initiate the domain for pressure and velocity\n\nCALL velocityDomain%Initiate(velocityMeshFile, "")\nCALL pressureDomain%Initiate(pressureMeshFile, "")\n\nCALL obj%InitiateCellToCellData(domain1=velocityDomain, &\n  & domain2=pressureDomain)\n\ncellToCell => obj%GetCellToCellPointer()\nCALL velocityDomain%GetParam(minElemNum=a, maxElemNum=b)\n\nDO iel = a, b\n\n  IF (.NOT. velocityDomain%isElementPresent(iel)) CYCLE\n\n  !! here i am checking if the cellToCell(iel) is present in\n  !! in the pressure domain or not.\n  !! If it is present then it should be a cell element.\n  ii = cellToCell(iel)\n\n  isok = ii .NE. 0\n  IF (.NOT. isok) THEN\n    CALL fail("CellToCell: error code 1")\n    RETURN\n  END IF\n\n  isok = pressureDomain%isElementPresent(ii)\n  IF (.NOT. isok) THEN\n    CALL fail("CellToCell: error code 2")\n    RETURN\n  END IF\n\nEND DO\nCALL PASS("InitiateCellToCellData()")\n\nCALL pressureMeshFile%DEALLOCATE()\nCALL velocityMeshFile%DEALLOCATE()\nCALL pressureDomain%DEALLOCATE()\nCALL velocityDomain%DEALLOCATE()\nCALL obj%DEALLOCATE()\nEND PROGRAM main\n'})})}function r(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}const m={},c="InitiateCellToCellData",h={},E=[{value:"Interface 1",id:"interface-1",level:2},{value:"Interface 2",id:"interface-2",level:2}];function C(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{TabItem:i,Tabs:l}=n;return i||u("TabItem",!0),l||u("Tabs",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"initiatecelltocelldata",children:"InitiateCellToCellData"})}),"\n",(0,o.jsxs)(n.p,{children:["This routine initiates ",(0,o.jsx)(n.code,{children:"cellToCell"})," data (mapping) between two ",(0,o.jsx)(n.a,{href:"/docs-api/Domain/Domain_",children:"Domain_"})," or ",(0,o.jsx)(n.a,{href:"/docs-api/Mesh/Mesh_",children:"Mesh_"}),"."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The topology of elements in both meshes should be the same, this means that if one mesh is made of triangles then other mesh should be made of triangles."}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"xidim"})," of the elements in both meshes should be the same, this means that if the ",(0,o.jsx)(n.code,{children:"mesh1"})," is surface mesh then ",(0,o.jsx)(n.code,{children:"mesh2"})," should be a surface mesh."]}),"\n",(0,o.jsxs)(n.li,{children:["This routine needs ",(0,o.jsx)(n.code,{children:"nodeToNode"})," information, so make sure it is initiated before calling this routine."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"interface-1",children:"Interface 1"}),"\n",(0,o.jsxs)(l,{children:[(0,o.jsxs)(i,{value:"interface",label:"Interface",default:!0,children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE InitiateCellToCellData(obj, domain1, domain2)\n    CLASS(DomainConnectivity_), INTENT(INOUT) :: obj\n    !! Domain connectivity object\n    CLASS(Domain_), INTENT(IN) :: domain1\n    !! Primary domain, in CellToCell(i), i denotes the\n    !! global element number in domain1 domain.\n    CLASS(Domain_), INTENT(IN) :: domain2\n    !! Secondary domain => CellToCell(i) denotes the\n    !! global element number in domain2 domain.\n  END SUBROUTINE InitiateCellToCellData\nEND INTERFACE\n"})}),(0,o.jsx)(n.p,{children:"This subroutine generates the cell to cell connectivity between\ntwo domains."}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"obj%cellToCell"})," will be initiated"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"domain1"})," main domain"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"domain2"})," secondary domain"]}),"\n"]}),(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["All ",(0,o.jsx)(n.strong,{children:"CELL"})," elements in domain-1 will be mapped to ",(0,o.jsx)(n.strong,{children:"CELL"})," elements in domain-2."]})}),(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["If ",(0,o.jsx)(n.code,{children:"cellToCell(iel)"})," is equal to zero then it means there is no element found in domain-2 corresponding to element number iel in domain-1."]})}),(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["The size of ",(0,o.jsx)(n.code,{children:"cellToCell"})," is the largest element number present in domain1."]})}),(0,o.jsx)(n.admonition,{title:"TODO",type:"info",children:(0,o.jsx)(n.p,{children:"Currently, lowerbound and upper bound of cellToCell is 1 and domain1%maxElemNumber. In the future, the lower bound will be domain1%minElemNumber."})}),(0,o.jsx)(n.p,{children:"Following points should be noted before calling this routine"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"This routine provides map between cell elements of one domain to cell elements of another domain."}),"\n",(0,o.jsx)(n.li,{children:"The topology of the both elements should be the same"}),"\n",(0,o.jsx)(n.li,{children:"There is one to one mapping between elements of domain 1 and elements of domain2"}),"\n",(0,o.jsx)(n.li,{children:"This routine works well for two domains of same region with same/different order. For example, domain of tri3 and domain of tri6 elements."}),"\n"]})]}),(0,o.jsx)(i,{value:"example",label:"example",children:(0,o.jsx)(s,{})}),(0,o.jsx)(i,{value:"close",label:"\u21a2 close"})]}),"\n",(0,o.jsx)(n.h2,{id:"interface-2",children:"Interface 2"}),"\n",(0,o.jsxs)(l,{children:[(0,o.jsxs)(i,{value:"interface",label:"Interface",default:!0,children:[(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE dc_initiateCellToCellData1(obj, domain1, domain2, &\n    & dim1, dim2, entityNum1, entityNum2)\n    CLASS(DomainConnectivity_), INTENT(INOUT) :: obj\n    !! Domain connectivity object,\n    !! [[DomainConnectivity:cellToCell]] will be initiated\n    CLASS(Domain_), INTENT(IN) :: domain1\n    !! Primary domain, in cellToCell(i), i denotes the\n    !! global element number in domain1 domain.\n    CLASS(Domain_), INTENT(IN) :: domain2\n    !! secondary domain, => cellToCell(i) denotes the\n    !! global cell number in `domain2` domain.\n    INTEGER(I4B), INTENT(IN) :: dim1\n    !! dimension of mesh in domain1\n    INTEGER(I4B), INTENT(IN) :: dim2\n    !! dimension of mesh in domain2\n    INTEGER(I4B), INTENT(IN) :: entityNum1\n    !! entity num of mesh in domain1\n    INTEGER(I4B), INTENT(IN) :: entityNum2\n    !! entity num of mesh in domain2\n  END SUBROUTINE dc_initiateCellToCellData1\nEND INTERFACE\n"})}),(0,o.jsx)(n.p,{children:"This subroutine generates the cell to cell connectivity between two meshes."}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"obj%cellToCell"})," will be initiated"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"domain1"})," main domain"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"domain2"})," secondary domain"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"dim1, entitynum1"})," dimension and entity number of mesh in ",(0,o.jsx)(n.code,{children:"domain1"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"dim2, entitynum2"})," dimension and entity number of mesh in ",(0,o.jsx)(n.code,{children:"domain2"})]}),"\n"]}),(0,o.jsx)(n.p,{children:"Following points should be noted"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The topology of elements in both meshes should be the same, this means that if one mesh is triangle then other mesh should be a triangle."}),"\n",(0,o.jsx)(n.li,{children:"The xidim of the elements in both meshes should be the same, this means that if the mesh1 is surface mesh then mesh2 should be a surface mesh."}),"\n",(0,o.jsxs)(n.li,{children:["This routine needs ",(0,o.jsx)(n.code,{children:"nodeToNode"})," information, so make sure it is initiated before calling this routine."]}),"\n"]})]}),(0,o.jsx)(i,{value:"example",label:"example",children:(0,o.jsx)(r,{})}),(0,o.jsx)(i,{value:"close",label:"\u21a2 close"})]})]})}function T(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(C,{...e})}):C(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},54213:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>s});var l=i(36672);const o={},t=l.createContext(o);function a(e){const n=l.useContext(t);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),l.createElement(t.Provider,{value:n},e.children)}}}]);