"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[60382],{81699:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>s});const l=JSON.parse('{"id":"FEDOF/FEDOF_","title":"Structure","description":"The structure of FEDOF_ is given below.","source":"@site/docs/docs-api/FEDOF/FEDOF_.md","sourceDirName":"FEDOF","slug":"/FEDOF/FEDOF_","permalink":"/docs-api/FEDOF/FEDOF_","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/FEDOF/FEDOF_.md","tags":[{"inline":true,"label":"Domain","permalink":"/docs-api/tags/domain"},{"inline":true,"label":"Mesh","permalink":"/docs-api/tags/mesh"},{"inline":true,"label":"shapeFunctions","permalink":"/docs-api/tags/shape-functions"},{"inline":true,"label":"FEDOF","permalink":"/docs-api/tags/fedof"}],"version":"current","lastUpdatedAt":1737330762000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"date":"2024-09-30T00:00:00.000Z","update":"2024-09-30T00:00:00.000Z","status":"stable","docs":"done","extpkgs":"none","category":["Domain","Mesh","ShapeFunctions","FEDOF"],"tags":["Domain","Mesh","shapeFunctions","FEDOF"]},"sidebar":"tutorialSidebar","previous":{"title":"FEDOF","permalink":"/docs-api/FEDOF/"},"next":{"title":"SetFEDOFParam","permalink":"/docs-api/FEDOF/SetFEDOFParam"}}');var r=o(23420),i=o(54213);const d={sidebar_position:2,date:new Date("2024-09-30T00:00:00.000Z"),update:new Date("2024-09-30T00:00:00.000Z"),status:"stable",docs:"done",extpkgs:"none",category:["Domain","Mesh","ShapeFunctions","FEDOF"],tags:["Domain","Mesh","shapeFunctions","FEDOF"]},t="Structure",c={},s=[{value:"<code>isLagrange</code>",id:"islagrange",level:3},{value:"<code>tdof</code>",id:"tdof",level:3},{value:"<code>tNodes</code>",id:"tnodes",level:3},{value:"<code>tEdges</code>",id:"tedges",level:3},{value:"<code>tFaces</code>",id:"tfaces",level:3},{value:"<code>tCells</code>",id:"tcells",level:3},{value:"<code>maxTotalConnectivity</code>",id:"maxtotalconnectivity",level:3},{value:"<code>baseContinuity</code>",id:"basecontinuity",level:3},{value:"<code>baseInterpolation</code>",id:"baseinterpolation",level:3},{value:"<code>maxCellOrder</code>",id:"maxcellorder",level:3},{value:"<code>maxFaceOrder</code>",id:"maxfaceorder",level:3},{value:"<code>maxEdgeOrder</code>",id:"maxedgeorder",level:3},{value:"<code>cellOrder</code>",id:"cellorder",level:3},{value:"<code>faceOrder</code>",id:"faceorder",level:3},{value:"<code>edgeOrder</code>",id:"edgeorder",level:3},{value:"<code>edgeIA</code>",id:"edgeia",level:3},{value:"<code>faceIA</code>",id:"faceia",level:3},{value:"<code>cellIA</code>",id:"cellia",level:3},{value:"<code>fe</code>",id:"fe",level:3},{value:"<code>mesh</code>",id:"mesh",level:3}];function a(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"structure",children:"Structure"})}),"\n",(0,r.jsxs)(n.p,{children:["The structure of ",(0,r.jsx)(n.code,{children:"FEDOF_"})," is given below."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-fortran",children:'TYPE :: FEDOF_\n  PRIVATE\n  LOGICAL(LGT) :: isLagrange = .FALSE.\n  !! It is true when baseInterpolation is Lagrange\n  INTEGER(I4B) :: tdof = 0\n  !! Total number of degrees of freedom\n  INTEGER(I4B) :: tNodes = 0\n  !! Total number of nodes\n  INTEGER(I4B) :: tEdges = 0\n  !! Total number of edges\n  INTEGER(I4B) :: tFaces = 0\n  !! Total number of faces\n  INTEGER(I4B) :: tCells = 0\n  !! Total number of cells\n  INTEGER(I4B) :: maxTotalConnectivity = 0\n  !! maximum number of connectivity\n\n  CHARACTER(2) :: baseContinuity = "H1"\n  !! continuity or conformity of basis defined on reference\n  !! element, following values are allowed\n  !! H1, HCurl, HDiv, DG\n\n  CHARACTER(4) :: baseInterpolation = "LAGR"\n  !! Type of basis functions used for interpolation on reference\n  !! element, Following values are allowed\n  !! LagrangeInterpolation ! HierarchyInterpolation\n  !! OrthogonalInterpolation ! HermitInterpolation\n  !! SerendipityInterpolation\n\n  INTEGER(INT8) :: maxCellOrder = 0_INT8\n  !! maximum value of cell order\n\n  INTEGER(INT8) :: maxFaceOrder = 0_INT8\n  !! maximum value of face order\n\n  INTEGER(INT8) :: maxEdgeOrder = 0_INT8\n  !! maximum value of edge order\n\n  INTEGER(INT8), ALLOCATABLE :: cellOrder(:)\n  !! Order of each cell\n  !! the size of cellOrder is equal to the obj%tCells\n  !! Get connectivity of an element\n  !! Get entity number of an element\n  !! Get the cell number of an element (this is global element number)\n  !! convert it to the local element number\n  !! use this local element number to get cell order from cellOrder\n\n  INTEGER(INT8), ALLOCATABLE :: faceOrder(:)\n  !! order of each face\n\n  INTEGER(INT8), ALLOCATABLE :: edgeOrder(:)\n  !! order of each edge\n\n  INTEGER(I4B), ALLOCATABLE :: edgeIA(:)\n  !! sparsity for edge, the size of edgeJA is equal to the total number of\n  !! degrees of freedom on edge,\n  !! the size of edgeIA is equal to the total number of edges + 1\n  !! The degrees of freedom of iedge is stored in\n  !! edgeJA(edgeIA(iedge):edgeIA(iedge+1)-1)\n\n  INTEGER(I4B), ALLOCATABLE :: faceIA(:)\n  !! sparsity for face, the size of faceJA is equal to the total number of\n  !! degrees of freedom on face,\n  !! the size of faceIA is equal to the total number of faces + 1\n  !! The degrees of freedom of iface is stored in\n  !! faceJA(faceIA(iface):faceIA(iface+1)-1)\n\n  INTEGER(I4B), ALLOCATABLE :: cellIA(:)\n  !! sparsity for cell, the size of cellJA is equal to the total number of\n  !! degrees of freedom on cell,\n  !! the size of cellIA is equal to the total number of cells + 1\n  !! The degrees of freedom of icell is stored in\n  !! cellJA(cellIA(icell):cellIA(icell+1)-1)\n\n  TYPE(AbstractFEPointer_) :: fe(8)\n  !! pointer to finite element object\n  !! point, line, triangle, quadrangle, tetrahedron, hexahedron, prism,\n  !! pyramid\n\n  CLASS(AbstractMesh_), POINTER :: mesh => NULL()\n  !! Pointer to domain\nEND TYPE FEDOF_\n'})}),"\n",(0,r.jsx)(n.h3,{id:"islagrange",children:(0,r.jsx)(n.code,{children:"isLagrange"})}),"\n",(0,r.jsxs)(n.p,{children:["It is true when ",(0,r.jsx)(n.code,{children:"baseInterpolation"})," is Lagrange"]}),"\n",(0,r.jsx)(n.h3,{id:"tdof",children:(0,r.jsx)(n.code,{children:"tdof"})}),"\n",(0,r.jsx)(n.p,{children:"Total number of degrees of freedom"}),"\n",(0,r.jsx)(n.h3,{id:"tnodes",children:(0,r.jsx)(n.code,{children:"tNodes"})}),"\n",(0,r.jsx)(n.p,{children:"Total number of nodes"}),"\n",(0,r.jsx)(n.h3,{id:"tedges",children:(0,r.jsx)(n.code,{children:"tEdges"})}),"\n",(0,r.jsx)(n.p,{children:"Total number of edges"}),"\n",(0,r.jsx)(n.h3,{id:"tfaces",children:(0,r.jsx)(n.code,{children:"tFaces"})}),"\n",(0,r.jsx)(n.p,{children:"Total number of faces"}),"\n",(0,r.jsx)(n.h3,{id:"tcells",children:(0,r.jsx)(n.code,{children:"tCells"})}),"\n",(0,r.jsx)(n.p,{children:"Total number of cells"}),"\n",(0,r.jsx)(n.h3,{id:"maxtotalconnectivity",children:(0,r.jsx)(n.code,{children:"maxTotalConnectivity"})}),"\n",(0,r.jsx)(n.p,{children:"Maximum number of connectivity."}),"\n",(0,r.jsx)(n.h3,{id:"basecontinuity",children:(0,r.jsx)(n.code,{children:"baseContinuity"})}),"\n",(0,r.jsx)(n.p,{children:"Continuity or conformity of basis defined on reference element, following values are allowed"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"H1"}),"\n",(0,r.jsx)(n.li,{children:"HCurl"}),"\n",(0,r.jsx)(n.li,{children:"HDiv"}),"\n",(0,r.jsx)(n.li,{children:"DG"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"baseinterpolation",children:(0,r.jsx)(n.code,{children:"baseInterpolation"})}),"\n",(0,r.jsx)(n.p,{children:"Type of basis functions used for interpolation on reference element, Following values are allowed"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"LagrangeInterpolation"}),"\n",(0,r.jsx)(n.li,{children:"HierarchyInterpolation"}),"\n",(0,r.jsx)(n.li,{children:"OrthogonalInterpolation"}),"\n",(0,r.jsx)(n.li,{children:"HermitInterpolation"}),"\n",(0,r.jsx)(n.li,{children:"SerendipityInterpolation"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"maxcellorder",children:(0,r.jsx)(n.code,{children:"maxCellOrder"})}),"\n",(0,r.jsx)(n.p,{children:"Maximum value of cell order."}),"\n",(0,r.jsx)(n.h3,{id:"maxfaceorder",children:(0,r.jsx)(n.code,{children:"maxFaceOrder"})}),"\n",(0,r.jsx)(n.p,{children:"Maximum value of face order."}),"\n",(0,r.jsx)(n.h3,{id:"maxedgeorder",children:(0,r.jsx)(n.code,{children:"maxEdgeOrder"})}),"\n",(0,r.jsx)(n.p,{children:"Maximum value of edge order."}),"\n",(0,r.jsx)(n.h3,{id:"cellorder",children:(0,r.jsx)(n.code,{children:"cellOrder"})}),"\n",(0,r.jsxs)(n.p,{children:["Order of each cell. The size of ",(0,r.jsx)(n.code,{children:"cellOrder"})," is equal to the ",(0,r.jsx)(n.code,{children:"obj%tCells"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"The process is as follows:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Get connectivity of an element."}),"\n",(0,r.jsx)(n.li,{children:"Get entity number of an element."}),"\n",(0,r.jsxs)(n.li,{children:["Get the cell number of an element (this is global element number) convert it to the local element number use this local element number to get cell order from ",(0,r.jsx)(n.code,{children:"cellOrder"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"faceorder",children:(0,r.jsx)(n.code,{children:"faceOrder"})}),"\n",(0,r.jsx)(n.p,{children:"Order of each face."}),"\n",(0,r.jsx)(n.h3,{id:"edgeorder",children:(0,r.jsx)(n.code,{children:"edgeOrder"})}),"\n",(0,r.jsx)(n.p,{children:"Order of each edge."}),"\n",(0,r.jsx)(n.h3,{id:"edgeia",children:(0,r.jsx)(n.code,{children:"edgeIA"})}),"\n",(0,r.jsxs)(n.p,{children:["Sparsity for edge, the size of ",(0,r.jsx)(n.code,{children:"edgeJA"})," is equal to the total number of degrees of freedom on edge, the size of ",(0,r.jsx)(n.code,{children:"edgeIA"})," is equal to the total number of ",(0,r.jsx)(n.code,{children:"edges + 1"}),". The degrees of freedom of ",(0,r.jsx)(n.code,{children:"iedge"})," is stored in ",(0,r.jsx)(n.code,{children:"edgeJA(edgeIA(iedge)):edgeIA(iedge+1)-1))"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"faceia",children:(0,r.jsx)(n.code,{children:"faceIA"})}),"\n",(0,r.jsxs)(n.p,{children:["Sparsity for face. The size of ",(0,r.jsx)(n.code,{children:"faceIA"})," is equal to the total number of degrees of freedom on face, the size of ",(0,r.jsx)(n.code,{children:"faceIA"})," is equal to the total number of ",(0,r.jsx)(n.code,{children:"faces + 1"}),". The degrees of freedom of ",(0,r.jsx)(n.code,{children:"iface"})," is stored in ",(0,r.jsx)(n.code,{children:"faceJA(faceIA(iface):faceIA(iface+1)-1)"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"cellia",children:(0,r.jsx)(n.code,{children:"cellIA"})}),"\n",(0,r.jsxs)(n.p,{children:["Sparsity for cell. The size of ",(0,r.jsx)(n.code,{children:"cellIA"})," is equal to the total number of degrees of freedom on cell. The size of ",(0,r.jsx)(n.code,{children:"cellIA"})," is equal to the total number of ",(0,r.jsx)(n.code,{children:"cells + 1"}),". The degrees of freedom of ",(0,r.jsx)(n.code,{children:"icell"})," is stored in ",(0,r.jsx)(n.code,{children:"cellJA(cellIA(icell)):cellIA(icell+1)-1))"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"fe",children:(0,r.jsx)(n.code,{children:"fe"})}),"\n",(0,r.jsx)(n.p,{children:"Pointer to finite element object point, line, triangle, quadrangle, tetrahedron, hexahedron, prism, pyramid."}),"\n",(0,r.jsx)(n.h3,{id:"mesh",children:(0,r.jsx)(n.code,{children:"mesh"})}),"\n",(0,r.jsx)(n.p,{children:"Pointer to domain."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},54213:(e,n,o)=>{o.d(n,{R:()=>d,x:()=>t});var l=o(36672);const r={},i=l.createContext(r);function d(e){const n=l.useContext(i);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),l.createElement(i.Provider,{value:n},e.children)}}}]);