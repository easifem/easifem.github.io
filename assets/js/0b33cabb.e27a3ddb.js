"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[10579],{69125:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"SuperLU/formats","title":"Formats","description":"Yesnot","source":"@site/docs/docs-api/SuperLU/formats.md","sourceDirName":"SuperLU","slug":"/SuperLU/formats","permalink":"/docs-api/SuperLU/formats","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/SuperLU/formats.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Utility","permalink":"/docs-api/SuperLU/dutil"},"next":{"title":"Options","permalink":"/docs-api/SuperLU/options"}}');var r=t(23420),_=t(54213);const a={},i="Formats",s={},l=[{value:"Yes_no_t",id:"yes_no_t",level:2},{value:"Fact_t",id:"fact_t",level:2},{value:"RowPerm_t",id:"rowperm_t",level:2},{value:"ColPerm_t",id:"colperm_t",level:2},{value:"Trans_t",id:"trans_t",level:2},{value:"DiagScale_t",id:"diagscale_t",level:2},{value:"IterRefine_t",id:"iterrefine_t",level:2},{value:"MemType_t",id:"memtype_t",level:2},{value:"Stack_end_t",id:"stack_end_t",level:2},{value:"LU_space_t",id:"lu_space_t",level:2},{value:"Norm_t",id:"norm_t",level:2},{value:"Milu_t",id:"milu_t",level:2},{value:"MType_t",id:"mtype_t",level:2},{value:"DType_t",id:"dtype_t",level:2},{value:"SType_t",id:"stype_t",level:2},{value:"NCFormat",id:"ncformat",level:2},{value:"NRFormat",id:"nrformat",level:2},{value:"SCformat",id:"scformat",level:2},{value:"SCPformat",id:"scpformat",level:2},{value:"NCPformat",id:"ncpformat",level:2},{value:"DNformat",id:"dnformat",level:2},{value:"<code>superlu_options_t</code>",id:"superlu_options_t",level:2},{value:"SuperLUStat_t",id:"superlustat_t",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,_.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"formats",children:"Formats"})}),"\n",(0,r.jsx)(e.h2,{id:"yes_no_t",children:"Yes_no_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"TYPE :: yes_no_\n  INTEGER(C_INT) :: NO, YES\nEND TYPE yes_no_\n\nTYPE(yes_no_), PUBLIC, PARAMETER :: yes_no_t = yes_no_(NO, YES)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"fact_t",children:"Fact_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"TYPE :: fact_\n  INTEGER(C_INT) :: DOFACT, SamePattern, SamePattern_SameRowPerm, FACTORED\nEND TYPE fact_\n\nTYPE(fact_), PUBLIC, PARAMETER :: fact_t = fact_(&\n  & DOFACT, SamePattern, SamePattern_SameRowPerm, FACTORED)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"rowperm_t",children:"RowPerm_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"TYPE :: rowperm_\n  INTEGER(C_INT) :: NOROWPERM, LargeDiag_MC64, LargeDiag_HWPM, MY_PERMR\nEND TYPE rowperm_\n\nTYPE(rowperm_), PUBLIC, PARAMETER :: rowperm_t = rowperm_( &\n  & NOROWPERM, LargeDiag_MC64, LargeDiag_HWPM, MY_PERMR)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"colperm_t",children:"ColPerm_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"\nTYPE :: colperm_\n  INTEGER(C_INT) :: NATURAL, MMD_ATA, MMD_AT_PLUS_A, COLAMD, &\n   & METIS_AT_PLUS_A, PARMETIS, ZOLTAN, MY_PERMC\nEND TYPE\n\nTYPE(colperm_), PUBLIC, PARAMETER :: colperm_t = colperm_(&\n  & NATURAL, MMD_ATA, MMD_AT_PLUS_A, COLAMD, &\n  & METIS_AT_PLUS_A, PARMETIS, ZOLTAN, MY_PERMC)\n\n"})}),"\n",(0,r.jsx)(e.h2,{id:"trans_t",children:"Trans_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"TYPE :: trans_\n  INTEGER(C_INT) :: NOTRANS, TRANS, CONJ\nEND TYPE\n\nTYPE(trans_), PARAMETER, PUBLIC :: trans_t = trans_(&\n  & NOTRANS, TRANS, CONJ)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"diagscale_t",children:"DiagScale_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"\nTYPE :: DiagScale_\n  INTEGER(C_INT) :: NOEQUIL, ROW, COL, BOTH\nEND TYPE\n\nTYPE(DiagScale_), PUBLIC, PARAMETER :: DiagScale_t = DiagScale_(&\n& NOEQUIL, ROW, COL, BOTH)\n\n"})}),"\n",(0,r.jsx)(e.h2,{id:"iterrefine_t",children:"IterRefine_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"TYPE :: IterRefine_\n  INTEGER(C_INT) :: NOREFINE, SLU_SINGLE = 1, SLU_DOUBLE, SLU_EXTRA\nEND TYPE\n\nTYPE(IterRefine_), PUBLIC, PARAMETER :: IterRefine_t = IterRefine_(&\n  & NOREFINE, SLU_SINGLE, SLU_DOUBLE, SLU_EXTRA)\n\n"})}),"\n",(0,r.jsx)(e.h2,{id:"memtype_t",children:"MemType_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"TYPE :: MemType_\n  INTEGER(C_INT) :: USUB, LSUB, UCOL, LUSUP, LLVL, ULVL, NO_MEMTYPE\nEND TYPE MemType_\n\nTYPE(MemType_), PUBLIC, PARAMETER :: MemType_t = MemType_(&\n  & USUB, LSUB, UCOL, LUSUP, LLVL, ULVL, NO_MEMTYPE)\n\n"})}),"\n",(0,r.jsx)(e.h2,{id:"stack_end_t",children:"Stack_end_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"\nTYPE :: stack_end_\n  INTEGER(C_INT) :: HEAD, TAIL\nEND TYPE\n\nTYPE(stack_end_), PUBLIC, PARAMETER :: stack_end_t = stack_end_(&\n & HEAD, TAIL)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"lu_space_t",children:"LU_space_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"\nTYPE :: LU_space_\n  INTEGER(C_INT) :: SYSTEM, USER\nEND TYPE\n\nTYPE(LU_space_), PARAMETER, PUBLIC :: LU_space_t = LU_space_(&\n& SYSTEM, USER)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"norm_t",children:"Norm_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"\nTYPE :: norm_\n  INTEGER(C_INT) :: ONE_NORM, TWO_NORM, INF_NORM\nEND TYPE\n\nTYPE(norm_), PUBLIC, PARAMETER :: norm_t = norm_(&\n & ONE_NORM, TWO_NORM, INF_NORM)\n\n"})}),"\n",(0,r.jsx)(e.h2,{id:"milu_t",children:"Milu_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"\nTYPE :: milu_\n  INTEGER(C_INT) :: SILU, SMILU_1, SMILU_2, SMILU_3\nEND TYPE milu_\n\nTYPE(milu_), PARAMETER, PUBLIC :: milu_t = milu_(&\n  &  SILU, SMILU_1, SMILU_2, SMILU_3)\n\n"})}),"\n",(0,r.jsx)(e.h2,{id:"mtype_t",children:"MType_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"TYPE :: Mtype_\n  INTEGER(C_INT) :: SLU_GE\n  INTEGER(C_INT) :: SLU_TRLU\n  INTEGER(C_INT) :: SLU_TRUU\n  INTEGER(C_INT) :: SLU_TRL\n  INTEGER(C_INT) :: SLU_TRU\n  INTEGER(C_INT) :: SLU_SYL\n  INTEGER(C_INT) :: SLU_SYU\n  INTEGER(C_INT) :: SLU_HEL\n  INTEGER(C_INT) :: SLU_HEU\nEND TYPE Mtype_\n\n\nTYPE(Mtype_), PUBLIC, PARAMETER :: Mtype_t = Mtype_(&\n  & SLU_GE=SLU_GE, &\n  & SLU_TRLU=SLU_TRLU, &\n  & SLU_TRUU=SLU_TRUU, &\n  & SLU_TRL=SLU_TRL, &\n  & SLU_TRU=SLU_TRU, &\n  & SLU_SYL=SLU_SYL, &\n  & SLU_SYU=SLU_SYU, &\n  & SLU_HEL=SLU_HEL, &\n  & SLU_HEU=SLU_HEU)\n\n"})}),"\n",(0,r.jsx)(e.h2,{id:"dtype_t",children:"DType_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"TYPE :: Dtype_\n  INTEGER(C_INT) :: SLU_S\n  INTEGER(C_INT) :: SLU_D\n  INTEGER(C_INT) :: SLU_C\n  INTEGER(C_INT) :: SLU_Z\nEND TYPE Dtype_\n\n\nTYPE(Dtype_), PARAMETER, PUBLIC :: Dtype_t = Dtype_(&\n  & SLU_S=SLU_S, &\n  & SLU_D=SLU_D, &\n  & SLU_C=SLU_C, &\n  & SLU_Z=SLU_Z)\n\n"})}),"\n",(0,r.jsx)(e.h2,{id:"stype_t",children:"SType_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"TYPE :: Stype_\n  INTEGER(C_INT) :: SLU_NC\n  INTEGER(C_INT) :: SLU_NCP\n  INTEGER(C_INT) :: SLU_NR\n  INTEGER(C_INT) :: SLU_SC\n  INTEGER(C_INT) :: SLU_SCP\n  INTEGER(C_INT) :: SLU_SR\n  INTEGER(C_INT) :: SLU_DN\n  INTEGER(C_INT) :: SLU_NR_LOC\nEND TYPE Stype_\n\n\nTYPE(Stype_), PARAMETER, PUBLIC :: Stype_t = Stype_(&\n  & SLU_NC=SLU_NC, &\n  & SLU_NCP=SLU_NCP, &\n  & SLU_NR=SLU_NR, &\n  & SLU_SC=SLU_SC, &\n  & SLU_SCP=SLU_SCP, &\n  & SLU_SR=SLU_SR, &\n  & SLU_DN=SLU_DN, &\n  & SLU_NR_LOC=SLU_NR_LOC &\n  & )\n\n"})}),"\n",(0,r.jsx)(e.h2,{id:"ncformat",children:"NCFormat"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"! typedef struct {\n!   int_t nnz;     /* number of nonzeros in the matrix */\n!   void *nzval;   /* pointer to array of nonzero values, packed by column */\n!   int_t *rowind; /* pointer to array of row indices of the nonzeros */\n!   int_t *colptr; /* pointer to array of beginning of columns in nzval[]\n!                     and rowind[]  */\n!                  /* Note:\n!                     Zero-based indexing is used;\n!                     colptr[] has ncol+1 entries, the last one pointing\n!                     beyond the last column, so that colptr[ncol] = nnz. */\n! } NCformat;\n\nTYPE, BIND(c) :: NCformat\n  INTEGER(C_INT) :: nnz\n  TYPE(C_PTR) :: nzval\n  TYPE(C_PTR) :: rowind\n  TYPE(C_PTR) :: colptr\nEND TYPE NCformat\n\nPUBLIC :: NCformat\n"})}),"\n",(0,r.jsx)(e.h2,{id:"nrformat",children:"NRFormat"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"! typedef struct {\n!   int_t nnz;     /* number of nonzeros in the matrix */\n!   void *nzval;   /* pointer to array of nonzero values, packed by raw */\n!   int_t *colind; /* pointer to array of columns indices of the nonzeros */\n!   int_t *rowptr; /* pointer to array of beginning of rows in nzval[]\n!                     and colind[]  */\n!                  /* Note:\n!                     Zero-based indexing is used;\n!                     rowptr[] has nrow+1 entries, the last one pointing\n!                     beyond the last row, so that rowptr[nrow] = nnz. */\n! } NRformat;\n\nTYPE, BIND(c) :: NRformat\n  INTEGER(C_INT) :: nnz\n  TYPE(C_PTR) :: nzval\n  TYPE(C_PTR) :: colind\n  TYPE(C_PTR) :: rowptr\nEND TYPE NRformat\n\nPUBLIC :: NRformat\n"})}),"\n",(0,r.jsx)(e.h2,{id:"scformat",children:"SCformat"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"! typedef struct {\n!   int_t nnz;    /* number of nonzeros in the matrix */\n!   int_t nsuper; /* number of supernodes, minus 1 */\n!   void *nzval;  /* pointer to array of nonzero values, packed by column */\n!   int_t *nzval_colptr; /* pointer to array of beginning of columns in nzval[] */\n!   int_t *rowind;       /* pointer to array of compressed row indices of\n!                           rectangular supernodes */\n!   int_t\n!       *rowind_colptr; /* pointer to array of beginning of columns in rowind[] */\n!   int_t *col_to_sup;  /* col_to_sup[j] is the supernode number to which column\n!                        j belongs; mapping from column to supernode number. */\n!   int_t *sup_to_col;  /* sup_to_col[s] points to the start of the s-th\n!                        supernode; mapping from supernode number to column.\n!                        e.g.: col_to_sup: 0 1 2 2 3 3 3 4 4 4 4 4 4 (ncol=12)\n!                              sup_to_col: 0 1 2 4 7 12           (nsuper=4) */\n!                       /* Note:\n!                          Zero-based indexing is used;\n!                          nzval_colptr[], rowind_colptr[], col_to_sup and\n!                          sup_to_col[] have ncol+1 entries, the last one\n!                          pointing beyond the last column.\n!                          For col_to_sup[], only the first ncol entries are\n!                          defined. For sup_to_col[], only the first nsuper+2\n!                          entries are defined. */\n! } SCformat;\n!\n\nTYPE, BIND(c) :: SCformat\n  INTEGER(C_INT) :: nnz\n  INTEGER(C_INT) :: nsuper\n  TYPE(C_PTR) :: nzval\n  TYPE(C_PTR) :: nzval_colptr\n  TYPE(C_PTR) :: rowind\n  TYPE(C_PTR) :: rowind_colptr\n  TYPE(C_PTR) :: col_to_sup\n  TYPE(C_PTR) :: sup_to_col\nEND TYPE SCformat\n"})}),"\n",(0,r.jsx)(e.h2,{id:"scpformat",children:"SCPformat"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"! typedef struct {\n!   int_t nnz;    /*number of nonzeros in the matrix*/\n!   int_t nsuper; /*number of supernodes*/\n!   void *nzval;  /* pointer to array of nonzero values, packed by column */\n!   int_t*nzval_colbeg;  /*nzval_colbeg[j] points to beginning of column j\n!                            in nzval[]*/\n!   int_t *nzval_colend;  /* nzval_colend[j] points to one past the last element\n!                            of column j in nzval[] */\n!   int_t*rowind;        /*pointer to array of compressed row indices of\n!                            rectangular supernodes*/\n!   int_t *rowind_colbeg; /* rowind_colbeg[j] points to beginning of column j\n!                            in rowind[] */\n!   int_t*rowind_colend; /*rowind_colend[j] points to one past the last element\n!                            of column j in rowind[]*/\n!   int_t *col_to_sup;    /* col_to_sup[j] is the supernode number to which column\n!                            j belongs; mapping from column to supernode. */\n!   int_t*sup_to_colbeg; /*sup_to_colbeg[s] points to the start of the s-th\n!                            supernode; mapping from supernode to column.*/\n!   int_t *sup_to_colend; /* sup_to_colend[s] points to one past the end of the\n!                            s-th supernode; mapping from supernode number to\n!                            column.\n!                         e.g.: col_to_sup: 0 1 2 2 3 3 3 4 4 4 4 4 4 (ncol=12)\n!                               sup_to_colbeg: 0 1 2 4 7              (nsuper=4)\n!                               sup_to_colend: 1 2 4 7 12                    */\n!                         /* Note:\n!                            Zero-based indexing is used;\n!                            nzval_colptr[], rowind_colptr[], col_to_sup and\n!                            sup_to_col[] have ncol+1 entries, the last one\n!                            pointing beyond the last column.         */\n! } SCPformat;\n\nTYPE, BIND(c) :: SCPformat\n  INTEGER(C_INT) :: nnz, nsuper\n  TYPE(C_PTR) :: nzval, nzval_colbeg, nzval_colend, rowind, &\n    & rowind_colbeg, rowindx_colend, col_to_sup, sup_to_colbeg, &\n    & sup_to_colend\nEND TYPE SCPformat\n\nPUBLIC :: SCPformat\n"})}),"\n",(0,r.jsx)(e.h2,{id:"ncpformat",children:"NCPformat"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"! typedef struct {\n!   int_t nnz;     /*number of nonzeros in the matrix*/\n!   void *nzval;   /* pointer to array of nonzero values, packed by column */\n!   int_t*rowind; /*pointer to array of row indices of the nonzeros*/\n!   /*Note: nzval[]/rowind[] always have the same length*/\n!   int_t *colbeg; /* colbeg[j] points to the beginning of column j in nzval[]\n!                     and rowind[]  */\n!   int_t*colend; /*colend[j] points to one past the last element of column\n!                     j in nzval[] and rowind[]*/\n!                  /*Note:\n!                     Zero-based indexing is used;\n!                     The consecutive columns of the nonzeros may not be\n!                     contiguous in storage, because the matrix has been\n!                     postmultiplied by a column permutation matrix.*/\n! } NCPformat;\n\nTYPE, BIND(c) :: NCPformat\n  INTEGER(C_INT) :: nnz\n  TYPE(C_PTR) :: nzval, rowindx, colbeg, colend\nEND TYPE NCPformat\n\nPUBLIC :: NCPformat\n\n"})}),"\n",(0,r.jsx)(e.h2,{id:"dnformat",children:"DNformat"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"! typedef struct {\n!   int_t lda;   /*leading dimension*/\n!   void *nzval; /* array of size lda*ncol to represent a dense matrix*/\n! } DNformat;\n\nTYPE, BIND(c) :: DNformat\n  INTEGER(C_INT) :: lda\n  TYPE(C_PTR) :: nzval\nEND TYPE DNformat\n\nPUBLIC :: DNformat\n"})}),"\n",(0,r.jsx)(e.h2,{id:"superlu_options_t",children:(0,r.jsx)(e.code,{children:"superlu_options_t"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"! typedef struct {\n!     fact_t        Fact;\n!     yes_no_t      Equil;\n!     colperm_t     ColPerm;\n!     trans_t       Trans;\n!     IterRefine_t  IterRefine;\n!     double        DiagPivotThresh;\n!     yes_no_t      SymmetricMode;\n!     yes_no_t      PivotGrowth;\n!     yes_no_t      ConditionNumber;\n!     rowperm_t     RowPerm;\n!     int           ILU_DropRule;\n!     double          ILU_DropTol;    /* threshold for dropping */\n!     double          ILU_FillFactor; /* gamma in the secondary dropping */\n!     norm_t          ILU_Norm;       /* infinity-norm, 1-norm, or 2-norm */\n!     double          ILU_FillTol;    /* threshold for zero pivot perturbation */\n!     milu_t          ILU_MILU;\n!     double          ILU_MILU_Dim;   /* Dimension of PDE (if available) */\n!     yes_no_t      ParSymbFact;\n!     yes_no_t      ReplaceTinyPivot; /* used in SuperLU_DIST */\n!     yes_no_t      SolveInitialized;\n!     yes_no_t      RefineInitialized;\n!     yes_no_t      PrintStat;\n!     int           nnzL, nnzU;      /* used to store nnzs for now       */\n!     int           num_lookaheads;  /* num of levels in look-ahead      */\n!     yes_no_t      lookahead_etree; /* use etree computed from the\n!                                       serial symbolic factorization */\n!     yes_no_t      SymPattern;      /* symmetric factorization          */\n! } superlu_options_t;\n!\n\nTYPE, BIND(C) :: superlu_options_t\n  INTEGER(C_INT) :: Fact\n  INTEGER(C_INT) :: Equil\n  INTEGER(C_INT) :: ColPerm\n  INTEGER(C_INT) :: Trans\n  INTEGER(C_INT) :: IterRefine\n  REAL(C_DOUBLE) :: DiagPivotThresh\n  INTEGER(C_INT) :: SymmetricMode\n  INTEGER(C_INT) :: PivotGrowth\n  INTEGER(C_INT) :: ConditionNumber\n  INTEGER(C_INT) :: RowPerm\n  INTEGER(C_INT) :: ILU_DropRule\n  REAL(C_DOUBLE) :: ILU_DropTol\n  REAL(C_DOUBLE) :: ILU_FillFactor\n  INTEGER(C_INT) :: ILU_Norm\n  REAL(C_DOUBLE) :: ILU_FillTol\n  INTEGER(C_INT) :: ILU_MILU; \n  REAL(C_DOUBLE) :: ILU_MILU_Dim\n  INTEGER(C_INT) :: ParSymbFact\n  INTEGER(C_INT) :: ReplaceTinyPivot\n  INTEGER(C_INT) :: SolveInitialized\n  INTEGER(C_INT) :: RefineInitialized\n  INTEGER(C_INT) :: PrintStat = 0\n  INTEGER(C_INT) :: nnzL\n  INTEGER(C_INT) :: nnzU\n  INTEGER(C_INT) :: num_lookaheads\n  INTEGER(C_INT) :: lookahead_etree\n  INTEGER(C_INT) :: SymPattern\nEND TYPE superlu_options_t\n"})}),"\n",(0,r.jsx)(e.h2,{id:"superlustat_t",children:"SuperLUStat_t"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-fortran",children:"! typedef struct {\n!     int     *panel_histo; /* histogram of panel size distribution */\n!     double  *utime;       /* running time at various phases */\n!     flops_t *ops;         /* operation count at various phases */\n!     int     TinyPivots;   /* number of tiny pivots */\n!     int     RefineSteps;  /* number of iterative refinement steps */\n!     int     expansions;   /* number of memory expansions */\n! } SuperLUStat_t;\n\nTYPE, BIND(C) :: SuperLUStat_t\n  ! INTEGER(C_INT), POINTER :: panel_histo(:)\n  ! REAL(C_DOUBLE), POINTER :: utime(:)\n  ! REAL(C_FLOAT), POINTER :: ops(:)\n  TYPE(C_PTR) :: panel_histo\n  TYPE(C_PTR) :: utime\n  TYPE(C_PTR) :: ops\n  INTEGER(C_INT) :: TinyPivots\n  INTEGER(C_INT) :: RefineSteps\n  INTEGER(C_INT) :: expansions\nEND TYPE SuperLUStat_t\n\nPUBLIC :: SuperLUStat_t\n\n"})})]})}function d(n={}){const{wrapper:e}={...(0,_.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},54213:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>i});var o=t(36672);const r={},_=o.createContext(r);function a(n){const e=o.useContext(_);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),o.createElement(_.Provider,{value:e},n.children)}}}]);