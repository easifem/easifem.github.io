"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[63369],{68748:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"SuperLU/dgstrf","title":"dgstrf","description":"DGSTRF computes an LU factorization of a general sparse m-by-n matrix A using partial pivoting with row interchanges.","source":"@site/docs/docs-api/SuperLU/dgstrf.md","sourceDirName":"SuperLU","slug":"/SuperLU/dgstrf","permalink":"/docs-api/SuperLU/dgstrf","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/SuperLU/dgstrf.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"dgssvx","permalink":"/docs-api/SuperLU/dgssvx"},"next":{"title":"Utility","permalink":"/docs-api/SuperLU/dutil"}}');var i=n(23420),a=n(54213);const t={},l="dgstrf",c={},o=[{value:"Interface",id:"interface",level:2},{value:"options",id:"options",level:2},{value:"A",id:"a",level:2},{value:"relax",id:"relax",level:2},{value:"<code>panel_size</code>",id:"panel_size",level:2},{value:"etree",id:"etree",level:2},{value:"work",id:"work",level:2},{value:"lwork",id:"lwork",level:2},{value:"<code>perm_c</code>",id:"perm_c",level:2},{value:"<code>perm_r</code>",id:"perm_r",level:2},{value:"L",id:"l",level:2},{value:"U",id:"u",level:2},{value:"Glu",id:"glu",level:2},{value:"stat",id:"stat",level:2},{value:"info",id:"info",level:2}];function d(e){const s={admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",msub:"msub",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"dgstrf",children:"dgstrf"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"DGSTRF"})," computes an LU factorization of a general sparse m-by-n matrix A using partial pivoting with row interchanges."]}),"\n",(0,i.jsx)(s.p,{children:"The factorization has the form"}),"\n",(0,i.jsx)(s.span,{className:"katex-display",children:(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsxs)(s.msub,{children:[(0,i.jsx)(s.mi,{children:"P"}),(0,i.jsx)(s.mi,{children:"r"})]}),(0,i.jsx)(s.mo,{children:"\u22c5"}),(0,i.jsx)(s.mi,{children:"A"}),(0,i.jsx)(s.mo,{children:"="}),(0,i.jsx)(s.mi,{children:"L"}),(0,i.jsx)(s.mo,{children:"\u22c5"}),(0,i.jsx)(s.mi,{children:"U"}),(0,i.jsx)(s.mo,{separator:"true",children:","})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"P_{r} \\cdot A = L \\cdot  U,"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,i.jsxs)(s.span,{className:"mord",children:[(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"P"}),(0,i.jsx)(s.span,{className:"msupsub",children:(0,i.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(s.span,{className:"vlist-r",children:[(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.1514em"},children:(0,i.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,i.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(s.span,{className:"mord mtight",children:(0,i.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.02778em"},children:"r"})})})]})}),(0,i.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(s.span,{className:"vlist-r",children:(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(s.span,{})})})]})})]}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(s.span,{className:"mbin",children:"\u22c5"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"A"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(s.span,{className:"mrel",children:"="}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"L"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(s.span,{className:"mbin",children:"\u22c5"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8778em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"U"}),(0,i.jsx)(s.span,{className:"mpunct",children:","})]})]})]})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Pr is a row-permutation matrix"}),"\n",(0,i.jsxs)(s.li,{children:["L is lower triangular with unit diagonal elements (lower trapezoidal if ",(0,i.jsx)(s.code,{children:"A->nrow > A->ncol"}),")"]}),"\n",(0,i.jsxs)(s.li,{children:["U is upper triangular (upper trapezoidal if ",(0,i.jsx)(s.code,{children:"A->nrow < A->ncol"}),")."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"See supermatrix.h for the definition of 'SuperMatrix' structure."}),"\n",(0,i.jsx)(s.h2,{id:"interface",children:"Interface"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:'! void\n! dgstrf (superlu_options_t *options, SuperMatrix *A,\n!         int relax, int panel_size, int *etree, void *work, int lwork,\n!         int *perm_c, int *perm_r, SuperMatrix *L, SuperMatrix *U,\n!             GlobalLU_t *Glu, /* persistent to facilitate multiple factorizations */\n!         SuperLUStat_t *stat, int *info)\nINTERFACE\n  SUBROUTINE dgstrf(options, A, relax, panel_size, etree, &\n    & work, lwork, perm_c, perm_r, &\n    & L, U, &\n    & Glu, stat, info) &\n    & BIND(C, name="dgstrf")\n    IMPORT :: superlu_options_t, SuperLUStat_t, C_INT, C_PTR, &\n      & SuperMatrix, GlobalLU_t, C_CHAR, C_DOUBLE\n    !\n    TYPE(superlu_options_t), INTENT(IN) :: options\n    TYPE(SuperMatrix), INTENT(INOUT) :: A\n    INTEGER(C_INT), VALUE, INTENT(IN) :: relax\n    INTEGER(C_INT), VALUE, INTENT(IN) :: panel_size\n    INTEGER(C_INT), INTENT(INOUT) :: etree(*)\n    TYPE(C_PTR), INTENT(inout) :: work\n    INTEGER(C_INT), VALUE, INTENT(IN) :: lwork\n    INTEGER(C_INT), INTENT(INOUT) :: perm_c(*)\n    INTEGER(C_INT), INTENT(INOUT) :: perm_r(*)\n    TYPE(SuperMatrix), INTENT(INOUT) :: L\n    TYPE(SuperMatrix), INTENT(INOUT) :: U\n    TYPE(GlobalLU_t), INTENT(inout) :: Glu\n    TYPE(SuperLUStat_t), INTENT(INOUT) :: stat\n    INTEGER(C_INT), INTENT(INOUT) :: info\n  END SUBROUTINE dgstrf\nEND INTERFACE\nPUBLIC :: dgstrf\n'})}),"\n",(0,i.jsx)(s.h2,{id:"options",children:"options"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:" (input) superlu_options_t*\n"})}),"\n",(0,i.jsx)(s.p,{children:"The structure defines the input parameters to control how the LU decomposition will be performed."}),"\n",(0,i.jsx)(s.h2,{id:"a",children:"A"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"(input) SuperMatrix*\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Original matrix A, permuted by columns, of dimension ",(0,i.jsx)(s.code,{children:"(A->nrow, A->ncol)"}),". The type of ",(0,i.jsx)(s.code,{children:"A"})," can be:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Stype = SLU_NCP"}),"\n",(0,i.jsx)(s.li,{children:"Dtype = SLU_D"}),"\n",(0,i.jsx)(s.li,{children:"Mtype = SLU_GE."}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"relax",children:"relax"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"(input) int\n"})}),"\n",(0,i.jsx)(s.p,{children:"To control degree of relaxing supernodes. If the number of nodes (columns) in a subtree of the elimination tree is less than relax, this subtree is considered as one supernode, regardless of the row structures of those columns."}),"\n",(0,i.jsx)(s.h2,{id:"panel_size",children:(0,i.jsx)(s.code,{children:"panel_size"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"panel_size (input) int\n"})}),"\n",(0,i.jsx)(s.p,{children:"A panel consists of at most panel_size consecutive columns."}),"\n",(0,i.jsx)(s.h2,{id:"etree",children:"etree"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"(input) int*, dimension (A->ncol)\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Elimination tree of ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsxs)(s.msup,{children:[(0,i.jsx)(s.mi,{children:"A"}),(0,i.jsx)(s.mi,{children:"T"})]}),(0,i.jsx)(s.mo,{children:"\u22c5"}),(0,i.jsx)(s.mi,{children:"A"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"A^{T} \\cdot A"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8413em"}}),(0,i.jsxs)(s.span,{className:"mord",children:[(0,i.jsx)(s.span,{className:"mord mathnormal",children:"A"}),(0,i.jsx)(s.span,{className:"msupsub",children:(0,i.jsx)(s.span,{className:"vlist-t",children:(0,i.jsx)(s.span,{className:"vlist-r",children:(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.8413em"},children:(0,i.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(s.span,{className:"mord mtight",children:(0,i.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.13889em"},children:"T"})})})]})})})})})]}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(s.span,{className:"mbin",children:"\u22c5"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"A"})]})]})]}),"."]}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["etree is a vector of parent pointers for a forest whose vertices are the integers 0 to ",(0,i.jsx)(s.code,{children:"A->ncol-1"}),", ",(0,i.jsx)(s.code,{children:"etree[root]==A->ncol"}),". On input, the columns of A should be permuted so that the etree is in a certain postorder."]})}),"\n",(0,i.jsx)(s.h2,{id:"work",children:"work"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"(input/output) void*, size (lwork) (in bytes)\n"})}),"\n",(0,i.jsx)(s.p,{children:"User-supplied work space and space for the output data structures. Not referenced if lwork = 0;"}),"\n",(0,i.jsx)(s.h2,{id:"lwork",children:"lwork"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"lwork (input) int\n"})}),"\n",(0,i.jsx)(s.p,{children:"Specifies the size of work array in bytes."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"0, allocate space internally by system malloc;"}),"\n",(0,i.jsx)(s.li,{children:"Greater than 0: use user-supplied work array of length lwork in bytes, returns error if space runs out."}),"\n",(0,i.jsx)(s.li,{children:"-1: the routine guesses the amount of space needed without performing the factorization, and returns it in *info; no other side effects."}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"perm_c",children:(0,i.jsx)(s.code,{children:"perm_c"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"(input) int*, dimension (A->ncol)\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Column permutation vector, which defines the permutation matrix Pc; ",(0,i.jsx)(s.code,{children:"perm_c[i] = j"})," means column i of A is in position j in ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"A"}),(0,i.jsx)(s.mo,{children:"\u22c5"}),(0,i.jsxs)(s.msub,{children:[(0,i.jsx)(s.mi,{children:"P"}),(0,i.jsx)(s.mi,{children:"c"})]})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"A \\cdot P_{c}"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"A"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(s.span,{className:"mbin",children:"\u22c5"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,i.jsxs)(s.span,{className:"mord",children:[(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"P"}),(0,i.jsx)(s.span,{className:"msupsub",children:(0,i.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(s.span,{className:"vlist-r",children:[(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.1514em"},children:(0,i.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,i.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(s.span,{className:"mord mtight",children:(0,i.jsx)(s.span,{className:"mord mathnormal mtight",children:"c"})})})]})}),(0,i.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(s.span,{className:"vlist-r",children:(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(s.span,{})})})]})})]})]})]})]}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["When searching for diagonal, ",(0,i.jsx)(s.code,{children:"perm_c[*]"})," is applied to the row subscripts of A, so that diagonal threshold pivoting can find the diagonal of A, rather than that of ",(0,i.jsx)(s.code,{children:"A*Pc"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"perm_r",children:(0,i.jsx)(s.code,{children:"perm_r"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"(input/output) int*, dimension (A->nrow)\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Row permutation vector which defines the permutation matrix Pr, ",(0,i.jsx)(s.code,{children:"perm_r[i] = j"})," means row i of A is in position j in ",(0,i.jsx)(s.code,{children:"Pr*A"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["If ",(0,i.jsx)(s.code,{children:"options->Fact == SamePattern_SameRowPerm"}),", the pivoting routine will try to use the input ",(0,i.jsx)(s.code,{children:"perm_r"}),", unless a certain threshold criterion is violated. In that case, perm_r is overwritten by a new permutation determined by partial pivoting or diagonal threshold pivoting."]}),"\n",(0,i.jsx)(s.p,{children:"Otherwise, perm_r is output argument;"}),"\n",(0,i.jsx)(s.h2,{id:"l",children:"L"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"(output) SuperMatrix*\n"})}),"\n",(0,i.jsxs)(s.p,{children:["The factor L from the factorization ",(0,i.jsx)(s.code,{children:"Pr*A=L*U"}),"; use compressed row\nsubscripts storage for supernodes, i.e., L has type:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"Stype = SLU_SC"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"Dtype = SLU_D"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.code,{children:"Mtype = SLU_TRLU"})}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"u",children:"U"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"(output) SuperMatrix*\n"})}),"\n",(0,i.jsxs)(s.p,{children:["The factor U from the factorization ",(0,i.jsx)(s.code,{children:"Pr*A*Pc=L*U"}),". Use column-wise\nstorage scheme, i.e., U has types:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"Stype = SLU_NC"}),","]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"Dtype = SLU_D"}),","]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"Mtype = SLU_TRU"}),"."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"glu",children:"Glu"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"Glu (input/output) GlobalLU_t *\n"})}),"\n",(0,i.jsxs)(s.p,{children:["If ",(0,i.jsx)(s.code,{children:"options->Fact == SamePattern_SameRowPerm"}),", it is an input;"]}),"\n",(0,i.jsxs)(s.p,{children:["The matrix A will be factorized assuming that a\nfactorization of a matrix with the same sparsity pattern\nand similar numerical values was performed prior to this one.\nTherefore, this factorization will reuse both row and column\nscaling factors R and C, both row and column permutation\nvectors ",(0,i.jsx)(s.code,{children:"perm_r"})," and ",(0,i.jsx)(s.code,{children:"perm_c"}),", and the L and U data structures\nset up from the previous factorization."]}),"\n",(0,i.jsx)(s.p,{children:"Otherwise, it is an output."}),"\n",(0,i.jsx)(s.h2,{id:"stat",children:"stat"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"(output) SuperLUStat_t*\n"})}),"\n",(0,i.jsx)(s.p,{children:"Record the statistics on runtime and floating-point operation count.\nSee slu_util.h for the definition of 'SuperLUStat_t'."}),"\n",(0,i.jsx)(s.h2,{id:"info",children:"info"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"(output) int*\n"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"= 0:"})," successful exit"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"< 0:"})," if info = -i, the i-th argument had an illegal value"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"> 0:"})," if info = i, and ",(0,i.jsx)(s.code,{children:"i"})," is"]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-txt",children:"   <= A->ncol: U(i,i) is exactly zero. The factorization has\n      been completed, but the factor U is exactly singular,\n      and division by zero will occur if it is used to solve a\n      system of equations.\n   > A->ncol: number of bytes allocated when memory allocation\n      failure occurred, plus A->ncol. If lwork = -1, it is\n      the estimated amount of space needed, plus A->ncol.\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-fortran",children:"! *\n! * Local Working Arrays:\n! * ======================\n! *   m = number of rows in the matrix\n! *   n = number of columns in the matrix\n! *\n! *   xprune[0:n-1]: xprune[*] points to locations in subscript\n! *        vector lsub[*]. For column i, xprune[i] denotes the point where\n! *        structural pruning begins. I.e. only xlsub[i],..,xprune[i]-1 need\n! *        to be traversed for symbolic factorization.\n! *\n! *   marker[0:3*m-1]: marker[i] = j means that node i has been\n! *        reached when working on column j.\n! *        Storage: relative to original row subscripts\n! *        NOTE: There are 3 of them: marker/marker1 are used for panel dfs,\n! *              see dpanel_dfs.c; marker2 is used for inner-factorization,\n! *            see dcolumn_dfs.c.\n! *\n! *   parent[0:m-1]: parent vector used during dfs\n! *      Storage: relative to new row subscripts\n! *\n! *   xplore[0:m-1]: xplore[i] gives the location of the next (dfs)\n! *        unexplored neighbor of i in lsub[*]\n! *\n! *   segrep[0:nseg-1]: contains the list of supernodal representatives\n! *        in topological order of the dfs. A supernode representative is the\n! *        last column of a supernode.\n! *      The maximum size of segrep[] is n.\n! *\n! *   repfnz[0:W*m-1]: for a nonzero segment U[*,j] that ends at a\n! *        supernodal representative r, repfnz[r] is the location of the first\n! *        nonzero in this segment.  It is also used during the dfs: repfnz[r]>0\n! *        indicates the supernode r has been explored.\n! *        NOTE: There are W of them, each used for one column of a panel.\n! *\n! *   panel_lsub[0:W*m-1]: temporary for the nonzeros row indices below\n! *      the panel diagonal. These are filled in during dpanel_dfs(), and are\n! *      used later in the inner LU factorization within the panel.\n! *        panel_lsub[]/dense[] pair forms the SPA data structure.\n! *        NOTE: There are W of them.\n! *\n! *   dense[0:W*m-1]: sparse accumulating (SPA) vector for intermediate values;\n! *                       NOTE: there are W of them.\n! *\n! *   tempv[0:*]: real temporary used for dense numeric kernels;\n! *        The size of this array is defined by NUM_TEMPV() in slu_ddefs.h.\n! void\n! dgstrf (superlu_options_t *options, SuperMatrix *A,\n!         int relax, int panel_size, int *etree, void *work, int lwork,\n!         int *perm_c, int *perm_r, SuperMatrix *L, SuperMatrix *U,\n!             GlobalLU_t *Glu, /* persistent to facilitate multiple factorizations */\n!         SuperLUStat_t *stat, int *info)\n"})})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},54213:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>l});var r=n(36672);const i={},a=r.createContext(i);function t(e){const s=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(a.Provider,{value:s},e.children)}}}]);