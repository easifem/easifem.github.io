"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[88113],{84981:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>s,contentTitle:()=>m,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"AbstractBC/ImportFromToml","title":"ImportFromToml","description":"Initiate an instance of AbstractBC_ from toml configuration.","source":"@site/docs/docs-api/AbstractBC/ImportFromToml.md","sourceDirName":"AbstractBC","slug":"/AbstractBC/ImportFromToml","permalink":"/docs-api/AbstractBC/ImportFromToml","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AbstractBC/ImportFromToml.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Import","permalink":"/docs-api/AbstractBC/Import"},"next":{"title":"Initiate","permalink":"/docs-api/AbstractBC/Initiate"}}');var t=o(23420),a=o(54213);const l={},m="ImportFromToml",s={},r=[{value:"Interface 1",id:"interface-1",level:2},{value:"Interface 2",id:"interface-2",level:2},{value:"TOML configuration",id:"toml-configuration",level:2}];function c(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...n.components},{Details:o}=e;return o||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"importfromtoml",children:"ImportFromToml"})}),"\n",(0,t.jsxs)(e.p,{children:["Initiate an instance of ",(0,t.jsx)(e.code,{children:"AbstractBC_"})," from toml configuration."]}),"\n",(0,t.jsx)(e.h2,{id:"interface-1",children:"Interface 1"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-fortran",children:"INTERFACE AbstractBCImportFromToml\n  MODULE SUBROUTINE bc_ImportFromToml1(obj, table, dom)\n    CLASS(AbstractBC_), INTENT(INOUT) :: obj\n    TYPE(toml_table), INTENT(INOUT) :: table\n    CLASS(Domain_), TARGET, INTENT(IN) :: dom\n  END SUBROUTINE bc_ImportFromToml1\nEND INTERFACE AbstractBCImportFromToml\n"})}),"\n",(0,t.jsx)(e.admonition,{type:"info",children:(0,t.jsx)(e.p,{children:"This method is mainly for internal use."})}),"\n",(0,t.jsx)(e.h2,{id:"interface-2",children:"Interface 2"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-fortran",children:"INTERFACE AbstractBCImportFromToml\n  MODULE SUBROUTINE bc_ImportFromToml2(obj, dom, tomlName, afile,  &\n    & filename, printToml)\n    CLASS(AbstractBC_), INTENT(INOUT) :: obj\n    CLASS(Domain_), TARGET, INTENT(IN) :: dom\n    CHARACTER(*), INTENT(IN) :: tomlName\n    TYPE(TxtFile_), OPTIONAL, INTENT(INOUT) :: afile\n    CHARACTER(*), OPTIONAL, INTENT(IN) :: filename\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: printToml\n  END SUBROUTINE bc_ImportFromToml2\nEND INTERFACE AbstractBCImportFromToml\n"})}),"\n",(0,t.jsx)(e.h2,{id:"toml-configuration",children:"TOML configuration"}),"\n",(0,t.jsxs)(o,{children:[(0,t.jsx)("summary",{children:"Click here to see the toml-configuration file"}),(0,t.jsx)("div",{children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-toml",children:'[bc]\nname = "DirichletBC"\n# Name of the boundary condition\nidof = 1\n# idof denotes the degree of freedom where\n# we apply the contraint,\n# For x component idof is 1\n# For y component idof is 2\n# For z component idof is 3\n\nnodalValueType = "Constant" # Time, SpaceTime, Space\n# Other option: Constant, Time, Space,  SpaceTime\n# nodalValuetype denotes the type of boundary condition\n# It can take following values\n# Constant: It means the boundary condition is constant in\n#           space and time.\n# Space:    It means the boundary condition is variable in\n#           space but constant in time.\n# Time:     It means the boundary condition is variable in\n#           in time but constant in Space\n# SpaceTime:It means the boundary condition is variable in\n#           both space and time.\n\nvalue = 20.0\n# Value of boundary condition\n# The shape of value depends upon the nodalValueType as explained below.\n# For nodalValueType="Constant", value should be a scalar real value\n# For nodalValueType="Space", value should be a vector of real values\n# value=[1.0, 2.0, 3.0, 4.0]\n# For nodalValueType="Time", value should  be a vector of real values\n# value=[1.0, 2.0, 3.0, 4.0]\n# For nodalValueType="SpaceTime", value should be two dimensional array of\n# real values\n# value=[[1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0]]\n\nisUserFunction = false\nisNormal = false\nisTangent = false\nuseExternal = false\n\n[bc.function]\nname = "boundaryFunction"\n# name of the function\n\nreturnType = "Scalar"\n# returnType must be "Scalar"\n\nnumReturns = 1\n# number of returns must be 1\n\nargType = "Space"\n# argumen type of function, It can take following values\n# "Constant", when the user function is constant\n# "Space", when the user function is space dependent only.\n# "Time", when the user function is time dependent only.\n# "SpaceTime", when the user function is space-time dependent.\n\nnumArgs = 3\n# number of arguments\n# number of arguments should be 0, when argType is "Constant"\n# number of arguments should be 1, when argType is "Time"\n# number of arguments should be 3, when argType is "Space"\n# number of arguments should be 4, when argType is "SpaceTime"\n\nvalue = 1.0\n# if lua script and luaFunctionName are absent then this\n# variable must be given.\n# When this is given, then argType must be Constant, and\n# numArgs should be 0.\n\nluaScript = "./hello.lua"\n# name of the lua script which contains the functions\n\nluaFunctionName = "hello"\n# which function in the lua script to be used for boundary condition\n\n[bc.boundary]\nisSelectionByMeshID = false\n# set isSelectionByMeshID to true when mesh selection is by meshID\n# if this variable is set to true then we should provide following\n# table\n[bc.boundary.meshID]\npoint = [1, 2, 3]\n# id of mesh of points\n# you can also give the filename\nline = [1, 2, 3, 4]\n# id of mesh of lines\n# you can also give the filename\nsurface = [1, 2, 3]\n# id of mesh of surfaces\n# you can also give the filename "filename.txt"\nvolume = [1, 2, 3]\n# id of mesh of volumes\n# you can also give the filename "filename.txt"\n\nisSelectionByElemNum = false\n# set isSelectionByElemNum to true when mesh selection is by\n# specifying element number\n# if this variable is set to true then we should provide following\n# table\n[bc.boundary.elemNum]\npoint = [1, 2, 3]\n# element number for points\nline = [1, 2, 3]\n# element number of lines\nsurface = [1, 2, 3]\n# element number of surfaces\nvolume = [1, 2, 3]\n# element number of volume\n\nisSelectionByBox = false\n# set isSelectionByBox to true when mesh selection is by\n# specifying the bounding boxes\n# if this variable is set to true then we should provide following\n# table\n[bc.boundary.box]\npoint = [\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 0.0, zmax = 1.0 },\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 2.0, zmax = 3.0 },\n]\n# boxes for mesh of points\nline = [\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 0.0, zmax = 1.0 },\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 2.0, zmax = 3.0 },\n]\n# boxes for mesh of lines\nsurface = [\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 0.0, zmax = 1.0 },\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 2.0, zmax = 3.0 },\n]\n# boxes for mesh of surfaces\nvolume = [\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 0.0, zmax = 1.0 },\n  { xmin = 0.0, xmax = 1.0, ymin = 0.0, ymax = 1.0, zmin = 2.0, zmax = 3.0 },\n]\n# boxes for mesh of volumes\n\nisSelectionByNodeNum = false\n# set isSelectionByNodeNum to true when mesh selection is by\n# by specifying the node number.\n# if this variable is set to true then we should provide following\n# table\n[bc.boundary.nodeNum]\npoint = [1, 2, 3]\nline = [1, 2, 3]\nsurface = [1, 2, 3]\nvolume = [1, 2, 3]\n'})})})]})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},36721:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>u,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>f});const i=JSON.parse('{"id":"DirichletBC/ImportFromToml","title":"ImportFromToml","description":"Examples","source":"@site/docs/docs-api/DirichletBC/ImportFromToml.md","sourceDirName":"DirichletBC","slug":"/DirichletBC/ImportFromToml","permalink":"/docs-api/DirichletBC/ImportFromToml","draft":false,"unlisted":false,"editUrl":"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/DirichletBC/ImportFromToml.md","tags":[],"version":"current","lastUpdatedAt":1724304782000,"sidebarPosition":4,"frontMatter":{"sidebar_label":"ImportFromToml","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Initiate","permalink":"/docs-api/DirichletBC/Initiate"},"next":{"title":"Set","permalink":"/docs-api/DirichletBC/Set"}}');var t=o(23420),a=o(54213),l=o(84981),m=o(84689),s=o(11068),r=o(3880);const c={sidebar_label:"ImportFromToml",sidebar_position:4},d=void 0,u={},f=[...l.toc,{value:"Examples",id:"examples",level:2},...m.RM,...s.RM,...r.RM];function p(n){const e={h2:"h2",...(0,a.R)(),...n.components},{TabItem:o,Tabs:i}=e;return o||b("TabItem",!0),i||b("Tabs",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(l.default,{}),"\n",(0,t.jsx)(e.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)(o,{value:"example",label:"example 1",children:(0,t.jsx)(m.Ay,{})}),(0,t.jsx)(o,{value:"ex2",label:"example 2",children:(0,t.jsx)(s.Ay,{})}),(0,t.jsx)(o,{value:"ex3",label:"example 3",children:(0,t.jsx)(r.Ay,{})}),(0,t.jsx)(o,{value:"close",label:"\u21a2 Close",default:!0})]})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(p,{...n})}):p(n)}function b(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}},84689:(n,e,o)=>{o.d(e,{Ay:()=>r,RM:()=>m});var i=o(23420),t=o(54213),a=o(68913);const l='! Import from toml\n! Constant function\n!\n! In this example we will initiate an instance of `DirichletBC_` by importing data from `toml` configuration.\n!\n! The content of toml config file is given below\n!\n! ```toml\n! [bc1]\n! name = "DirichletBC"\n! idof = 1\n! nodalValueType = "Constant"\n! value = 10.0\n!\n! [bc1.boundary]\n! isSelectionByMeshID = true\n! [bc1.boundary.meshID]\n! surface = [1, 2]\n! ```\n!\n! Note that in the boundary condition is constant, and mesh is selected by mesh-id.\n\nPROGRAM main\nUSE easifemBase\nUSE easifemClasses\nIMPLICIT NONE\n\nTYPE(DirichletBC_) :: obj\nTYPE(Domain_) :: dom\nTYPE(HDF5File_) :: domainfile\nCHARACTER(*), PARAMETER :: domainfilename = "./mesh3D.h5"\nCHARACTER(*), PARAMETER :: tomlFileName = "./DirichletBC.toml"\nINTEGER(I4B) :: bottom = 1, top = 2, left = 3, right = 4,  &\n  & front = 5, behind = 6\nINTEGER(I4B), ALLOCATABLE :: nodeNum(:)\nREAL(DFP), ALLOCATABLE :: nodalValue(:, :)\n\nCALL FPL_Init()\nCALL domainfile%Initiate(filename=domainfilename, mode="READ")\nCALL domainfile%OPEN()\nCALL dom%Initiate(domainfile, group="")\nCALL obj%ImportFromToml(filename=tomlFileName, dom=dom, tomlName="bc1")\n\nCALL obj%Get(nodeNum=nodeNum, nodalValue=nodalValue)\n\nCALL Display(nodeNum, "nodeNum", advance="NO")\nCALL Display(nodalValue, "nodalValue", advance="YES")\nCALL display(SIZE(nodeNum), "size = ")\n\nCALL domainfile%DEALLOCATE()\nCALL dom%DEALLOCATE()\nCALL FPL_Finalize()\nEND PROGRAM main\n',m=[];function s(n){return(0,i.jsx)(a.A,{language:"fortran",children:l})}function r(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(s,{...n})}):s()}},11068:(n,e,o)=>{o.d(e,{Ay:()=>r,RM:()=>m});var i=o(23420),t=o(54213),a=o(68913);const l='! Import from toml\n! we define userfunction in the config file.\n!\n! Initiate an instance of `DirichletBC_` by importing config from a Toml file.\n!\n! In the toml file we define details of [UserFunction](/docs-api/UserFunction).\n!\n! ```toml\n! [bc2]\n! name = "DirichletBC"\n! idof = 1\n! nodalValueType = "Constant"\n! isUserFunction = true\n!\n! [bc2.function]\n! name = "func"\n! returnType = "Scalar"\n! argType = "Constant"\n! value = 10.0\n!\n! # boundary\n! [bc2.boundary]\n! isSelectionByMeshID = true\n!\n! [bc2.boundary.meshID]\n! surface = [1, 2]\n! ```\n\nPROGRAM main\nUSE easifemBase\nUSE easifemClasses\nIMPLICIT NONE\n\nTYPE(DirichletBC_) :: obj\nTYPE(Domain_) :: dom\nTYPE(HDF5File_) :: domainfile\nCHARACTER(*), PARAMETER :: domainfilename = "./mesh3D.h5"\nCHARACTER(*), PARAMETER :: tomlFileName = "./DirichletBC.toml"\nINTEGER(I4B) :: bottom = 1, top = 2, left = 3, right = 4,  &\n  & front = 5, behind = 6\nINTEGER(I4B), ALLOCATABLE :: nodeNum(:)\nREAL(DFP), ALLOCATABLE :: nodalValue(:, :)\n\nCALL FPL_Init()\nCALL domainfile%Initiate(filename=domainfilename, mode="READ")\nCALL domainfile%OPEN()\nCALL dom%Initiate(domainfile, group="")\nCALL obj%ImportFromToml(filename=tomlFileName, dom=dom, tomlName="bc2")\n\nCALL obj%Get(nodeNum=nodeNum, nodalValue=nodalValue)\n\nCALL Display(nodeNum, "nodeNum", advance="NO")\nCALL Display(nodalValue, "nodalValue", advance="YES")\nCALL display(SIZE(nodeNum), "size = ")\n\nCALL domainfile%DEALLOCATE()\nCALL dom%DEALLOCATE()\nCALL FPL_Finalize()\nEND PROGRAM main\n',m=[];function s(n){return(0,i.jsx)(a.A,{language:"fortran",children:l})}function r(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(s,{...n})}):s()}},3880:(n,e,o)=>{o.d(e,{Ay:()=>m,RM:()=>a});var i=o(23420),t=o(54213);const a=[];function l(n){const e={code:"code",pre:"pre",...(0,t.R)(),...n.components};return(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-fortran",children:'PROGRAM main\nUSE easifemBase\nUSE easifemClasses\nIMPLICIT NONE\n\nTYPE(DirichletBC_) :: obj\nTYPE(Domain_) :: dom\nTYPE(HDF5File_) :: domainfile\nCHARACTER(*), PARAMETER :: domainfilename = "./mesh3D.h5"\nCHARACTER(*), PARAMETER :: tomlFileName = "./DirichletBC.toml"\nINTEGER(I4B) :: bottom = 1, top = 2, left = 3, right = 4,  &\n  & front = 5, behind = 6\nINTEGER(I4B), ALLOCATABLE :: nodeNum(:)\nREAL(DFP), ALLOCATABLE :: nodalValue(:, :)\n\nCALL FPL_Init()\nCALL domainfile%Initiate(filename=domainfilename, mode="READ")\nCALL domainfile%OPEN()\nCALL dom%Initiate(domainfile, group="")\nCALL obj%ImportFromToml(filename=tomlFileName, dom=dom, tomlName="bc3")\n\nCALL obj%Get(nodeNum=nodeNum, nodalValue=nodalValue)\n\nCALL Display(nodeNum, "nodeNum", advance="NO")\nCALL Display(nodalValue, "nodalValue", advance="YES")\nCALL display(SIZE(nodeNum), "size = ")\n\nCALL domainfile%DEALLOCATE()\nCALL dom%DEALLOCATE()\nCALL FPL_Finalize()\nEND PROGRAM main\n'})})}function m(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}}}]);