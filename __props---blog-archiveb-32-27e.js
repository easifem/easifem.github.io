"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkeasifem_docs"] = globalThis["webpackChunkeasifem_docs"] || []).push([["__props---blog-archiveb-32-27e"],{

/***/ "./.docusaurus/docusaurus-plugin-content-blog/blog/p/blog-archive-f05.json":
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"archive":{"blogPosts":[{"id":"/FEDOF/understanding-fedof-1","metadata":{"permalink":"/blog/FEDOF/understanding-fedof-1","source":"@site/docs/blog/FEDOF/understanding-fedof-1.md","title":"Understanding FEDOF in easifem (Part 1)","description":"This post explains concept of FEDOF in easifem.","date":"2025-12-08T00:01:37.000Z","tags":[{"inline":true,"label":"mesh","permalink":"/blog/tags/mesh"},{"inline":true,"label":"fedof","permalink":"/blog/tags/fedof"},{"inline":true,"label":"basis","permalink":"/blog/tags/basis"},{"inline":true,"label":"shapeFunctions","permalink":"/blog/tags/shape-functions"}],"readingTime":6.4,"hasTruncateMarker":true,"authors":[{"name":"Vikas Sharma","title":"Assistant Professor, Kyoto University, Japan","url":"https://github.com/vickysharma0812","socials":{"x":"https://x.com/vickysharma0812","github":"https://github.com/vickysharma0812","linkedin":"https://www.linkedin.com/in/vickysharma0812/","researchgate":"https://www.researchgate.net/profile/Vikas-Sharma-41"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/vickysharma0812.jpg","key":"vickysharma0812","page":null}],"frontMatter":{"title":"Understanding FEDOF in easifem (Part 1)","description":"This post explains concept of FEDOF in easifem.","authors":["vickysharma0812"],"tags":["mesh","fedof","basis","shapeFunctions"],"hide_table_of_contents":false},"unlisted":false,"nextItem":{"title":"Understanding FEDOF in easifem (Part 2)","permalink":"/blog/FEDOF/understanding-fedof-2"}},"content":"## FEDOF\\n\\n`FEDOF` denotes the finite element degree of freedom. The concept of degree of freedom depends upon the type of finite element approximation (basis functions) used for the problem.\\n\\n:::note\\nThese series of notes will present the FEDOF concept for for H1 conforming Hierarchical and Lagrange basis functions.\\n:::\\n\\n- For Lagrange polynomials the degree of freedoms are associatd with the nodes of the mesh. In this case, a node implies a point in the mesh. This point can be a vertex, somewhere on the edge, face, or interior of the element.\\n- For Hierarchical polynmials the degree of freedoms are associated with the modes. They can be associated with nodes, edges, faces and interior of the elements. In this case the node has an abstract meaning. But we will associcate them with the vertex, edge, face, and interior basis functions.\\n- In the case of H1 conforming basis functions with Hierarchical polynomials, the orientation of edge and faces with respect to the master element is very important. However, for Lagrange polynomials the orientation is not so much needed if we generate the nodes correctly for higher order mesh.\\n\\n<!-- truncate -->\\n\\n## Mesh related stuff\\n\\nIn this note we will focus on 2D mesh with quadrilateral.\\n\\n![Quadrilateral mesh](./figures/square_3x3.svg)\\n\\nInformation about this domain is given below:\\n\\n```txt\\nengine: GMSH 4.1 0 8\\nversion: 4.1\\nnsd: 2\\nminNptrs: 1\\nmaxNptrs: 9\\nminElemNum: 1\\nmaxElemNum: 16\\ntNodes: 9\\ntEntitiesForNodes: 9\\ntEntitiesForElements: 9\\ntElements: 4, 8, 4, 0\\ntotal mesh of volume: 0\\ntotal mesh of surface: 1\\ntotal mesh of curve: 4\\ntotal mesh of point: 4\\n```\\n\\nThe information about the cell mesh is given below.\\n\\n```txt\\ntotal nodes: 9\\ntotal elements: 4\\ntEdges: 0\\ntFaces: 12\\n```\\n\\n:::info\\nFor a 2D-mesh, we do not define the edges. For 2D mesh we only have Cell, faces, and vertices.\\n:::\\n\\nFrom the domain we can get the pointer to mesh of cells. In this case a cell is made of quadrilateral elements.\\n\\n```fortran\\ncellMesh => dom%GetMeshPointer()\\n```\\n\\nWe can get the maximum number of nodes in an element by using `GetMaxNNE()` method.\\n\\n```fortran\\nmaxNNE = cellMesh%GetMaxNNE()\\n```\\n\\nFor this mesh the value of `maxNNE` will be 4, as the maximum number of nodes in a quadrilateral element is 4.\\n\\n:::info\\nYou can think maxNNE as the maximum number of vertex connectivity for elements of mesh.\\n:::\\n\\nWe can get the global element number of a local element number by using following.\\n\\n```fortran\\niel = cellMesh%GetGlobalElemNumber(localElement=1)\\n```\\n\\n:::note \\"GlobalElement vs LocalElement Number\\"\\nGlobal element number is what you see in the mesh file, it the element number assigned by the mesh generator. Whereas, local element number is the location of this element inside the cellMesh object. We do not hope you to know the local element number, therefore, you can convert global element number to local element by using the method `GetLocalElemNumber()`.\\n:::\\n\\nIn this case iel will be 13.\\n\\n## Vertex connectivity of mesh\\n\\nThe vertex connectivity of this element can be obtained by using the following code.\\n\\n```fortran\\ncon = cellMesh%GetConnectivity(globalElement=1, islocal=yes, opt=\\"V\\")\\n```\\n\\n:::note\\nTo get vertex connectivity we use opt=\\"V\\", for face connectivity we will use opt=\\"F\\", for edge connectivity we will use opt=\\"E\\", and for cell connectivity we will use opt=\\"C\\", and for all connectivity we will use opt=\\"A\\".\\n:::\\n\\nThe vertex connectivity of global element 13 (local element 1) is given below.\\n\\n```txt\\n1 5 9 8\\n```\\n\\n:::caution\\nNote that the vertex connectivity is returned in terms of global vertex numbers.\\n:::\\n\\n## Face connectivity of mesh\\n\\nNow lets get the face connectivity for this element.\\n\\nWe can enquire about the total number of faces in the mesh by using the method `GetTotalFaces()` as shown below.\\n\\n```fortran\\nCALL Display(cellMesh%GetTotalFaces(), \\"Total faces in mesh:\\")\\n```\\n\\nThe face connectivity of global Element 13 (local element 1) can be obtained by using the following.\\n\\n```fortran\\ncon = cellMesh%GetConnectivity(globalElement=1, islocal=yes, opt=\\"F\\")\\nCALL Display(con, \\"Connectivity of faces for globalElement=1: \\")\\n```\\n\\nThe result is given below.\\n\\n```txt\\n1 2 3 4\\n```\\n\\n:::note\\nThese are local face numbers. Note that there are no global face numbers because the mesh file does not provide face number. Therefore, the concept of global or local face number is not valid here.\\n:::\\n\\nWe can get the orientation of these faces by using `GetFaceOrientation()`, the face orientation is a two dimensional array, where first dimension contains the face orientation flag in two dimensions and the second dimension contains the local face number. The following code is related to getting the face orientation.\\n\\n:::caution\\nThe number of rows in faceOrientation should be 3.\\n:::\\n\\n```fortran\\nCALL Reallocate(orient, 3, SIZE(con))\\nCALL cellMesh%GetFaceOrientation(globalElement=1, islocal=yes, ans=orient, &\\n                                 nrow=nrow, ncol=ncol)\\nCALL Display(orient(1:nrow, 1:ncol), &\\n             \\"Face orientations for globalElement=1: \\")\\n```\\n\\nThe result is given below.\\n\\n```txt\\nFace orientations for globalElement=1:\\n---------------------------------------\\n             1   1  -1  -1\\n```\\n\\nLet\'s understand the concept of face orientation.\\n\\nThe vertex connectivity of global element 13 is given by `[1 5 9 8]`. The faces are oriented in the counter clockwise direction.\\n\\n- Local face 1 is form vertex 1 to vertex 5\\n- Local face 2 is form vertex 5 to vertex 9\\n- Local face 3 is form vertex 9 to vertex 8\\n- Local face 4 is form vertex 8 to vertex 1\\n\\nIn 2D, positive orientation of a face means from small to large vertex number. Therefore,\\n\\n- Local face 1, form vertex 1 to vertex 5, has positive orientation.\\n- Local face 2, form vertex 5 to vertex 9, has positive orientation.\\n- Local face 3, form vertex 9 to vertex 8, has negative orientation.\\n- Local face 4, form vertex 8 to vertex 1, has negative orientation.\\n\\n:::warning\\nIf you try to get the edge data for 2D mesh you will get nothing because edge data is note defined for 2D mesh.\\n:::\\n\\nGetting vertex connectivity of the a face. To get the node numbers of a face we need to describe the globalElement and the local face number as shown below.\\n\\n```fortran\\ncon = cellMesh%GetFacetConnectivity(globalElement=1, iface=1, islocal=yes)\\nCALL Display(con, \\"Node numbers of face 1 of element 1: \\")\\n\\ncon = cellMesh%GetFacetConnectivity(globalElement=1, iface=2, islocal=yes)\\nCALL Display(con, \\"Node numbers of face 2 of element 1: \\")\\n\\ncon = cellMesh%GetFacetConnectivity(globalElement=1, iface=3, islocal=yes)\\nCALL Display(con, \\"Node numbers of face 3 of element 1: \\")\\n\\ncon = cellMesh%GetFacetConnectivity(globalElement=1, iface=4, islocal=yes)\\nCALL Display(con, \\"Node numbers of face 4 of element 1: \\")\\n```\\n\\nThe result is given below.\\n\\n```txt\\nNode numbers of face 1 of element 1: [1 5]\\nNode numbers of face 2 of element 1: [5 9]\\nNode numbers of face 3 of element 1: [9 8]\\nNode numbers of face 4 of element 1: [8 1]\\n```\\n\\n:::caution\\nNote these face connectivities are for local face of element.\\n:::\\n\\n## Getting all connectivity of mesh\\n\\nwe can get all connectivity of an element by using the following code.\\n\\n```fortran\\ncon = cellMesh%GetConnectivity(globalElement=1, islocal=yes, opt=\'V\')\\nCALL Display(con, \\"Connectivity of vertex for localElement=1: \\")\\n```\\n\\n## Scalar FEDOF\\n\\nGetting the degree of freedom for scalar field.\\n\\n- Vertex DOF connectivity for localElement=1:\\n\\n```txt\\n1 5 9 8\\n```\\n\\n- Face DOF connectivity for localElement=1:\\n\\n```txt\\n10 11 12 13\\n```\\n\\n- Cell DOF connectivity for localElement=1:\\n\\n```txt\\n22\\n```\\n\\n- All DOF connectivity for localElement=1:\\n\\n```txt\\n1 5 9 8 10 11 12 13 22\\n```\\n\\nThere is another way to get FEDOF connectivity.\\n\\nFrom the cellMesh we get the connectivity with opt \\"V\\", \\"F\\", \\"C\\", and \\"A\\" for vertex, face, cell, and all DOF connectivity respectively. Then for each of these abstract node number we can call following methods on FEDOF object.\\n\\n- `GetVertextDOF()`\\n- `GetFaceDOF()`\\n- `GetCellDOF()`"},{"id":"/FEDOF/understanding-fedof-2","metadata":{"permalink":"/blog/FEDOF/understanding-fedof-2","source":"@site/docs/blog/FEDOF/understanding-fedof-2.md","title":"Understanding FEDOF in easifem (Part 2)","description":"This post explains concept of FEDOF in easifem.","date":"2025-12-08T00:01:37.000Z","tags":[{"inline":true,"label":"mesh","permalink":"/blog/tags/mesh"},{"inline":true,"label":"fedof","permalink":"/blog/tags/fedof"}],"readingTime":3.23,"hasTruncateMarker":true,"authors":[{"name":"Vikas Sharma","title":"Assistant Professor, Kyoto University, Japan","url":"https://github.com/vickysharma0812","socials":{"x":"https://x.com/vickysharma0812","github":"https://github.com/vickysharma0812","linkedin":"https://www.linkedin.com/in/vickysharma0812/","researchgate":"https://www.researchgate.net/profile/Vikas-Sharma-41"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/vickysharma0812.jpg","key":"vickysharma0812","page":null}],"frontMatter":{"title":"Understanding FEDOF in easifem (Part 2)","description":"This post explains concept of FEDOF in easifem.","authors":["vickysharma0812"],"tags":["mesh","fedof"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Understanding FEDOF in easifem (Part 1)","permalink":"/blog/FEDOF/understanding-fedof-1"},"nextItem":{"title":"Understanding FEDOF in easifem (Part 3)","permalink":"/blog/FEDOF/understanding-fedof-3"}},"content":"## FEDOF\\n\\n:::note\\nRead the part 1 of this series [here](./understanding-fedof-1.md) before proceeding further.\\n:::\\n\\nIn this note we will study the FEDOF for scalar field using H1 conforming Hierarchical basis functions.\\nThe main focus on the degree of freedom associated with vertex, face, and cell of the element.\\n\\n## Mesh related stuff\\n\\nIn this note we will focus on 2D mesh with quadrilateral.\\n\\n![Quadrilateral mesh](./figures/square_3x3.svg)\\n\\n<!-- truncate -->\\n\\n## Scalar FEDOF\\n\\nInitiate the FEDOF object and scalar field by using the following code.\\n\\n```fortran\\nCALL u%ImportFromToml(tomlName=\\"u\\", fedof=fedof, dom=dom, filename=tomlFileName)\\nCALL fedof%Display(msg=\\"FEDOF info: \\")\\n```\\n\\n## Getting all the connectivity\\n\\n![Scalar FEDOF in global element 13](./figures/iel1_order4.svg)\\n\\nThe following code gets all the DOF in an element.\\n\\n```txt\\n1   5   9   8  10  11  12  13  14  15  16  17  18  19  20  21  46  47  48  49  50  51  52  53  54\\n```\\n\\n## Vertex connectivity\\n\\nFollowing code gets the vertex DOF connectivity.\\n\\n```fortran\\nnrow = fedof%GetTotalDOF(globalElement=1, islocal=yes, opt=\\"V\\")\\nCALL Display(nrow, \\"Total Vertex DOF for localElement=1:\\")\\n\\ncon = fedof%GetConnectivity(globalElement=1, islocal=yes, opt=\\"V\\")\\nCALL Display(con, \\"Vertex DOF connectivity for localElement=1:\\")\\n```\\n\\n```txt\\n1 5 9 8\\n```\\n\\n:::note\\nThese are local DOF numbers, and it has nothing to do with the mesh connectivity.\\n:::\\n\\nWe can get the DOF of a single vertex by using `GetVertexDOF()` as shown below.\\n\\n```fortran\\nCALL Reallocate(con, 100)\\ncall cellMesh%GetConnectivity_(globalElement=1, islocal=yes, opt=\\"V\\", ans=con, tsize=tsize)\\nCALL fedof%GetVertexDOF(globalNode=con(1), islocal=.false., ans=con, tsize=tsize)\\nCALL Display(con(1), \\"DOF of vertex 1 of element 1:\\")\\n```\\n\\n## Face connectivity\\n\\nFollowing code gets the connectivity of all face DOF in an element. Note that these face DOF are local. In addition, they are related to the positive oriented faces only.\\n\\n```fortran\\nnrow = fedof%GetTotalDOF(globalElement=1, islocal=yes, opt=\\"F\\")\\nCALL Display(nrow, \\"Total Face DOF for localElement=1:\\")\\n\\ncon = fedof%GetConnectivity(globalElement=1, islocal=yes, opt=\\"F\\")\\nCALL Display(con, \\"Face DOF connectivity for localElement=1:\\", full=.TRUE., &\\n             orient=\\"R\\")\\n```\\n\\n```txt\\n10  11  12  13  14  15  16  17  18  19  20  21\\n```\\n\\nWe can get the DOF of a face by using `GetFaceDOF()` as shown below.\\n\\n```fortran\\nCALL Reallocate(con, 100, isExpand=.TRUE., expandFactor=2)\\nCALL cellMesh%GetConnectivity_(globalElement=1, islocal=yes, opt=\\"F\\", &\\n                               ans=con, tsize=tsize)\\nnrow = con(1)\\nCALL fedof%GetFaceDOF(globalFace=nrow, islocal=.TRUE., ans=con, &\\n                      tsize=tsize)\\nCALL Display(con(1:tsize), \\"DOF on face: \\"//ToString(nrow), full=.TRUE., &\\n             orient=\\"R\\")\\n```\\n\\n:::info DOF on face: 1\\n\\n```txt\\n10  11  12\\n```\\n\\n:::\\n\\nGetting dof on local face 3 on element 1:\\n\\n```fortran\\nCALL Reallocate(con, 100, isExpand=.TRUE., expandFactor=2)\\nCALL cellMesh%GetConnectivity_(globalElement=1, islocal=yes, opt=\\"F\\", &\\n                               ans=con, tsize=tsize)\\nnrow = con(3)\\nCALL fedof%GetFaceDOF(globalFace=nrow, islocal=.TRUE., ans=con, &\\n                      tsize=tsize)\\nCALL Display(con(1:tsize), \\"DOF on face: \\"//ToString(nrow), full=.TRUE., &\\n             orient=\\"R\\")\\n```\\n\\n:::info DOF of face: 3\\n\\n```txt\\n16 17 18\\n```\\n\\n:::\\n\\n## Cell connectivity\\n\\nFollowing code gets the connectivity of cell in an element. Note that these DOFs are local.\\n\\n```fortran\\nnrow = fedof%GetTotalDOF(globalElement=1, islocal=yes, opt=\\"C\\")\\nCALL Display(nrow, \\"Total Cell DOF for localElement=1:\\")\\n\\ncon = fedof%GetConnectivity(globalElement=1, islocal=yes, opt=\\"C\\")\\nCALL Display(con, \\"Cell DOF connectivity for localElement=1:\\")\\n```\\n\\n:::info Result\\n\\n```txt\\n46  47  48  49  50  51  52  53  54\\n```\\n\\n:::\\n\\nWe can get the cell DOF by using `GetCellDOF()` as shown below.\\n\\n```fortran\\nCALL Reallocate(con, 100, isExpand=.TRUE., expandFactor=2)\\nCALL cellMesh%GetConnectivity_(globalElement=1, islocal=yes, opt=\\"C\\", &\\n                               ans=con, tsize=tsize)\\nnrow = con(1)\\nCALL fedof%GetCellDOF(globalCell=nrow, islocal=.FALSE., ans=con, &\\n                      tsize=tsize)\\nCALL Display(con(1:tsize), \\"DOF in cell: \\"//ToString(nrow), full=.TRUE., &\\n             orient=\\"R\\")\\n```\\n\\n:::info DOF in cell: 13\\n\\n```txt\\n46  47  48  49  50  51  52  53  54\\n```\\n\\n:::"},{"id":"/FEDOF/understanding-fedof-3","metadata":{"permalink":"/blog/FEDOF/understanding-fedof-3","source":"@site/docs/blog/FEDOF/understanding-fedof-3.md","title":"Understanding FEDOF in easifem (Part 3)","description":"This post explains concept of FEDOF in easifem.","date":"2025-12-08T00:01:37.000Z","tags":[{"inline":true,"label":"mesh","permalink":"/blog/tags/mesh"},{"inline":true,"label":"fedof","permalink":"/blog/tags/fedof"}],"readingTime":1.03,"hasTruncateMarker":true,"authors":[{"name":"Vikas Sharma","title":"Assistant Professor, Kyoto University, Japan","url":"https://github.com/vickysharma0812","socials":{"x":"https://x.com/vickysharma0812","github":"https://github.com/vickysharma0812","linkedin":"https://www.linkedin.com/in/vickysharma0812/","researchgate":"https://www.researchgate.net/profile/Vikas-Sharma-41"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/vickysharma0812.jpg","key":"vickysharma0812","page":null}],"frontMatter":{"title":"Understanding FEDOF in easifem (Part 3)","description":"This post explains concept of FEDOF in easifem.","authors":["vickysharma0812"],"tags":["mesh","fedof"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Understanding FEDOF in easifem (Part 2)","permalink":"/blog/FEDOF/understanding-fedof-2"},"nextItem":{"title":"Handling Dirichlet Bounding Conditions in easifem (Part 1)","permalink":"/blog/DirichletBC/understanding-dirichletbc-1"}},"content":"## FEDOF\\n\\n:::note\\n\\n- Read the part 1 of this series [here](./understanding-fedof-1.md) before proceeding further.\\n- Read the part 2 of this series [here](./understanding-fedof-2.md) before proceeding further.\\n\\n:::\\n\\nIn this note we will study the FEDOF for scalar field using H1 conforming Hierarchical basis functions.\\nThe main focus is on generating quadrature points and shape functions.\\n\\nIn this note we will focus on 2D mesh with quadrilateral.\\n\\n![Quadrilateral mesh](./figures/square_3x3.svg)\\n\\n<!-- truncate -->\\n\\n## Scalar FEDOF\\n\\nInitiate the FEDOF object and scalar field by using the following code.\\n\\n```fortran\\nCALL u%ImportFromToml(tomlName=\\"u\\", fedof=fedof, dom=dom, filename=tomlFileName)\\nCALL fedof%Display(msg=\\"FEDOF info: \\")\\n```\\n\\n## Getting quadrature points\\n\\nThe following code gets the quadrature points in an element.\\n\\n```fortran\\nCALL fedof%GetQuadraturePoints(quad=qp, globalElement=1, islocal=yes)\\nCALL Display(qp, \\"Quadrature points: \\")\\n```\\n\\n:::note Quadrature points\\n\\n|    x1     |    x2     |    x3     |    x4     |    x5     |    x6     |    x7     |    x8     |    x9     |    x10    |   x11    |   x12    |    x13    |    x14    |   x15    |   x16    |\\n| :-------: | :-------: | :-------: | :-------: | :-------: | :-------: | :-------: | :-------: | :-------: | :-------: | :------: | :------: | :-------: | :-------: | :------: | :------: |\\n| -0.861136 | -0.861136 | -0.861136 | -0.861136 | -0.339981 | -0.339981 | -0.339981 | -0.339981 | 0.339981  | 0.339981  | 0.339981 | 0.339981 | 0.861136  | 0.861136  | 0.861136 | 0.861136 |\\n| -0.861136 | -0.339981 | 0.339981  | 0.861136  | -0.861136 | -0.339981 | 0.339981  | 0.861136  | -0.861136 | -0.339981 | 0.339981 | 0.861136 | -0.861136 | -0.339981 | 0.339981 | 0.861136 |\\n| 0.121003  | 0.226852  | 0.226852  | 0.121003  | 0.226852  | 0.425293  | 0.425293  | 0.226852  | 0.226852  | 0.425293  | 0.425293 | 0.226852 | 0.121003  | 0.226852  | 0.226852 | 0.121003 |\\n\\n:::\\n\\n## Getting shape functions"},{"id":"/DirichletBC/understanding-dirichletbc-1","metadata":{"permalink":"/blog/DirichletBC/understanding-dirichletbc-1","source":"@site/docs/blog/DirichletBC/understanding-dirichletbc-1.md","title":"Handling Dirichlet Bounding Conditions in easifem (Part 1)","description":"This post explains concept of FEDOF in easifem.","date":"2025-12-08T00:01:27.000Z","tags":[{"inline":true,"label":"mesh","permalink":"/blog/tags/mesh"},{"inline":true,"label":"fedof","permalink":"/blog/tags/fedof"},{"inline":true,"label":"dirichletBC","permalink":"/blog/tags/dirichlet-bc"}],"readingTime":2.86,"hasTruncateMarker":true,"authors":[{"name":"Vikas Sharma","title":"Assistant Professor, Kyoto University, Japan","url":"https://github.com/vickysharma0812","socials":{"x":"https://x.com/vickysharma0812","github":"https://github.com/vickysharma0812","linkedin":"https://www.linkedin.com/in/vickysharma0812/","researchgate":"https://www.researchgate.net/profile/Vikas-Sharma-41"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/vickysharma0812.jpg","key":"vickysharma0812","page":null}],"frontMatter":{"title":"Handling Dirichlet Bounding Conditions in easifem (Part 1)","description":"This post explains concept of FEDOF in easifem.","authors":["vickysharma0812"],"tags":["mesh","fedof","dirichletBC"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Understanding FEDOF in easifem (Part 3)","permalink":"/blog/FEDOF/understanding-fedof-3"},"nextItem":{"title":"Handling Dirichlet Bounding Conditions in easifem (Part 2)","permalink":"/blog/DirichletBC/understanding-dirichletbc-2"}},"content":"## Introduction\\n\\nTo apply boundary condition in FEM computation, EASIFEM, provides a class called [DirichletBC_](/docs-api/DirichletBC/DirichletBC_).\\n\\n:::info\\n`DirichletBC_` is a subclass of [AbstractBC](/docs-api/AbstractBC).\\n:::\\n\\nTo understand how `DirichletBC` works, lets consider an example of linear elasticity. Let\'s say we want to apply the following boundary condition.\\n\\n$$\\n\\\\mathbf{u} = \\\\mathbf{U}_{0}, \\\\text{ on } \\\\Gamma\\n$$\\n\\nWe may think that there is only one boundary condition. But in easifem this is not the case. Actually, $\\\\mathbf{u}$, has three components in 3D (and two components in 2D). Therefore, the above boundary condition is actually boundary condition for $u_x$, $u_y$, and $u_z$. So, we have three boundary condition on a given boundary $\\\\Gamma$.\\n\\n<!-- truncate -->\\n\\nThe second point, which is quite obvious, is that every boundary condition has two things:\\n\\n- The boundary\\n- The value (condition)\\n\\nTo define the boundary EASIFEM employs the [MeshSelection](/docs-api/MeshSelection) class. The value can be specified in several ways as mentioned below in this section.\\n\\n:::note\\nSeveral instances of DirichletBC can have same boundary but different condition.\\n:::\\n\\n## Mesh and degrees of freedom\\n\\n![Degree of freedom in mesh](./figures/order4_mesh3x3.svg)\\n\\n## Import from toml\\n\\nWe can initiate an instance of `DirichletBC_` by importing the information from a toml-file. To do so, we will use the method called [ImportFromToml](/docs-api/AbstractBC/ImportFromToml).\\n\\nLet us consider the following toml file\\n\\nimport CodeBlock from \'@theme/CodeBlock\';\\n\\nimport CodeSnippet from \'!!raw-loader!./code/test1.toml\';\\n\\n<CodeBlock language=\\"toml\\">{CodeSnippet}</CodeBlock>\\n\\nWe use the following code to import the boundary condition from the above toml file.\\n\\nimport FortranCodeSnippet from \'!!raw-loader!./code/test1.F90\';\\n\\n<CodeBlock language=\\"fortran\\">{FortranCodeSnippet}</CodeBlock>\\n\\nWe obtain the following information about the boundary condition.\\n\\n| Property             | Value           |\\n| -------------------- | --------------- |\\n| isInit               | TRUE            |\\n| name                 | left_bottom_fix |\\n| idof                 | 1               |\\n| nodalValueType       | CONSTANT        |\\n| isUserFunction       | FALSE           |\\n| isUseExternal        | FALSE           |\\n| IsInitiated          | TRUE            |\\n| IsSelectionByMeshID  | TRUE            |\\n| IsSelectionByElemNum | FALSE           |\\n| IsSelectionByNodeNum | FALSE           |\\n| IsSelectionByBox     | FALSE           |\\n| MeshID Point         | FALSE           |\\n| MeshID Curve         | TRUE            |\\n| MeshID Surface       | FALSE           |\\n| MeshID Volume        | FALSE           |\\n| ElemNum Point        | FALSE           |\\n| ElemNum Curve        | FALSE           |\\n| ElemNum Surface      | FALSE           |\\n| ElemNum Volume       | FALSE           |\\n| NodeNum Point        | FALSE           |\\n| NodeNum Curve        | FALSE           |\\n| NodeNum Surface      | FALSE           |\\n| NodeNum Volume       | FALSE           |\\n| Box Point            | FALSE           |\\n| Box Curve            | FALSE           |\\n| Box Surface          | FALSE           |\\n| Box Volume           | FALSE           |\\n\\n## Getting Total Node Numbers\\n\\nTo get the total number of nodes where the boundary condition is applied, we can use the method called [GetTotalNodeNum](/docs-api/AbstractBC/GetTotalNodeNum).\\n\\n```fortran\\nCALL Display(obj%GetTotalNodeNum(fedof=fedof), \\"Total Node Num: \\")\\n```\\n\\n:::info Results\\nTotal Node Num: 18\\n:::\\n\\nThere is a total of 18 nodes where the boundary condition is applied. Actually, node number 1 is counted two times because it is common to bottom and left boundaries.\\n\\n## Getting Node Numbers\\n\\nTo get the node numbers we call [Get](/docs-api/AbstractBC/Get) method. These node numbers are degrees of freedom numbers for FEDOF. You can use these indices to set and get the values in node fields.\\n\\n```fortran\\nCALL obj%Get(fedof=fedof, nodeNum=nodeNum, tsize=tsize, &\\n             iNodeOnNode=iNodeOnNode, iNodeOnEdge=iNodeOnEdge, &\\n             iNodeOnFace=iNodeOnFace)\\nCALL Display(tsize, \\"tsize = \\")\\nCALL Display(nodeNum(1:tsize), \\"nodeNum\\", full=.TRUE., orient=\\"ROW\\")\\nCALL Display(iNodeOnNode, \\"iNodeOnNode = \\")\\nCALL Display(iNodeOnFace, \\"iNodeOnFace = \\")\\nCALL Display(iNodeOnEdge, \\"iNodeOnEdge = \\")\\n```\\n\\n:::info Results\\n\\n```txt\\n                                nodeNum\\n----------------------------------------------------------------------\\n 1   5   2   4   8   1  10  11  12  31  32  33  28  29  30  19  20  21\\n\\niNodeOnNode = 1\\niNodeOnFace = 7\\niNodeOnEdge = 19\\n```\\n\\n- Node number 1 to 6 (7-1) are vertex dof numbers.\\n- Node number 7 to 18 (19-1) are face dof numbers\\n- Node number 19 to 18 are edge dof numbers (There are no edges)\\n\\n:::"},{"id":"/DirichletBC/understanding-dirichletbc-2","metadata":{"permalink":"/blog/DirichletBC/understanding-dirichletbc-2","source":"@site/docs/blog/DirichletBC/understanding-dirichletbc-2.md","title":"Handling Dirichlet Bounding Conditions in easifem (Part 2)","description":"This post explains concept of Dirichlet Boundary Condition in EASIFEM","date":"2025-12-08T00:01:27.000Z","tags":[{"inline":true,"label":"mesh","permalink":"/blog/tags/mesh"},{"inline":true,"label":"fedof","permalink":"/blog/tags/fedof"},{"inline":true,"label":"dirichletBC","permalink":"/blog/tags/dirichlet-bc"}],"readingTime":1.87,"hasTruncateMarker":true,"authors":[{"name":"Vikas Sharma","title":"Assistant Professor, Kyoto University, Japan","url":"https://github.com/vickysharma0812","socials":{"x":"https://x.com/vickysharma0812","github":"https://github.com/vickysharma0812","linkedin":"https://www.linkedin.com/in/vickysharma0812/","researchgate":"https://www.researchgate.net/profile/Vikas-Sharma-41"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/vickysharma0812.jpg","key":"vickysharma0812","page":null}],"frontMatter":{"title":"Handling Dirichlet Bounding Conditions in easifem (Part 2)","description":"This post explains concept of Dirichlet Boundary Condition in EASIFEM","authors":["vickysharma0812"],"tags":["mesh","fedof","dirichletBC"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Handling Dirichlet Bounding Conditions in easifem (Part 1)","permalink":"/blog/DirichletBC/understanding-dirichletbc-1"},"nextItem":{"title":"Creating structured mesh in 2D using EASIFEM","permalink":"/blog/generating-2d-mesh-in-easifem"}},"content":"## Introduction\\n\\n:::note\\n\\nBefore reading this post, it is recommended to read [Handling Dirichlet Bounding Conditions in easifem (Part 1)](./understanding-dirichletbc-1.md) first.\\n\\n:::\\n\\nIn this example, Dirichlet boundary conditions is given by a user defined function.\\n\\n## Mesh and degrees of freedom\\n\\n![Degree of freedom in mesh](./figures/order4_mesh3x3.svg)\\n\\n<!-- truncate -->\\n\\n## Import from toml\\n\\nWe can initiate an instance of `DirichletBC_` by importing the information from a toml-file. To do so, we will use the method called [ImportFromToml](/docs-api/AbstractBC/ImportFromToml).\\n\\nLet us consider the following toml file\\n\\nimport CodeBlock from \'@theme/CodeBlock\';\\n\\nimport CodeSnippet from \'!!raw-loader!./code/test2.toml\';\\n\\n<CodeBlock language=\\"toml\\">{CodeSnippet}</CodeBlock>\\n\\nWe use the following code to import the boundary condition from the above toml file.\\n\\nimport FortranCodeSnippet from \'!!raw-loader!./code/test2.F90\';\\n\\n<CodeBlock language=\\"fortran\\">{FortranCodeSnippet}</CodeBlock>\\n\\nWe obtain the following information about the boundary condition.\\n\\n:::info Results\\n\\n#### DirichletBC Info\\n\\n| Property       | Value                     |\\n| -------------- | ------------------------- |\\n| isInit         | TRUE                      |\\n| name           | Bottom Space UserFunction |\\n| idof           | 1                         |\\n| nodalValueType | SPACE                     |\\n| isUserFunction | TRUE                      |\\n| isUseExternal  | FALSE                     |\\n\\n#### Boundary\\n\\n| Property             | Value |\\n| -------------------- | ----- |\\n| IsInitiated          | TRUE  |\\n| IsSelectionByMeshID  | TRUE  |\\n| IsSelectionByElemNum | FALSE |\\n| IsSelectionByNodeNum | FALSE |\\n| IsSelectionByBox     | FALSE |\\n\\n#### Allocation Status\\n\\n| Element Type      | Point | Curve | Surface | Volume |\\n| ----------------- | ----- | ----- | ------- | ------ |\\n| MeshID ALLOCATED  | FALSE | TRUE  | FALSE   | FALSE  |\\n| ElemNum ALLOCATED | FALSE | FALSE | FALSE   | FALSE  |\\n| NodeNum ALLOCATED | FALSE | FALSE | FALSE   | FALSE  |\\n| Box ALLOCATED     | FALSE | FALSE | FALSE   | FALSE  |\\n\\n:::\\n\\n## Getting Total Node Numbers\\n\\nTo get the total number of nodes where the boundary condition is applied, we can use the method called [GetTotalNodeNum](/docs-api/AbstractBC/GetTotalNodeNum).\\n\\n```fortran\\nCALL Display(obj%GetTotalNodeNum(fedof=fedof), \\"Total Node Num: \\")\\n```\\n\\n:::info Results\\nTotal Node Num: 9\\n:::\\n\\n## Getting Node Numbers\\n\\nTo get the node numbers we call [Get](/docs-api/AbstractBC/Get) method. These node numbers are degrees of freedom numbers for FEDOF. You can use these indices to set and get the values in node fields.\\n\\n```fortran\\nCALL obj%Get(fedof=fedof, nodeNum=nodeNum, tsize=tsize, &\\n             iNodeOnNode=iNodeOnNode, iNodeOnEdge=iNodeOnEdge, &\\n             iNodeOnFace=iNodeOnFace)\\nCALL Display(tsize, \\"tsize = \\")\\nCALL Display(nodeNum(1:tsize), \\"nodeNum\\", full=.TRUE., orient=\\"ROW\\")\\nCALL Display(iNodeOnNode, \\"iNodeOnNode = \\")\\nCALL Display(iNodeOnFace, \\"iNodeOnFace = \\")\\nCALL Display(iNodeOnEdge, \\"iNodeOnEdge = \\")\\n```\\n\\n:::info Results\\n\\n```txt\\n              nodeNum\\n----------------------------------\\n 1   5   2  10  11  12  31  32  33\\n\\niNodeOnNode = 1\\niNodeOnFace = 4\\niNodeOnEdge = 10\\n```\\n\\n- Node number 1 to 3 are vertex dof numbers.\\n- Node number 4 to 9 are face dof numbers\\n\\n:::"},{"id":"/generating-2d-mesh-in-easifem","metadata":{"permalink":"/blog/generating-2d-mesh-in-easifem","source":"@site/docs/blog/generating-2d-mesh-in-easifem.md","title":"Creating structured mesh in 2D using EASIFEM","description":"This post explains methods of creating 2D mesh in easifem.","date":"2025-06-02T04:27:15.000Z","tags":[{"inline":true,"label":"mesh","permalink":"/blog/tags/mesh"},{"inline":true,"label":"gmsh","permalink":"/blog/tags/gmsh"},{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"}],"readingTime":3.52,"hasTruncateMarker":true,"authors":[{"name":"Vikas Sharma","title":"Assistant Professor, Kyoto University, Japan","url":"https://github.com/vickysharma0812","socials":{"x":"https://x.com/vickysharma0812","github":"https://github.com/vickysharma0812","linkedin":"https://www.linkedin.com/in/vickysharma0812/","researchgate":"https://www.researchgate.net/profile/Vikas-Sharma-41"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/vickysharma0812.jpg","key":"vickysharma0812","page":null},{"name":"Shion Shimizu","title":"Doctoral Student, Kyoto University, Japan","url":"https://github.com/shishiousan","socials":{"github":"https://github.com/shishiousan","linkedin":"https://www.linkedin.com/in/shion-shimizu-838997340/","researchgate":"https://www.researchgate.net/profile/Shion-Shimizu"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/shishiousan.jpg","key":"shishiousan","page":null}],"frontMatter":{"title":"Creating structured mesh in 2D using EASIFEM","description":"This post explains methods of creating 2D mesh in easifem.","authors":["vickysharma0812","shishiousan"],"tags":["mesh","gmsh","tutorial"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Handling Dirichlet Bounding Conditions in easifem (Part 2)","permalink":"/blog/DirichletBC/understanding-dirichletbc-2"},"nextItem":{"title":"Setting up a new kernel using EASIFEM","permalink":"/blog/how-to-setup-a-new-kernel-in-easifem"}},"content":"## Creating a structured mesh of quadrangles\\n\\nTo create a structured mesh of quadrangles in easifem, we will need following classes:\\n\\n- GmshStructuredMesh_Class: This is high-level interface on top of Gmsh library to create structured meshes.\\n- Gmsh_Class: Interface to Gmsh library.\\n- MSHFile_Class: Reading gmsh files\\n- HDF5File_Class: Writing gmsh files to HDF5 file.\\n\\n![Very small mesh of quadrangles](/img/blog/very_small_quad4_mesh.svg)\\n\\n```fortran\\nPROGRAM main\\nUSE GmshStructuredMesh_Class\\nUSE Gmsh_Class\\nUSE FPL\\nUSE GlobalData\\nUSE MSHFIle_Class\\nUSE HDF5File_Class\\n\\nIMPLICIT NONE\\n\\nTYPE(GmshStructuredMesh_) :: obj\\nTYPE(Gmsh_) :: gmsh\\nTYPE(ParameterList_) :: param\\n! CHARACTER(*), PARAMETER :: title = \\"small_quad4_mesh\\"\\nCHARACTER(*), PARAMETER :: title = \\"very_small_quad4_mesh\\"\\nREAL(DFP), PARAMETER :: pointsOnAxis1(2) = [0.0, 1.0]\\nREAL(DFP), PARAMETER :: pointsOnAxis2(2) = [0.0, 1.0]\\n\\nINTEGER(I4B), PARAMETER :: transfinitePointsOnAxis1(1) = [3]\\nINTEGER(I4B), PARAMETER :: transfinitePointsOnAxis2(1) = [3]\\n\\nINTEGER(I4B) :: ierr\\n\\nTYPE(MSHFile_) :: mshFile\\nTYPE(HDF5File_) :: hdf5file\\n\\nCALL FPL_Init()\\nCALL param%Initiate()\\n\\nCALL SetGmshStructuredMeshParam(param=param, &\\n                                filename=title//\\".msh\\", &\\n                                pointsOnAxis1=pointsOnAxis1, &\\n                                pointsOnAxis2=pointsOnAxis2, &\\n                          transfinitePointsOnAxis1=transfinitePointsOnAxis1, &\\n                          transfinitePointsOnAxis2=transfinitePointsOnAxis2, &\\n                                recombineAll=.TRUE.)\\n\\nCALL obj%Initiate(param)\\n\\nierr = gmsh%initialize()\\nierr = gmsh%model%add(\\"GmshStructuredMesh2D\\")\\nCALL obj%Generate(gmsh)\\n! ierr = gmsh%fltk%run()\\nierr = gmsh%finalize()\\n\\nCALL param%DEALLOCATE()\\nCALL obj%DEALLOCATE()\\n\\nCALL mshFile%Initiate(filename=title//\'.msh\', STATUS=\\"OLD\\", ACTION=\\"READ\\")\\nCALL mshFile%OPEN()\\nCALL mshFile%READ()\\nCALL hdf5file%Initiate(title//\'.h5\', MODE=\\"NEW\\")\\nCALL hdf5file%OPEN()\\nCALL mshFile%Export(hdf5=hdf5file, group=\\"\\")\\nCALL mshFile%DEALLOCATE()\\nCALL hdf5file%DEALLOCATE()\\n\\nEND PROGRAM main\\n```\\n\\n<!-- truncate -->\\n\\n## Creating a structured mesh of quadrangles with two regions\\n\\n![Very small mesh of quadrangles with two regions](/img/blog/very_small_quad4_mesh_two_region.svg)\\n\\n```fortran\\nPROGRAM main\\nUSE GmshStructuredMesh_Class\\nUSE Gmsh_Class\\nUSE FPL\\nUSE GlobalData\\nUSE MSHFile_Class\\nUSE HDF5File_Class\\n\\nIMPLICIT NONE\\n\\nTYPE(GmshStructuredMesh_) :: obj\\nTYPE(Gmsh_) :: gmsh\\nTYPE(ParameterList_) :: param\\nCHARACTER(*), PARAMETER :: title = \\"very_small_quad4_mesh_two_region\\"\\nREAL(DFP), PARAMETER :: pointsOnAxis1(3) = [0.0, 1.0, 2.0]\\nREAL(DFP), PARAMETER :: pointsOnAxis2(2) = [0.0, 1.0]\\n\\nINTEGER(I4B), PARAMETER :: transfinitePointsOnAxis1(2) = [3, 3]\\nINTEGER(I4B), PARAMETER :: transfinitePointsOnAxis2(1) = [2]\\n\\nINTEGER(I4B) :: ierr\\n\\nTYPE(MSHFile_) :: mshFile\\nTYPE(HDF5File_) :: hdf5file\\n\\nCALL FPL_Init()\\nCALL param%Initiate()\\n\\nCALL SetGmshStructuredMeshParam( &\\n  param=param, &\\n  filename=title//\\".msh\\", &\\n  pointsOnAxis1=pointsOnAxis1, &\\n  pointsOnAxis2=pointsOnAxis2, &\\n  transfinitePointsOnAxis1=transfinitePointsOnAxis1, &\\n  transfinitePointsOnAxis2=transfinitePointsOnAxis2, &\\n  recombineAll=.TRUE.)\\n\\nCALL obj%Initiate(param)\\n\\nierr = gmsh%initialize()\\nierr = gmsh%model%add(\\"GmshStructuredMesh2D\\")\\nCALL obj%Generate(gmsh)\\n! ierr = gmsh%fltk%run()\\nierr = gmsh%finalize()\\n\\nCALL param%DEALLOCATE()\\nCALL obj%DEALLOCATE()\\n\\nCALL mshFile%Initiate(filename=title//\'.msh\', STATUS=\\"OLD\\", ACTION=\\"READ\\")\\nCALL mshFile%OPEN()\\nCALL mshFile%READ()\\nCALL hdf5file%Initiate(title//\'.h5\', MODE=\\"NEW\\")\\nCALL hdf5file%OPEN()\\nCALL mshFile%Export(hdf5=hdf5file, group=\\"\\")\\nCALL mshFile%DEALLOCATE()\\nCALL hdf5file%DEALLOCATE()\\n\\nEND PROGRAM main\\n```\\n\\n## Creating a structured mesh of triangles\\n\\n![Small mesh of linear triangles](/img/blog/small_tri3_mesh.svg)\\n\\n```fortran\\nPROGRAM main\\nUSE easifemBase\\nUSE Gmsh_Class\\nUSE HDF5File_Class\\nUSE MSHFile_Class\\n\\nTYPE(Gmsh_) :: gmsh\\n\\nCHARACTER(LEN=*), PARAMETER :: title = \\"small_tri3_mesh\\"\\nREAL(DFP), PARAMETER :: lx = 2.0\\nREAL(DFP), PARAMETER :: ly = 2.0\\nINTEGER(I4B), PARAMETER :: order = 1\\n\\nREAL(DFP), PARAMETER :: meshSize = 1.0\\nREAL(DFP), PARAMETER :: corner(3) = 0.0_DFP\\nINTEGER(I4B) :: ierr\\nREAL(DFP) :: x, y, z, lc\\n\\nTYPE(MSHFile_) :: mshFile\\nTYPE(HDF5File_) :: hdf5file\\n\\nierr = gmsh%Initialize()\\nierr = gmsh%model%add(title)\\n\\nx = corner(1); y = corner(2); z = corner(3); lc = meshSize\\nierr = gmsh%model%geo%addPoint(x=x, y=y, z=z, meshSize=lc, tag=1)\\n\\nx = x + lx; y = y; z = z; lc = lc\\nierr = gmsh%model%geo%addPoint(x=x, y=y, z=z, meshSize=lc, tag=2)\\n\\nx = x; y = y + ly; z = z; lc = lc\\nierr = gmsh%model%geo%addPoint(x=x, y=y, z=z, meshSize=lc, tag=3)\\n\\nx = corner(1); y = y; z = z; lc = lc\\nierr = gmsh%model%geo%addPoint(x=x, y=y, z=z, meshSize=lc, tag=4)\\n\\nierr = gmsh%model%geo%addLine(1, 2, 1)\\nierr = gmsh%model%geo%addLine(2, 3, 2)\\nierr = gmsh%model%geo%addLine(3, 4, 3)\\nierr = gmsh%model%geo%addLine(4, 1, 4)\\n\\nierr = gmsh%model%geo%addCurveLoop([1, 2, 3, 4], tag=1)\\n\\nierr = gmsh%model%geo%addPlaneSurface([1], 1)\\n\\nierr = gmsh%model%geo%synchronize()\\n\\nierr = gmsh%option%setNumber(VALUE=1, name=\\"Mesh.SaveAll\\")\\nierr = gmsh%model%mesh%generate(2)\\n\\nierr = gmsh%model%mesh%setOrder(order)\\n\\nierr = gmsh%WRITE(title//\'.msh\')\\n\\nierr = gmsh%Finalize()\\n\\nCALL mshFile%Initiate(filename=title//\'.msh\', STATUS=\\"OLD\\", ACTION=\\"READ\\")\\nCALL mshFile%OPEN()\\nCALL mshFile%READ()\\nCALL hdf5file%Initiate(title//\'.h5\', MODE=\\"NEW\\")\\nCALL hdf5file%OPEN()\\nCALL mshFile%Export(hdf5=hdf5file, group=\\"\\")\\nCALL mshFile%DEALLOCATE()\\nCALL hdf5file%DEALLOCATE()\\n\\nEND PROGRAM main\\n```"},{"id":"/how-to-setup-a-new-kernel-in-easifem","metadata":{"permalink":"/blog/how-to-setup-a-new-kernel-in-easifem","source":"@site/docs/blog/how-to-setup-a-new-kernel-in-easifem.md","title":"Setting up a new kernel using EASIFEM","description":"This post provides definition of Kernel in EASIFEM and provides a step by step guide to create a new kernel.","date":"2025-05-11T09:05:24.000Z","tags":[{"inline":true,"label":"kernel","permalink":"/blog/tags/kernel"},{"inline":true,"label":"guide","permalink":"/blog/tags/guide"},{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"}],"readingTime":10.28,"hasTruncateMarker":true,"authors":[{"name":"Vikas Sharma","title":"Assistant Professor, Kyoto University, Japan","url":"https://github.com/vickysharma0812","socials":{"x":"https://x.com/vickysharma0812","github":"https://github.com/vickysharma0812","linkedin":"https://www.linkedin.com/in/vickysharma0812/","researchgate":"https://www.researchgate.net/profile/Vikas-Sharma-41"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/vickysharma0812.jpg","key":"vickysharma0812","page":null},{"name":"Shion Shimizu","title":"Doctoral Student, Kyoto University, Japan","url":"https://github.com/shishiousan","socials":{"github":"https://github.com/shishiousan","linkedin":"https://www.linkedin.com/in/shion-shimizu-838997340/","researchgate":"https://www.researchgate.net/profile/Shion-Shimizu"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/shishiousan.jpg","key":"shishiousan","page":null}],"frontMatter":{"title":"Setting up a new kernel using EASIFEM","description":"This post provides definition of Kernel in EASIFEM and provides a step by step guide to create a new kernel.","authors":["vickysharma0812","shishiousan"],"tags":["kernel","guide","tutorial"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Creating structured mesh in 2D using EASIFEM","permalink":"/blog/generating-2d-mesh-in-easifem"},"nextItem":{"title":"Handling Dirichlet Bounding Conditions in easifem (Part 1)","permalink":"/blog/DirichletBC/understanding-dirichletbc-3"}},"content":"This post explains the meaning of kernel in EASIFEM platform. It also describe the steps to create a new kernel in EASIFEM.\\n\\n## What is a kernel?\\n\\nA kernel is a computer program written in object oriented programming paradigm which attempts to solve a partial differential equation. In easifem, the term kernel is used for solving a particular PDE.\\n\\n:::note Why particular PDE?\\nIn our experience when we focus on solving a particular PDE, we can design the kernel quickly and more efficiently. This is because the kernel has specific tasks to perform with limited number of kernel parameters. We believe that this is a good balance between flexibility, efficiency and speed of development. In the past, we have tried to create a generic PDE solver type kernel but after few years the kernel became too complex and difficult to maintain by a group of developers. Therefore, we want to define a kernel for a specific PDE.\\n:::\\n\\n:::info Is kernel flexible?\\nYes, the kernel has sufficient amount of flexibility. For example, the coefficient of PDE can be constant, spatially changing or time dependent. The boundary condition can also be constant, space, time, or space-time dependent.\\n:::\\n\\n:::tip Kernel is blend of procedural programming and object oriented programming?\\nA kernel is a blend of procedural programming and object oriented programming. The procedural programming comes into the picture because a kernel is trying to solve a specific PDE by using a specific method. In this sense, the kernel\'s design is driven keeping procedure programming in mind. However, a kernel can solve several problems governed by the same PDE. These problems can have different types of boundary conditions and material properties. Also, we can use several numerical methods to solve the problem. In order to facilitate these objectives, we use object oriented programming.\\n:::\\n\\n<!-- truncate -->\\n\\n## Git ignore file\\n\\nAdd the following `.gitignore` file in the root directory of your kernel. This will help you to ignore the unnecessary files which are not required for the kernel.\\n\\n<details>\\n<summary>Git ignore file for EASIFEM projects</summary>\\n<div>\\n\\n```bash\\n*.a\\n*.mod\\n*.smod\\n*.o\\n*.out\\n*.i90\\n*.if90\\n*.DS_Store\\n*.prj\\n*.drawio\\n*.log\\n*.eps\\n*.h5\\n*.gp\\n*.msh\\n*.vtu\\n*.ipynb\\n*.dat\\n*.mtx\\n*.eps\\n*.pdf\\n*.geo\\n*.ps\\n*.png\\n*.jpg\\n*.plt\\n*.csv\\n\\n*/build/\\n**/build\\nbuild/\\n\\n_packages/\\n__*\\n\\nlog.txt\\ntest.txt\\n\\n## Obsidian related\\n.obsidian\\n\\n# VSCode related\\nvscode-settings\\n.vscode/\\nsettings.json\\n\\n## Docusaurus related\\n\\n# Logs\\nlogs\\n*.log\\nnpm-debug.log*\\nyarn-debug.log*\\nyarn-error.log*\\nlerna-debug.log*\\n.pnpm-debug.log*\\n\\n# Diagnostic reports (https://nodejs.org/api/report.html)\\nreport.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json\\n\\n# Runtime data\\npids\\n*.pid\\n*.seed\\n*.pid.lock\\n\\n# Directory for instrumented libs generated by jscoverage/JSCover\\nlib-cov\\n\\n# Coverage directory used by tools like istanbul\\ncoverage\\n*.lcov\\n\\n# nyc test coverage\\n.nyc_output\\n\\n# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\\n.grunt\\n\\n# Bower dependency directory (https://bower.io/)\\nbower_components\\n\\n# node-waf configuration\\n.lock-wscript\\n\\n# Compiled binary addons (https://nodejs.org/api/addons.html)\\nbuild/Release\\n\\n# Dependency directories\\nnode_modules/\\njspm_packages/\\n\\n# Snowpack dependency directory (https://snowpack.dev/)\\nweb_modules/\\n\\n# TypeScript cache\\n*.tsbuildinfo\\n\\n# Optional npm cache directory\\n.npm\\n\\n# Optional eslint cache\\n.eslintcache\\n\\n# Optional stylelint cache\\n.stylelintcache\\n\\n# Microbundle cache\\n.rpt2_cache/\\n.rts2_cache_cjs/\\n.rts2_cache_es/\\n.rts2_cache_umd/\\n\\n# Optional REPL history\\n.node_repl_history\\n\\n# Output of \'npm pack\'\\n*.tgz\\n\\n# Yarn Integrity file\\n.yarn-integrity\\n\\n# dotenv environment variable files\\n.env\\n.env.development.local\\n.env.test.local\\n.env.production.local\\n.env.local\\n\\n# parcel-bundler cache (https://parceljs.org/)\\n.cache\\n.parcel-cache\\n\\n# Next.js build output\\n.next\\nout\\n\\n# Nuxt.js build / generate output\\n.nuxt\\ndist\\n\\n# Gatsby files\\n.cache/\\n# Comment in the public line in if your project uses Gatsby and not Next.js\\n# https://nextjs.org/blog/next-9-1#public-directory-support\\n# public\\n\\n# vuepress build output\\n.vuepress/dist\\n\\n# vuepress v2.x temp and cache directory\\n.temp\\n.cache\\n\\n# Docusaurus cache and generated files\\n.docusaurus\\n\\n# Serverless directories\\n.serverless/\\n\\n# FuseBox cache\\n.fusebox/\\n\\n# DynamoDB Local files\\n.dynamodb/\\n\\n# TernJS port file\\n.tern-port\\n\\n# Stores VSCode versions used for testing VSCode extensions\\n.vscode-test\\n\\n# yarn v2\\n.yarn/cache\\n.yarn/unplugged\\n.yarn/build-state.yml\\n.yarn/install-state.gz\\n.pnp.*\\n\\n.DS_Store\\n.$*\\n\\n~*\\n```\\n\\n</div>\\n</details>\\n\\n## Directory structure\\n\\nCreate following directory in the root directory of your kernel.\\n\\n1. src: This directory will contain the source code of your kernel.\\n2. docs: This directory will contain the documentation of your kernel.\\n3. tests: This directory will contain the test code of your kernel.\\n4. examples: This directory will contain the example code and tutorials of your kernel.\\n5. cmake: This directory will contain the cmake files necessary to build your kernel.\\n6. docker: This directory will contain the docker files.\\n7. bin: This directory will contain the binary files of application based on your kernel\\n8. media: This directory will contain the figures and images used for the documentation\\n9. pages: This directory will contain the pages for documentation by using ford.\\n\\n## Structure of `src` directory\\n\\nThe `src` directory will contain the following directories and files.\\n\\n- `modules`: This directory contains the header files of the kernel. These header files are called modules.\\n- `submodules`: This directory contains the `submodules` of the kernel. These `submodules` are contains the implementation of the header files.\\n\\nLet us say you want to develop a class called `Abstract1DUVSTFEM_` (note that all user defined data types end with an underscore). Then you should create a directory called `Abstract1DUVSTFEM` in the `src/modules` directory.\\n\\nNow in `Abstract1DUVSTFEM` directory create another directory called `src` which will contain the header file. In this source directory you will create `Abstract1DUVSTFEM_Class.F90`.\\n\\nIn `Abstract1DUVSTFEM` directory create a file called `CMakeLists.txt`. The content of this is given below.\\n\\n```cmake title=\\"modules/Abstract1DUVSTFEM/CMakeLists.txt\\"\\nset(src_path \\"${CMAKE_CURRENT_LIST_DIR}/src/\\")\\ntarget_sources(${PROJECT_NAME} PRIVATE ${src_path}/Abstract1DUVSTFEM_Class.F90)\\n```\\n\\nIf you follow the above steps the src directory will look like the following.\\n\\n```bash\\nsrc\\n modules\\n  Abstract1DUVSTFEM\\n      CMakeLists.txt\\n      src\\n          Abstract1DUVSTFEM_Class.F90\\n submodules\\n```\\n\\nNow we will implement the methods defined in `Abstract1DUVSTFEM_Class.F90` in the `src/submodules` directory. Create a directory called `Abstract1DUVSTFEM` in the `src/submodules` directory. In this directory create a file called `CMakeLists.txt`. In this directory create a directory called `src` which will contain the submodules of module `Abstract1DUVSTFEM_Class`. The structure of the directory will look like this.\\n\\nThe content of `CMakeLists.txt` file will be as follows.\\n\\n```cmake title=\\"submodules/Abstract1DUVSTFEM/CMakeLists.txt\\"\\nset(src_path \\"${CMAKE_CURRENT_LIST_DIR}/src/\\")\\ntarget_sources(\\n  ${PROJECT_NAME}\\n  PRIVATE ${src_path}/Abstract1DUVSTFEM_Class@ApplyDirichletBCMethods.F90\\n```\\n\\n```bash\\nsrc\\n modules\\n  Abstract1DUVSTFEM\\n      CMakeLists.txt\\n      src\\n          Abstract1DUVSTFEM_Class.F90\\n submodules\\n     Abstract1DUVSTFEM\\n      src\\n          Abstract1DUVSTFEM_Class@ApplyDirichletBCMethods.F90\\n     CMakeLists.txt\\n```\\n\\n## Module and Submodule CMake file\\n\\nIn `modules` and `submodules` directory create a file called `CMakeLists.txt`. The CMake file will look like this.\\n\\n```cmake title=\\"modules/CMakeLists.txt\\"\\n# AbstractSTFEM\\ninclude(${CMAKE_CURRENT_LIST_DIR}/Abstract1DUVSTFEM/CMakeLists.txt)\\n```\\n\\n```cmake title=\\"submodules/CMakeLists.txt\\"\\n# AbstractSTFEM\\ninclude(${CMAKE_CURRENT_LIST_DIR}/Abstract1DUVSTFEM/CMakeLists.txt)\\n```\\n\\nNow the structure of the `src` directory will look like this.\\n\\n```bash\\nsrc\\n modules\\n  Abstract1DUVSTFEM\\n   CMakeLists.txt\\n   src\\n       Abstract1DUVSTFEM_Class.F90\\n  CMakeLists.txt\\n submodules\\n     Abstract1DUVSTFEM\\n      CMakeLists.txt\\n      src\\n          Abstract1DUVSTFEM_Class@ApplyDirichletBCMethods.F90\\n     CMakeLists.txt\\n```\\n\\nNow we need to write the main `CMakeLists.txt` file in the root of our project. That is, the parent directory of `src` directory. We will describe the content of this file in another blog post.\\n\\n<details>\\n<summary>Click here to see the content</summary>\\n<div>\\n\\n```cmake title=\\"CMakeLists.txt\\"\\ncmake_minimum_required(VERSION 3.20.0 FATAL_ERROR)\\nset(PROJECT_NAME \\"easifemOneDimElasticity\\")\\nproject(${PROJECT_NAME})\\n\\nenable_language(Fortran C CXX)\\n\\nset(VERSION_MAJOR \\"25\\")\\nset(VERSION_MINOR \\"04\\")\\nset(VERSION_BugFix \\"1\\")\\nset(PROJECT_VERSION ${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_BugFix})\\n\\nset(CMAKE_PROJECT_DESCRIPTION\\n    \\"${PROJECT_NAME} is  part of EASIFEM platform.\\n    EASIFEM: Expandable and Scalable Infrastructure for Finite Element Methods.\\n    This program solves one dimensional wave propogation problems using finite element\\n    methods including space-time finite element methods.\\n    \\")\\n\\nset(CMAKE_PROJECT_HOMEPAGE_URL \\"https://www.easifem.com\\")\\n\\nset(TARGETS_EXPORT_NAME \\"${PROJECT_NAME}Targets\\")\\nset(namespace \\"${PROJECT_NAME}\\")\\n\\ninclude(CMakePrintHelpers)\\ninclude(FortranCInterface)\\n\\nFortranCInterface_VERIFY()\\n\\nlist(APPEND TARGET_COMPILE_DEF \\"-DUSE_CMAKE\\")\\n\\n# find my cmake modules here...\\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules)\\n\\n# check error\\nif(\\" ${CMAKE_CURRENT_SOURCE_DIR}\\" STREQUAL \\" ${CMAKE_CURRENT_BINARY_DIR}\\")\\n  message(\\n    FATAL_ERROR\\n      \\"[ERROR] :: Build directory and Source directory cannot be same.\\")\\nendif()\\n\\n# make directories include(${PROJECT_SOURCE_DIR}/cmake/makeDirs.cmake)\\n#\\ninclude(GNUInstallDirs)\\n\\nset(CMAKE_Fortran_MODULE_DIRECTORY\\n    ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_INCLUDEDIR})\\n\\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY\\n    ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\\n\\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY\\n    ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\\n\\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY\\n    ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\\n\\nset(INSTALL_LIBDIR\\n    ${CMAKE_INSTALL_LIBDIR}\\n    CACHE PATH \\"Installation location of lib\\")\\n\\nset(INSTALL_INCLUDEDIR\\n    ${CMAKE_INSTALL_INCLUDEDIR}\\n    CACHE PATH \\"Installation location of module files\\")\\n\\nset(INSTALL_BINDIR\\n    ${CMAKE_INSTALL_BINDIR}\\n    CACHE PATH \\"Installation location of binary files\\")\\n\\nif(WIN32 AND NOT CYGWIN)\\n  set(DEF_INSTALL_CMAKEDIR CMake)\\nelse()\\n  set(DEF_INSTALL_CMAKEDIR share/cmake/${PROJECT_NAME})\\nendif()\\n\\nset(INSTALL_CMAKEDIR\\n    ${DEF_INSTALL_CMAKEDIR}\\n    CACHE PATH \\"Installation directory for CMake files\\")\\n\\nforeach(p LIB BIN INCLUDE CMAKE)\\n  file(TO_NATIVE_PATH ${CMAKE_INSTALL_PREFIX}/${INSTALL_${p}DIR} _path)\\n  message(STATUS \\"Installing ${p} componenets to ${_path}\\")\\nendforeach()\\n\\noption(BUILD_SHARED_LIBS \\"Build shared library\\" ON)\\n\\nif(BUILD_SHARED_LIBS)\\n  message(STATUS \\"${PROJECT_NAME} will be built as a shared library.\\")\\n  add_library(${PROJECT_NAME} SHARED \\"\\")\\n  set_property(TARGET ${PROJECT_NAME} PROPERTY POSITION_INDEPENDENT_CODE TRUE)\\nelse()\\n  message(STATUS \\"${PROJECT_NAME} will be built as a static library.\\")\\n  add_library(${PROJECT_NAME} STATIC \\"\\")\\nendif()\\n\\nmessage(\\n  STATUS\\n    \\"[INFO] :: Is the Fortran compiler loaded? ${CMAKE_Fortran_COMPILER_LOADED}\\"\\n)\\n\\nif(CMAKE_Fortran_COMPILER_LOADED)\\n  message(STATUS \\"[INFO] :: Fortran compiler: ${CMAKE_Fortran_COMPILER_ID}\\")\\n  message(\\n    STATUS\\n      \\"[INFO] :: Fortran compiler version is: ${CMAKE_Fortran_COMPILER_VERSION}\\"\\n  )\\nendif()\\n\\nif(NOT CMAKE_BUILD_TYPE)\\n  set(CMAKE_BUILD_TYPE\\n      Release\\n      CACHE STRING \\"Build type\\" FORCE)\\nendif()\\n\\nif(${CMAKE_Fortran_COMPILER_ID} STREQUAL \\"GNU\\" OR Fortran_COMPILER_NAME MATCHES\\n                                                  \\"gfortran*\\")\\n\\n  list(\\n    APPEND\\n    FORTRAN_FLAGS\\n    \\"-ffree-form\\"\\n    \\"-ffree-line-length-none\\"\\n    \\"-std=f2018\\"\\n    \\"-fimplicit-none\\"\\n    \\"-fno-range-check\\")\\n\\n  list(APPEND FORTRAN_FLAGS_RELEASE \\"-O3\\")\\n\\n  if(APPLE)\\n    list(\\n      APPEND\\n      FORTRAN_FLAGS_DEBUG\\n      \\"-fbounds-check\\"\\n      \\"-g\\"\\n      \\"-fbacktrace\\"\\n      \\"-Wextra\\"\\n      \\"-Wall\\"\\n      # \\"-fprofile-arcs\\"\\n      \\"-ftest-coverage\\"\\n      \\"-Wimplicit-interface\\")\\n\\n  else()\\n    list(\\n      APPEND\\n      FORTRAN_FLAGS_DEBUG\\n      \\"-fbounds-check\\"\\n      \\"-g\\"\\n      \\"-fbacktrace\\"\\n      \\"-Wextra\\"\\n      \\"-Wall\\"\\n      # \\"-fprofile-arcs\\"\\n      \\"-ftest-coverage\\"\\n      \\"-Wimplicit-interface\\")\\n  endif()\\n\\nelseif(${CMAKE_Fortran_COMPILER_ID} STREQUAL \\"Intel\\" OR Fortran_COMPILER_NAME\\n                                                        MATCHES \\"ifort*\\")\\n  list(APPEND FORTRAN_FLAGS \\"-r8\\" \\"-W1\\")\\n  list(APPEND FORTRAN_FLAGS_RELEASE \\"-O3\\")\\n  list(\\n    APPEND\\n    FORTRAN_FLAGS_DEBUG\\n    \\"-O0\\"\\n    \\"-traceback\\"\\n    \\"-g\\"\\n    \\"-debug all\\"\\n    \\"-check all\\"\\n    \\"-ftrapuv\\"\\n    \\"-warn\\"\\n    \\"nointerfaces\\")\\n\\nelseif(${CMAKE_Fortran_COMPILER_ID} STREQUAL \\"XL\\" OR Fortran_COMPILER_NAME\\n                                                     MATCHES \\"xlf*\\")\\n\\n  list(APPEND FORTRAN_FLAGS \\"-q64\\" \\"-qrealsize=8\\" \\"-qsuffix=f=f90:cpp=f90\\")\\n  list(APPEND FORTRAN_FLAGS_RELEASE \\"-O3\\" \\"-qstrict\\")\\n  list(APPEND FORTRAN_FLAGS_DEBUG \\"-O0\\" \\"-g\\" \\"-qfullpath\\" \\"-qkeepparm\\")\\n\\nelse()\\n  message(ERROR \\"[ERROR] :: No optimized Fortran compiler flags are known\\")\\nendif()\\n\\ncmake_print_variables(FORTRAN_FLAGS)\\ncmake_print_variables(FORTRAN_FLAGS_RELEASE)\\ncmake_print_variables(FORTRAN_FLAGS_DEBUG)\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/targetCompileOpts.cmake)\\ntarget_compile_options(\\n  ${PROJECT_NAME}\\n  PRIVATE ${TARGET_COMPILE_OPT} ${FORTRAN_FLAGS}\\n          \\"$<$<CONFIG:Debug>:${FORTRAN_FLAGS_DEBUG}>\\"\\n          \\"$<$<CONFIG:Release>:${FORTRAN_FLAGS_RELEASE}>\\")\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/targetIncludeDirs.cmake)\\ntarget_include_directories(\\n  ${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${CMAKE_Fortran_MODULE_DIRECTORY}>\\n                         $<INSTALL_INTERFACE:${INSTALL_INCLUDEDIR}>)\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/targetProperties.cmake) target properties\\nset_target_properties(\\n  ${PROJECT_NAME}\\n  PROPERTIES POSITION_INDEPENDENT_CODE 1\\n             SOVERSION ${VERSION_MAJOR}\\n             OUTPUT_NAME ${PROJECT_NAME}\\n             LIBRARY_OUTPUT_DIRECTORY ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}\\n             ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}\\n             RUNTIME_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\\n             MACOSX_RPATH ON\\n             WINDOWS_EXPORT_ALL_SYMBOLS ON)\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/targetCompileDefs.cmake)\\noption(USE_REAL32 OFF)\\noption(USE_REAL64 ON)\\n\\nif(USE_REAL32)\\n  list(APPEND TARGET_COMPILE_DEF \\"-DUSE_Real32\\")\\nendif()\\n\\nif(USE_REAL64)\\n  list(APPEND TARGET_COMPILE_DEF \\"-DUSE_Real64\\")\\nendif()\\n\\noption(USE_INT32 ON)\\nif(USE_INT32)\\n  list(APPEND TARGET_COMPILE_DEF \\"-DUSE_Int32\\")\\nendif()\\n\\noption(USE_INT64 OFF)\\nif(USE_INT64)\\n  list(APPEND TARGET_COMPILE_DEF \\"-DUSE_Int64\\")\\nendif()\\n\\nlist(APPEND TARGET_COMPILE_DEF \\"-D${CMAKE_HOST_SYSTEM_NAME}_SYSTEM\\")\\n\\n# DEFINE DEBUG\\nif(${CMAKE_BUILD_TYPE} STREQUAL \\"Debug\\")\\n  list(APPEND TARGET_COMPILE_DEF \\"-DDEBUG_VER\\")\\nendif()\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/install.cmake) Installation\\ninstall(\\n  DIRECTORY ${CMAKE_Fortran_MODULE_DIRECTORY}\\n  DESTINATION \\"./\\"\\n  COMPONENT \\"${PROJECT_NAME}\\")\\n\\ninstall(\\n  EXPORT ${TARGETS_EXPORT_NAME}\\n  FILE \\"${TARGETS_EXPORT_NAME}.cmake\\"\\n  NAMESPACE ${namespace}::\\n  DESTINATION ${INSTALL_CMAKEDIR}\\n  COMPONENT \\"${PROJECT_NAME}\\")\\n\\ninclude(CMakePackageConfigHelpers)\\n\\nwrite_basic_package_version_file(\\n  \\"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake\\"\\n  VERSION \\"${PROJECT_VERSION}\\"\\n  COMPATIBILITY AnyNewerVersion)\\n\\nconfigure_package_config_file(\\n  ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Config.cmake.in\\n  ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake\\n  INSTALL_DESTINATION ${INSTALL_CMAKEDIR}\\n  PATH_VARS INSTALL_INCLUDEDIR)\\n\\ninstall(\\n  FILES \\"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake\\"\\n        \\"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake\\"\\n  DESTINATION ${INSTALL_CMAKEDIR}\\n  COMPONENT \\"${PROJECT_NAME}-dev\\")\\n\\n# linking easifemClasses, \\n# this easifemClasses library is already linked with easifemBase\\n# so no need to link with easifemBase again.\\nfind_package(easifemClasses REQUIRED)\\nif(easifemBase_FOUND)\\n  message(STATUS \\"FOUND easifemClasses\\")\\nelse()\\n  message(ERROR \\"NOT FOUND easifemClasses\\")\\nendif()\\ntarget_link_libraries(${PROJECT_NAME} PUBLIC easifemClasses::easifemClasses)\\n\\n# Add source files\\ninclude(src/modules/CMakeLists.txt)\\ninclude(src/submodules/CMakeLists.txt)\\n\\n# this should be in the end.\\ntarget_compile_definitions(${PROJECT_NAME} PUBLIC ${TARGET_COMPILE_DEF})\\nmessage(STATUS \\"[INFO] :: Compiler definition : ${TARGET_COMPILE_DEF}\\")\\n\\ninstall(\\n  TARGETS ${PROJECT_NAME} ${C_PROJECTS}\\n  EXPORT ${TARGETS_EXPORT_NAME}\\n  COMPONENT \\"${PROJECT_NAME}\\"\\n  ARCHIVE DESTINATION ${INSTALL_LIBDIR}\\n  RUNTIME DESTINATION ${INSTALL_BINDIR}\\n  LIBRARY DESTINATION ${INSTALL_LIBDIR})\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/packaging.cmake)\\n```\\n\\n</div>\\n</details>\\n\\nThe above see make file needs `Config.cmake.in` file. The content of this file is given below.\\n\\n```cmake title=\\"Config.cmake.in\\"\\n@PACKAGE_INIT@\\n\\nFIND_PACKAGE(easifemClasses REQUIRED)\\n\\nset_and_check(\\n  \\"@PROJECT_NAME@_INCLUDE_DIR\\" \\"@PACKAGE_INSTALL_INCLUDEDIR@\\")\\n\\ninclude(\\n  \\"${CMAKE_CURRENT_LIST_DIR}/@TARGETS_EXPORT_NAME@.cmake\\")\\n\\ncheck_required_components(\\n    \\"@PROJECT_NAME@\\"\\n  )\\n```\\n\\n## Configuration for easifem CLI.\\n\\nNow that we have added the source code and setup the CMake files. We need to specify the toml configuration files for the kernel, so that we can build and install easifemOneDimElasticity kernel using easifem CLI. To do so, create a file called `oneDimElasticity.toml` in the directory where easifem plugins are kept. In our case it is kept at `~/.config/easifem/plugins/oneDimElasticity.toml`. The content of this file is given below.\\n\\n```toml title=\\"oneDimElasticity.toml\\"\\nname = \\"oneDimElasticity\\"\\nisActive = true\\nbuildSystem = \\"cmake\\"\\ngit = \'github.com/easifem/oneDimElasticity.git\'\\nsourceDir = \\"${HOME}/Dropbox/easifem/oneDimElasticity\\"\\ninstallDir = \\"${HOME}/.easifem/install/oneDimElasticity/\\"\\nbuildType = \\"Debug\\"\\nbuildSharedLibs = true\\nbuildStaticLibs = true\\nlibName = \\"easifemOneDimElasticity\\"\\ntargetName = \\"easifemOneDimElasticity\\"\\nprojectName = \\"easifemOneDimElasticity\\"\\n\\nruntest = true\\nlicense = \\"GPL3\\"\\n# buildOptions = [ \\"-D USE_GMSH_SDK:BOOL=ON\\"]\\n\\ndependencies = [\\"classes\\"]\\n```\\n\\n## Building the kernel by using easifem CLI\\n\\nTo build the kernel using easifem CLI, run the following command.\\n\\n```bash\\neasifem dev oneDimElasticity\\n```\\n\\n## Installing the kernel by using easifem CLI\\n\\nTo install the kernel using easifem CLI, run the following command.\\n\\n```bash\\neasifem install oneDimElasticity\\n```\\n\\nTo install the kernel with downloading the files from git, that is, by using the local source files, use the following command. In this case you must specify the sourceDir option in the above toml file.\\n\\n```bash\\neasifem install oneDimElasticity --no-download\\n```"},{"id":"/DirichletBC/understanding-dirichletbc-3","metadata":{"permalink":"/blog/DirichletBC/understanding-dirichletbc-3","source":"@site/docs/blog/DirichletBC/understanding-dirichletbc-3.md","title":"Handling Dirichlet Bounding Conditions in easifem (Part 1)","description":"This post explains concept of FEDOF in easifem.","date":"2024-08-22T05:33:02.000Z","tags":[{"inline":true,"label":"mesh","permalink":"/blog/tags/mesh"},{"inline":true,"label":"fedof","permalink":"/blog/tags/fedof"},{"inline":true,"label":"dirichletBC","permalink":"/blog/tags/dirichlet-bc"}],"readingTime":5.21,"hasTruncateMarker":true,"authors":[{"name":"Vikas Sharma","title":"Assistant Professor, Kyoto University, Japan","url":"https://github.com/vickysharma0812","socials":{"x":"https://x.com/vickysharma0812","github":"https://github.com/vickysharma0812","linkedin":"https://www.linkedin.com/in/vickysharma0812/","researchgate":"https://www.researchgate.net/profile/Vikas-Sharma-41"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/vickysharma0812.jpg","key":"vickysharma0812","page":null}],"frontMatter":{"title":"Handling Dirichlet Bounding Conditions in easifem (Part 1)","description":"This post explains concept of FEDOF in easifem.","authors":["vickysharma0812"],"tags":["mesh","fedof","dirichletBC"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Setting up a new kernel using EASIFEM","permalink":"/blog/how-to-setup-a-new-kernel-in-easifem"}},"content":"## Introduction\\n\\nTo apply boundary condition in FEM computation, EASIFEM, provides a class called [DirichletBC_](/docs-api/DirichletBC/DirichletBC_).\\n\\n:::info\\n`DirichletBC_` is a subclass of [AbstractBC](/docs-api/AbstractBC).\\n:::\\n\\nTo understand how `DirichletBC` works, lets consider an example of linear elasticity. Let\'s say we want to apply the following boundary condition.\\n\\n$$\\n\\\\mathbf{u} = \\\\mathbf{U}_{0}, \\\\text{ on } \\\\Gamma\\n$$\\n\\nWe may think that there is only one boundary condition. But in easifem this is not the case. Actually, $\\\\mathbf{u}$, has three components in 3D (and two components in 2D). Therefore, the above boundary condition is actually boundary condition for $u_x$, $u_y$, and $u_z$. So, we have three boundary condition on a given boundary $\\\\Gamma$.\\n\\n<!-- truncate -->\\n\\nThe second point, which is quite obvious, is that every boundary condition has two things:\\n\\n- The boundary\\n- The value (condition)\\n\\nTo define the boundary EASIFEM employs the [MeshSelection](/docs-api/MeshSelection) class. The value can be specified in several ways as mentioned below in this section.\\n\\n:::note\\nSeveral instances of DirichletBC can have same boundary but different condition.\\n:::\\n\\n## Import from toml\\n\\nWe can initiate an instance of `DirichletBC_` by importing the information from a toml-file. To do so, we will use the method called [ImportFromToml](/docs-api/AbstractBC/ImportFromToml).\\n\\nLet us consider the following toml file\\n\\nimport CodeBlock from \'@theme/CodeBlock\';\\n\\nimport CodeSnippet from \'!!raw-loader!./code/test1.toml\';\\n\\n<CodeBlock language=\\"toml\\">{CodeSnippet}</CodeBlock>\\n\\nWe use the following code to import the boundary condition from the above toml file.\\n\\nimport FortranCodeSnippet from \'!!raw-loader!./code/test1.F90\';\\n\\n<CodeBlock language=\\"fortran\\">{FortranCodeSnippet}</CodeBlock>\\n\\n## Learn from example\\n\\nLet\'s consider the following example, in which we will specify the constant boundary condition.\\n\\n<details>\\n<summary>Click here to see the example</summary>\\n<div>\\n\\n```fortran\\nPROGRAM main\\nUSE easifemBase\\nUSE easifemClasses\\nIMPLICIT NONE\\n\\nTYPE(DirichletBC_) :: obj\\nTYPE(MeshSelection_) :: boundary\\nTYPE(ParameterList_) :: param\\nTYPE(Domain_) :: dom\\nTYPE(HDF5File_) :: domainfile\\nCHARACTER(*), PARAMETER :: domainfilename = \\"./mesh3D.h5\\"\\nINTEGER(I4B) :: bottom = 1, top = 2, left = 3, right = 4, &\\n                front = 5, behind = 6, nsd\\nINTEGER(I4B), ALLOCATABLE :: nodeNum(:)\\nREAL(DFP), ALLOCATABLE :: nodalValue(:, :)\\n\\nCALL FPL_Init; CALL param%Initiate()\\nCALL domainfile%Initiate(filename=domainfilename, mode=\\"READ\\")\\nCALL domainfile%OPEN()\\nCALL dom%Initiate(domainfile, group=\\"\\")\\n\\nnsd = dom%GetNSD()\\n\\n! We call Set SetAbstractBCParam to set the parameter for boundary condition\\nCALL SetAbstractBCParam(param=param, prefix=obj%GetPrefix(),  &\\n  & name=\\"ZeroBC\\", idof=1, nodalValueType=Constant)\\n\\n! We call SetMeshSelectionParam to set the parameter for boundary condition\\nCALL SetMeshSelectionParam(param=param, prefix=boundary%GetPrefix(),  &\\n  & isSelectionByMeshID=.TRUE.)\\n\\nCALL boundary%Initiate(param)\\n\\nCALL boundary%Add(dom=dom, dim=nsd - 1, meshID=[top])\\nCALL boundary%Set()\\n\\nCALL obj%Initiate(param=param, boundary=boundary, dom=dom)\\n\\nCALL obj%Set(constantNodalValue=0.0_DFP)\\n\\nCALL obj%Get(nodeNum=nodeNum, nodalValue=nodalValue)\\n\\nCALL Display(nodeNum, \\"nodeNum\\", advance=\\"NO\\")\\nCALL Display(nodalValue, \\"nodalValue\\", advance=\\"YES\\")\\n\\nCALL domainfile%DEALLOCATE()\\nCALL dom%DEALLOCATE()\\nCALL param%DEALLOCATE(); CALL FPL_Finalize\\nEND PROGRAM main\\n```\\n\\n</div>\\n</details>\\n\\nIn the above code, to define the boundary condition, we follow the steps given below.\\n\\n### Step 1: Set the properties of the DirichletBC\\n\\nWe set the properties of `DirichletBC_` by using the method called [SetAbstractBCParam](/docs-api/AbstractBC/SetAbstractBCParam).\\n\\n```fortran\\nCALL SetAbstractBCParam(param=param, prefix=obj%GetPrefix(),  &\\n  & name=\\"ZeroBC\\", idof=1, nodalValueType=Constant)\\n```\\n\\n:::note\\nBecause we are setting constant boundary condition, we used `nodalValueType=Constant`.\\n:::\\n\\nYou can learn more about this method [here](/docs-api/AbstractBC/SetAbstractBCParam).\\n\\n### Step 2: Define a boundary\\n\\nTo define a boundary we will use the [MeshSelection](/docs-api/MeshSelection). In the above code, we select the boundary by specifing the `meshID`.\\n\\n```fortran\\nCALL SetMeshSelectionParam(param=param, prefix=boundary%GetPrefix(),  &\\n  & isSelectionByMeshID=.TRUE.)\\n```\\n\\nAfter setting the boundary parameter we call [Initiate](/docs-api/MeshSelection/Initiate) method.\\n\\n```fortran\\nCALL boundary%Initiate(param)\\n```\\n\\nSubsequently, we call `Add` method to add the information of `meshID`.\\n\\n```fortran\\nCALL boundary%Add(dom=dom, dim=nsd - 1, meshID=[top])\\nCALL boundary%Set()\\n```\\n\\n:::info\\nAfter adding the information of meshID we should call [Set](/docs-api/MeshSelection/Set) method, which means that we are done adding information to the boundary.\\n:::\\n\\nYou can learn more about `SetMeshSelectionParam` [here](/docs-api/MeshSelection/SetMeshSelectionParam)\\n\\n### Step 3: Initiate instance of `DirichletBC`\\n\\nAfter initiating the boundary, call [Initiate](/docs-api/AbstractBC/Initiate). To initiate an instance of `DirichletBC_` we need to pass the boundary, paramters, and domain.\\n\\n```fortran\\nCALL obj%Initiate(param=param, boundary=boundary, dom=dom)\\n```\\n\\n### Step 4: Set the boundary condition\\n\\nAfter initiating an instance of `DirichletBC_`, next step is to set the boundary condition. To do so, we will use the method [Set](/docs-api/AbstractBC/Set).\\n\\nWhile setting the value we should respect the configuration used while calling `SetAbstractBCParam`. For example, in the above example we configure boundary condition for `nodalValueType=Constant`. Therefore, we should set the `constantNodalValue` while calling the set method.\\n\\n```fortran\\nCALL obj%Set(constantNodalValue=0.0_DFP)\\n```\\n\\n### Step 5: Get the value of boundary condition\\n\\nTo get the boundary condition we will use the method [Get](/docs-api/AbstractBC/Get). The Get function can take two arguments `nodeNum(:)` and `nodalValue(:,:)`. The `nodeNum(:)` is compulsory, whereas `nodalValue` can be optional.\\n\\n```fortran\\nCALL obj%Get(nodeNum=nodeNum, nodalValue=nodalValue)\\n```\\n\\n:::note\\nOn return, the size of `nodeNum` and `SIZE(nodalValue, 1)` is same.\\n:::\\n\\nThe columns in `nodalValue` denotes the boundary condition at different times. You can read more about this subroutine [here](/docs-api/AbstractBC/Get).\\n\\n## Further reading\\n\\nThere is more to `DirichletBC_`, and you can learn about them from following pages. (Here `DBC` stands for `DirichletBC_`)\\n\\n<CardSection id=\\"quadraturePoints\\">\\n\\n<Card\\n    title=\\"Constant user function\\"\\n    to=\\"/guides/programming-fem/dirichletBC/dbc_userfunc_const\\"\\n    description=\\"This example shows how to initiate DBC by using a constant UserFunction $u=\\\\alpha$\\"\\n  />\\n<Card\\n    title=\\"Spatial user function\\"\\n    to=\\"/guides/programming-fem/dirichletBC/dbc_userfunc_space\\"\\n    description=\\"This example shows how to initiate DBC by using a space dependent UserFunction, $u=g(x, y, z)$\\"\\n  />\\n<Card\\n    title=\\"Toml file constant value\\"\\n    to=\\"/guides/programming-fem/dirichletBC/dbc_toml_const\\"\\n    description=\\"This example shows how to initiate DBC by reading a toml-file. Constant boundary condition, $u=\\\\alpha$\\"\\n  />\\n<Card\\n    title=\\"Toml file constant function\\"\\n    to=\\"/guides/programming-fem/dirichletBC/dbc_toml_userfunc_const\\"\\n    description=\\"This example shows how to initiate DBC by reading a toml-file. Constant boundary condition, $u=\\\\alpha$\\"\\n  />\\n<Card\\n    title=\\"Toml file space function\\"\\n    to=\\"/guides/programming-fem/dirichletBC/dbc_toml_userfunc_const\\"\\n    description=\\"This example shows how to initiate DBC by reading a toml-file. Space boundary condition, $u=g(x,y,z)$\\"\\n  />\\n</CardSection>"}]}}');

/***/ })

}]);