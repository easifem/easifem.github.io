"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkeasifem_docs"] = globalThis["webpackChunkeasifem_docs"] || []).push([["__props---blog-archiveb-32-27e"],{

/***/ "./.docusaurus/docusaurus-plugin-content-blog/blog/p/blog-archive-f05.json":
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"archive":{"blogPosts":[{"id":"/generating-2d-mesh-in-easifem","metadata":{"permalink":"/blog/generating-2d-mesh-in-easifem","source":"@site/docs/blog/generating-2d-mesh-in-easifem.md","title":"Creating structured mesh in 2D using EASIFEM","description":"This post explains methods of creating 2D mesh in easifem.","date":"2025-06-02T04:27:15.000Z","tags":[{"inline":true,"label":"mesh","permalink":"/blog/tags/mesh"},{"inline":true,"label":"gmsh","permalink":"/blog/tags/gmsh"},{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"}],"readingTime":3.52,"hasTruncateMarker":true,"authors":[{"name":"Vikas Sharma","title":"Assistant Professor, Kyoto University, Japan","url":"https://github.com/vickysharma0812","socials":{"x":"https://x.com/vickysharma0812","github":"https://github.com/vickysharma0812"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/vickysharma0812.jpg","key":"vickysharma0812","page":null},{"name":"Shion Shimizu","title":"Doctoral Student, Kyoto University, Japan","url":"https://github.com/shishiousan","socials":{"github":"https://github.com/shishiousan"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/shishiousan.jpg","key":"shishiousan","page":null}],"frontMatter":{"title":"Creating structured mesh in 2D using EASIFEM","description":"This post explains methods of creating 2D mesh in easifem.","authors":["vickysharma0812","shishiousan"],"tags":["mesh","gmsh","tutorial"],"hide_table_of_contents":false},"unlisted":false,"nextItem":{"title":"Setting up a new kernel using EASIFEM","permalink":"/blog/how-to-setup-a-new-kernel-in-easifem"}},"content":"## Creating a structured mesh of quadrangles\\n\\nTo create a structured mesh of quadrangles in easifem, we will need following classes:\\n\\n- GmshStructuredMesh_Class: This is high-level interface on top of Gmsh library to create structured meshes.\\n- Gmsh_Class: Interface to Gmsh library.\\n- MSHFile_Class: Reading gmsh files\\n- HDF5File_Class: Writing gmsh files to HDF5 file.\\n\\n![Very small mesh of quadrangles](/img/blog/very_small_quad4_mesh.svg)\\n\\n```fortran\\nPROGRAM main\\nUSE GmshStructuredMesh_Class\\nUSE Gmsh_Class\\nUSE FPL\\nUSE GlobalData\\nUSE MSHFIle_Class\\nUSE HDF5File_Class\\n\\nIMPLICIT NONE\\n\\nTYPE(GmshStructuredMesh_) :: obj\\nTYPE(Gmsh_) :: gmsh\\nTYPE(ParameterList_) :: param\\n! CHARACTER(*), PARAMETER :: title = \\"small_quad4_mesh\\"\\nCHARACTER(*), PARAMETER :: title = \\"very_small_quad4_mesh\\"\\nREAL(DFP), PARAMETER :: pointsOnAxis1(2) = [0.0, 1.0]\\nREAL(DFP), PARAMETER :: pointsOnAxis2(2) = [0.0, 1.0]\\n\\nINTEGER(I4B), PARAMETER :: transfinitePointsOnAxis1(1) = [3]\\nINTEGER(I4B), PARAMETER :: transfinitePointsOnAxis2(1) = [3]\\n\\nINTEGER(I4B) :: ierr\\n\\nTYPE(MSHFile_) :: mshFile\\nTYPE(HDF5File_) :: hdf5file\\n\\nCALL FPL_Init()\\nCALL param%Initiate()\\n\\nCALL SetGmshStructuredMeshParam(param=param, &\\n                                filename=title//\\".msh\\", &\\n                                pointsOnAxis1=pointsOnAxis1, &\\n                                pointsOnAxis2=pointsOnAxis2, &\\n                          transfinitePointsOnAxis1=transfinitePointsOnAxis1, &\\n                          transfinitePointsOnAxis2=transfinitePointsOnAxis2, &\\n                                recombineAll=.TRUE.)\\n\\nCALL obj%Initiate(param)\\n\\nierr = gmsh%initialize()\\nierr = gmsh%model%add(\\"GmshStructuredMesh2D\\")\\nCALL obj%Generate(gmsh)\\n! ierr = gmsh%fltk%run()\\nierr = gmsh%finalize()\\n\\nCALL param%DEALLOCATE()\\nCALL obj%DEALLOCATE()\\n\\nCALL mshFile%Initiate(filename=title//\'.msh\', STATUS=\\"OLD\\", ACTION=\\"READ\\")\\nCALL mshFile%OPEN()\\nCALL mshFile%READ()\\nCALL hdf5file%Initiate(title//\'.h5\', MODE=\\"NEW\\")\\nCALL hdf5file%OPEN()\\nCALL mshFile%Export(hdf5=hdf5file, group=\\"\\")\\nCALL mshFile%DEALLOCATE()\\nCALL hdf5file%DEALLOCATE()\\n\\nEND PROGRAM main\\n```\\n\\n<!-- truncate -->\\n\\n## Creating a structured mesh of quadrangles with two regions\\n\\n![Very small mesh of quadrangles with two regions](/img/blog/very_small_quad4_mesh_two_region.svg)\\n\\n```fortran\\nPROGRAM main\\nUSE GmshStructuredMesh_Class\\nUSE Gmsh_Class\\nUSE FPL\\nUSE GlobalData\\nUSE MSHFile_Class\\nUSE HDF5File_Class\\n\\nIMPLICIT NONE\\n\\nTYPE(GmshStructuredMesh_) :: obj\\nTYPE(Gmsh_) :: gmsh\\nTYPE(ParameterList_) :: param\\nCHARACTER(*), PARAMETER :: title = \\"very_small_quad4_mesh_two_region\\"\\nREAL(DFP), PARAMETER :: pointsOnAxis1(3) = [0.0, 1.0, 2.0]\\nREAL(DFP), PARAMETER :: pointsOnAxis2(2) = [0.0, 1.0]\\n\\nINTEGER(I4B), PARAMETER :: transfinitePointsOnAxis1(2) = [3, 3]\\nINTEGER(I4B), PARAMETER :: transfinitePointsOnAxis2(1) = [2]\\n\\nINTEGER(I4B) :: ierr\\n\\nTYPE(MSHFile_) :: mshFile\\nTYPE(HDF5File_) :: hdf5file\\n\\nCALL FPL_Init()\\nCALL param%Initiate()\\n\\nCALL SetGmshStructuredMeshParam( &\\n  param=param, &\\n  filename=title//\\".msh\\", &\\n  pointsOnAxis1=pointsOnAxis1, &\\n  pointsOnAxis2=pointsOnAxis2, &\\n  transfinitePointsOnAxis1=transfinitePointsOnAxis1, &\\n  transfinitePointsOnAxis2=transfinitePointsOnAxis2, &\\n  recombineAll=.TRUE.)\\n\\nCALL obj%Initiate(param)\\n\\nierr = gmsh%initialize()\\nierr = gmsh%model%add(\\"GmshStructuredMesh2D\\")\\nCALL obj%Generate(gmsh)\\n! ierr = gmsh%fltk%run()\\nierr = gmsh%finalize()\\n\\nCALL param%DEALLOCATE()\\nCALL obj%DEALLOCATE()\\n\\nCALL mshFile%Initiate(filename=title//\'.msh\', STATUS=\\"OLD\\", ACTION=\\"READ\\")\\nCALL mshFile%OPEN()\\nCALL mshFile%READ()\\nCALL hdf5file%Initiate(title//\'.h5\', MODE=\\"NEW\\")\\nCALL hdf5file%OPEN()\\nCALL mshFile%Export(hdf5=hdf5file, group=\\"\\")\\nCALL mshFile%DEALLOCATE()\\nCALL hdf5file%DEALLOCATE()\\n\\nEND PROGRAM main\\n```\\n\\n## Creating a structured mesh of triangles\\n\\n![Small mesh of linear triangles](/img/blog/small_tri3_mesh.svg)\\n\\n```fortran\\nPROGRAM main\\nUSE easifemBase\\nUSE Gmsh_Class\\nUSE HDF5File_Class\\nUSE MSHFile_Class\\n\\nTYPE(Gmsh_) :: gmsh\\n\\nCHARACTER(LEN=*), PARAMETER :: title = \\"small_tri3_mesh\\"\\nREAL(DFP), PARAMETER :: lx = 2.0\\nREAL(DFP), PARAMETER :: ly = 2.0\\nINTEGER(I4B), PARAMETER :: order = 1\\n\\nREAL(DFP), PARAMETER :: meshSize = 1.0\\nREAL(DFP), PARAMETER :: corner(3) = 0.0_DFP\\nINTEGER(I4B) :: ierr\\nREAL(DFP) :: x, y, z, lc\\n\\nTYPE(MSHFile_) :: mshFile\\nTYPE(HDF5File_) :: hdf5file\\n\\nierr = gmsh%Initialize()\\nierr = gmsh%model%add(title)\\n\\nx = corner(1); y = corner(2); z = corner(3); lc = meshSize\\nierr = gmsh%model%geo%addPoint(x=x, y=y, z=z, meshSize=lc, tag=1)\\n\\nx = x + lx; y = y; z = z; lc = lc\\nierr = gmsh%model%geo%addPoint(x=x, y=y, z=z, meshSize=lc, tag=2)\\n\\nx = x; y = y + ly; z = z; lc = lc\\nierr = gmsh%model%geo%addPoint(x=x, y=y, z=z, meshSize=lc, tag=3)\\n\\nx = corner(1); y = y; z = z; lc = lc\\nierr = gmsh%model%geo%addPoint(x=x, y=y, z=z, meshSize=lc, tag=4)\\n\\nierr = gmsh%model%geo%addLine(1, 2, 1)\\nierr = gmsh%model%geo%addLine(2, 3, 2)\\nierr = gmsh%model%geo%addLine(3, 4, 3)\\nierr = gmsh%model%geo%addLine(4, 1, 4)\\n\\nierr = gmsh%model%geo%addCurveLoop([1, 2, 3, 4], tag=1)\\n\\nierr = gmsh%model%geo%addPlaneSurface([1], 1)\\n\\nierr = gmsh%model%geo%synchronize()\\n\\nierr = gmsh%option%setNumber(VALUE=1, name=\\"Mesh.SaveAll\\")\\nierr = gmsh%model%mesh%generate(2)\\n\\nierr = gmsh%model%mesh%setOrder(order)\\n\\nierr = gmsh%WRITE(title//\'.msh\')\\n\\nierr = gmsh%Finalize()\\n\\nCALL mshFile%Initiate(filename=title//\'.msh\', STATUS=\\"OLD\\", ACTION=\\"READ\\")\\nCALL mshFile%OPEN()\\nCALL mshFile%READ()\\nCALL hdf5file%Initiate(title//\'.h5\', MODE=\\"NEW\\")\\nCALL hdf5file%OPEN()\\nCALL mshFile%Export(hdf5=hdf5file, group=\\"\\")\\nCALL mshFile%DEALLOCATE()\\nCALL hdf5file%DEALLOCATE()\\n\\nEND PROGRAM main\\n```"},{"id":"/how-to-setup-a-new-kernel-in-easifem","metadata":{"permalink":"/blog/how-to-setup-a-new-kernel-in-easifem","source":"@site/docs/blog/how-to-setup-a-new-kernel-in-easifem.md","title":"Setting up a new kernel using EASIFEM","description":"This post provides definition of Kernel in EASIFEM and provides a step by step guide to create a new kernel.","date":"2025-05-11T09:05:24.000Z","tags":[{"inline":true,"label":"kernel","permalink":"/blog/tags/kernel"},{"inline":true,"label":"guide","permalink":"/blog/tags/guide"},{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"}],"readingTime":10.28,"hasTruncateMarker":true,"authors":[{"name":"Vikas Sharma","title":"Assistant Professor, Kyoto University, Japan","url":"https://github.com/vickysharma0812","socials":{"x":"https://x.com/vickysharma0812","github":"https://github.com/vickysharma0812"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/vickysharma0812.jpg","key":"vickysharma0812","page":null},{"name":"Shion Shimizu","title":"Doctoral Student, Kyoto University, Japan","url":"https://github.com/shishiousan","socials":{"github":"https://github.com/shishiousan"},"imageURL":"https://raw.githubusercontent.com/easifem/authors/refs/heads/main/images/shishiousan.jpg","key":"shishiousan","page":null}],"frontMatter":{"title":"Setting up a new kernel using EASIFEM","description":"This post provides definition of Kernel in EASIFEM and provides a step by step guide to create a new kernel.","authors":["vickysharma0812","shishiousan"],"tags":["kernel","guide","tutorial"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Creating structured mesh in 2D using EASIFEM","permalink":"/blog/generating-2d-mesh-in-easifem"}},"content":"This post explains the meaning of kernel in EASIFEM platform. It also describe the steps to create a new kernel in EASIFEM.\\n\\n## What is a kernel?\\n\\nA kernel is a computer program written in object oriented programming paradigm which attempts to solve a partial differential equation. In easifem, the term kernel is used for solving a particular PDE.\\n\\n:::note Why particular PDE?\\nIn our experience when we focus on solving a particular PDE, we can design the kernel quickly and more efficiently. This is because the kernel has specific tasks to perform with limited number of kernel parameters. We believe that this is a good balance between flexibility, efficiency and speed of development. In the past, we have tried to create a generic PDE solver type kernel but after few years the kernel became too complex and difficult to maintain by a group of developers. Therefore, we want to define a kernel for a specific PDE.\\n:::\\n\\n:::info Is kernel flexible?\\nYes, the kernel has sufficient amount of flexibility. For example, the coefficient of PDE can be constant, spatially changing or time dependent. The boundary condition can also be constant, space, time, or space-time dependent.\\n:::\\n\\n:::tip Kernel is blend of procedural programming and object oriented programming?\\nA kernel is a blend of procedural programming and object oriented programming. The procedural programming comes into the picture because a kernel is trying to solve a specific PDE by using a specific method. In this sense, the kernel\'s design is driven keeping procedure programming in mind. However, a kernel can solve several problems governed by the same PDE. These problems can have different types of boundary conditions and material properties. Also, we can use several numerical methods to solve the problem. In order to facilitate these objectives, we use object oriented programming.\\n:::\\n\\n<!-- truncate -->\\n\\n## Git ignore file\\n\\nAdd the following `.gitignore` file in the root directory of your kernel. This will help you to ignore the unnecessary files which are not required for the kernel.\\n\\n<details>\\n<summary>Git ignore file for EASIFEM projects</summary>\\n<div>\\n\\n```bash\\n*.a\\n*.mod\\n*.smod\\n*.o\\n*.out\\n*.i90\\n*.if90\\n*.DS_Store\\n*.prj\\n*.drawio\\n*.log\\n*.eps\\n*.h5\\n*.gp\\n*.msh\\n*.vtu\\n*.ipynb\\n*.dat\\n*.mtx\\n*.eps\\n*.pdf\\n*.geo\\n*.ps\\n*.png\\n*.jpg\\n*.plt\\n*.csv\\n\\n*/build/\\n**/build\\nbuild/\\n\\n_packages/\\n__*\\n\\nlog.txt\\ntest.txt\\n\\n## Obsidian related\\n.obsidian\\n\\n# VSCode related\\nvscode-settings\\n.vscode/\\nsettings.json\\n\\n## Docusaurus related\\n\\n# Logs\\nlogs\\n*.log\\nnpm-debug.log*\\nyarn-debug.log*\\nyarn-error.log*\\nlerna-debug.log*\\n.pnpm-debug.log*\\n\\n# Diagnostic reports (https://nodejs.org/api/report.html)\\nreport.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json\\n\\n# Runtime data\\npids\\n*.pid\\n*.seed\\n*.pid.lock\\n\\n# Directory for instrumented libs generated by jscoverage/JSCover\\nlib-cov\\n\\n# Coverage directory used by tools like istanbul\\ncoverage\\n*.lcov\\n\\n# nyc test coverage\\n.nyc_output\\n\\n# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)\\n.grunt\\n\\n# Bower dependency directory (https://bower.io/)\\nbower_components\\n\\n# node-waf configuration\\n.lock-wscript\\n\\n# Compiled binary addons (https://nodejs.org/api/addons.html)\\nbuild/Release\\n\\n# Dependency directories\\nnode_modules/\\njspm_packages/\\n\\n# Snowpack dependency directory (https://snowpack.dev/)\\nweb_modules/\\n\\n# TypeScript cache\\n*.tsbuildinfo\\n\\n# Optional npm cache directory\\n.npm\\n\\n# Optional eslint cache\\n.eslintcache\\n\\n# Optional stylelint cache\\n.stylelintcache\\n\\n# Microbundle cache\\n.rpt2_cache/\\n.rts2_cache_cjs/\\n.rts2_cache_es/\\n.rts2_cache_umd/\\n\\n# Optional REPL history\\n.node_repl_history\\n\\n# Output of \'npm pack\'\\n*.tgz\\n\\n# Yarn Integrity file\\n.yarn-integrity\\n\\n# dotenv environment variable files\\n.env\\n.env.development.local\\n.env.test.local\\n.env.production.local\\n.env.local\\n\\n# parcel-bundler cache (https://parceljs.org/)\\n.cache\\n.parcel-cache\\n\\n# Next.js build output\\n.next\\nout\\n\\n# Nuxt.js build / generate output\\n.nuxt\\ndist\\n\\n# Gatsby files\\n.cache/\\n# Comment in the public line in if your project uses Gatsby and not Next.js\\n# https://nextjs.org/blog/next-9-1#public-directory-support\\n# public\\n\\n# vuepress build output\\n.vuepress/dist\\n\\n# vuepress v2.x temp and cache directory\\n.temp\\n.cache\\n\\n# Docusaurus cache and generated files\\n.docusaurus\\n\\n# Serverless directories\\n.serverless/\\n\\n# FuseBox cache\\n.fusebox/\\n\\n# DynamoDB Local files\\n.dynamodb/\\n\\n# TernJS port file\\n.tern-port\\n\\n# Stores VSCode versions used for testing VSCode extensions\\n.vscode-test\\n\\n# yarn v2\\n.yarn/cache\\n.yarn/unplugged\\n.yarn/build-state.yml\\n.yarn/install-state.gz\\n.pnp.*\\n\\n.DS_Store\\n.$*\\n\\n~*\\n```\\n\\n</div>\\n</details>\\n\\n## Directory structure\\n\\nCreate following directory in the root directory of your kernel.\\n\\n1. src: This directory will contain the source code of your kernel.\\n2. docs: This directory will contain the documentation of your kernel.\\n3. tests: This directory will contain the test code of your kernel.\\n4. examples: This directory will contain the example code and tutorials of your kernel.\\n5. cmake: This directory will contain the cmake files necessary to build your kernel.\\n6. docker: This directory will contain the docker files.\\n7. bin: This directory will contain the binary files of application based on your kernel\\n8. media: This directory will contain the figures and images used for the documentation\\n9. pages: This directory will contain the pages for documentation by using ford.\\n\\n## Structure of `src` directory\\n\\nThe `src` directory will contain the following directories and files.\\n\\n- `modules`: This directory contains the header files of the kernel. These header files are called modules.\\n- `submodules`: This directory contains the `submodules` of the kernel. These `submodules` are contains the implementation of the header files.\\n\\nLet us say you want to develop a class called `Abstract1DUVSTFEM_` (note that all user defined data types end with an underscore). Then you should create a directory called `Abstract1DUVSTFEM` in the `src/modules` directory.\\n\\nNow in `Abstract1DUVSTFEM` directory create another directory called `src` which will contain the header file. In this source directory you will create `Abstract1DUVSTFEM_Class.F90`.\\n\\nIn `Abstract1DUVSTFEM` directory create a file called `CMakeLists.txt`. The content of this is given below.\\n\\n```cmake title=\\"modules/Abstract1DUVSTFEM/CMakeLists.txt\\"\\nset(src_path \\"${CMAKE_CURRENT_LIST_DIR}/src/\\")\\ntarget_sources(${PROJECT_NAME} PRIVATE ${src_path}/Abstract1DUVSTFEM_Class.F90)\\n```\\n\\nIf you follow the above steps the src directory will look like the following.\\n\\n```bash\\nsrc\\n├── modules\\n│   └── Abstract1DUVSTFEM\\n│       ├── CMakeLists.txt\\n│       └── src\\n│           └── Abstract1DUVSTFEM_Class.F90\\n└── submodules\\n```\\n\\nNow we will implement the methods defined in `Abstract1DUVSTFEM_Class.F90` in the `src/submodules` directory. Create a directory called `Abstract1DUVSTFEM` in the `src/submodules` directory. In this directory create a file called `CMakeLists.txt`. In this directory create a directory called `src` which will contain the submodules of module `Abstract1DUVSTFEM_Class`. The structure of the directory will look like this.\\n\\nThe content of `CMakeLists.txt` file will be as follows.\\n\\n```cmake title=\\"submodules/Abstract1DUVSTFEM/CMakeLists.txt\\"\\nset(src_path \\"${CMAKE_CURRENT_LIST_DIR}/src/\\")\\ntarget_sources(\\n  ${PROJECT_NAME}\\n  PRIVATE ${src_path}/Abstract1DUVSTFEM_Class@ApplyDirichletBCMethods.F90\\n```\\n\\n```bash\\nsrc\\n├── modules\\n│   └── Abstract1DUVSTFEM\\n│       ├── CMakeLists.txt\\n│       └── src\\n│           └── Abstract1DUVSTFEM_Class.F90\\n└── submodules\\n    ├── Abstract1DUVSTFEM\\n    │   └── src\\n    │       ├── Abstract1DUVSTFEM_Class@ApplyDirichletBCMethods.F90\\n    └── CMakeLists.txt\\n```\\n\\n## Module and Submodule CMake file\\n\\nIn `modules` and `submodules` directory create a file called `CMakeLists.txt`. The CMake file will look like this.\\n\\n```cmake title=\\"modules/CMakeLists.txt\\"\\n# AbstractSTFEM\\ninclude(${CMAKE_CURRENT_LIST_DIR}/Abstract1DUVSTFEM/CMakeLists.txt)\\n```\\n\\n```cmake title=\\"submodules/CMakeLists.txt\\"\\n# AbstractSTFEM\\ninclude(${CMAKE_CURRENT_LIST_DIR}/Abstract1DUVSTFEM/CMakeLists.txt)\\n```\\n\\nNow the structure of the `src` directory will look like this.\\n\\n```bash\\nsrc\\n├── modules\\n│   ├── Abstract1DUVSTFEM\\n│   │   ├── CMakeLists.txt\\n│   │   └── src\\n│   │       └── Abstract1DUVSTFEM_Class.F90\\n│   └── CMakeLists.txt\\n└── submodules\\n    ├── Abstract1DUVSTFEM\\n    │   ├── CMakeLists.txt\\n    │   └── src\\n    │       ├── Abstract1DUVSTFEM_Class@ApplyDirichletBCMethods.F90\\n    ├── CMakeLists.txt\\n```\\n\\nNow we need to write the main `CMakeLists.txt` file in the root of our project. That is, the parent directory of `src` directory. We will describe the content of this file in another blog post.\\n\\n<details>\\n<summary>Click here to see the content</summary>\\n<div>\\n\\n```cmake title=\\"CMakeLists.txt\\"\\ncmake_minimum_required(VERSION 3.20.0 FATAL_ERROR)\\nset(PROJECT_NAME \\"easifemOneDimElasticity\\")\\nproject(${PROJECT_NAME})\\n\\nenable_language(Fortran C CXX)\\n\\nset(VERSION_MAJOR \\"25\\")\\nset(VERSION_MINOR \\"04\\")\\nset(VERSION_BugFix \\"1\\")\\nset(PROJECT_VERSION ${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_BugFix})\\n\\nset(CMAKE_PROJECT_DESCRIPTION\\n    \\"${PROJECT_NAME} is  part of EASIFEM platform.\\n    EASIFEM: Expandable and Scalable Infrastructure for Finite Element Methods.\\n    This program solves one dimensional wave propogation problems using finite element\\n    methods including space-time finite element methods.\\n    \\")\\n\\nset(CMAKE_PROJECT_HOMEPAGE_URL \\"https://www.easifem.com\\")\\n\\nset(TARGETS_EXPORT_NAME \\"${PROJECT_NAME}Targets\\")\\nset(namespace \\"${PROJECT_NAME}\\")\\n\\ninclude(CMakePrintHelpers)\\ninclude(FortranCInterface)\\n\\nFortranCInterface_VERIFY()\\n\\nlist(APPEND TARGET_COMPILE_DEF \\"-DUSE_CMAKE\\")\\n\\n# find my cmake modules here...\\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules)\\n\\n# check error\\nif(\\" ${CMAKE_CURRENT_SOURCE_DIR}\\" STREQUAL \\" ${CMAKE_CURRENT_BINARY_DIR}\\")\\n  message(\\n    FATAL_ERROR\\n      \\"[ERROR] :: Build directory and Source directory cannot be same.\\")\\nendif()\\n\\n# make directories include(${PROJECT_SOURCE_DIR}/cmake/makeDirs.cmake)\\n#\\ninclude(GNUInstallDirs)\\n\\nset(CMAKE_Fortran_MODULE_DIRECTORY\\n    ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_INCLUDEDIR})\\n\\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY\\n    ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\\n\\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY\\n    ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\\n\\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY\\n    ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\\n\\nset(INSTALL_LIBDIR\\n    ${CMAKE_INSTALL_LIBDIR}\\n    CACHE PATH \\"Installation location of lib\\")\\n\\nset(INSTALL_INCLUDEDIR\\n    ${CMAKE_INSTALL_INCLUDEDIR}\\n    CACHE PATH \\"Installation location of module files\\")\\n\\nset(INSTALL_BINDIR\\n    ${CMAKE_INSTALL_BINDIR}\\n    CACHE PATH \\"Installation location of binary files\\")\\n\\nif(WIN32 AND NOT CYGWIN)\\n  set(DEF_INSTALL_CMAKEDIR CMake)\\nelse()\\n  set(DEF_INSTALL_CMAKEDIR share/cmake/${PROJECT_NAME})\\nendif()\\n\\nset(INSTALL_CMAKEDIR\\n    ${DEF_INSTALL_CMAKEDIR}\\n    CACHE PATH \\"Installation directory for CMake files\\")\\n\\nforeach(p LIB BIN INCLUDE CMAKE)\\n  file(TO_NATIVE_PATH ${CMAKE_INSTALL_PREFIX}/${INSTALL_${p}DIR} _path)\\n  message(STATUS \\"Installing ${p} componenets to ${_path}\\")\\nendforeach()\\n\\noption(BUILD_SHARED_LIBS \\"Build shared library\\" ON)\\n\\nif(BUILD_SHARED_LIBS)\\n  message(STATUS \\"${PROJECT_NAME} will be built as a shared library.\\")\\n  add_library(${PROJECT_NAME} SHARED \\"\\")\\n  set_property(TARGET ${PROJECT_NAME} PROPERTY POSITION_INDEPENDENT_CODE TRUE)\\nelse()\\n  message(STATUS \\"${PROJECT_NAME} will be built as a static library.\\")\\n  add_library(${PROJECT_NAME} STATIC \\"\\")\\nendif()\\n\\nmessage(\\n  STATUS\\n    \\"[INFO] :: Is the Fortran compiler loaded? ${CMAKE_Fortran_COMPILER_LOADED}\\"\\n)\\n\\nif(CMAKE_Fortran_COMPILER_LOADED)\\n  message(STATUS \\"[INFO] :: Fortran compiler: ${CMAKE_Fortran_COMPILER_ID}\\")\\n  message(\\n    STATUS\\n      \\"[INFO] :: Fortran compiler version is: ${CMAKE_Fortran_COMPILER_VERSION}\\"\\n  )\\nendif()\\n\\nif(NOT CMAKE_BUILD_TYPE)\\n  set(CMAKE_BUILD_TYPE\\n      Release\\n      CACHE STRING \\"Build type\\" FORCE)\\nendif()\\n\\nif(${CMAKE_Fortran_COMPILER_ID} STREQUAL \\"GNU\\" OR Fortran_COMPILER_NAME MATCHES\\n                                                  \\"gfortran*\\")\\n\\n  list(\\n    APPEND\\n    FORTRAN_FLAGS\\n    \\"-ffree-form\\"\\n    \\"-ffree-line-length-none\\"\\n    \\"-std=f2018\\"\\n    \\"-fimplicit-none\\"\\n    \\"-fno-range-check\\")\\n\\n  list(APPEND FORTRAN_FLAGS_RELEASE \\"-O3\\")\\n\\n  if(APPLE)\\n    list(\\n      APPEND\\n      FORTRAN_FLAGS_DEBUG\\n      \\"-fbounds-check\\"\\n      \\"-g\\"\\n      \\"-fbacktrace\\"\\n      \\"-Wextra\\"\\n      \\"-Wall\\"\\n      # \\"-fprofile-arcs\\"\\n      \\"-ftest-coverage\\"\\n      \\"-Wimplicit-interface\\")\\n\\n  else()\\n    list(\\n      APPEND\\n      FORTRAN_FLAGS_DEBUG\\n      \\"-fbounds-check\\"\\n      \\"-g\\"\\n      \\"-fbacktrace\\"\\n      \\"-Wextra\\"\\n      \\"-Wall\\"\\n      # \\"-fprofile-arcs\\"\\n      \\"-ftest-coverage\\"\\n      \\"-Wimplicit-interface\\")\\n  endif()\\n\\nelseif(${CMAKE_Fortran_COMPILER_ID} STREQUAL \\"Intel\\" OR Fortran_COMPILER_NAME\\n                                                        MATCHES \\"ifort*\\")\\n  list(APPEND FORTRAN_FLAGS \\"-r8\\" \\"-W1\\")\\n  list(APPEND FORTRAN_FLAGS_RELEASE \\"-O3\\")\\n  list(\\n    APPEND\\n    FORTRAN_FLAGS_DEBUG\\n    \\"-O0\\"\\n    \\"-traceback\\"\\n    \\"-g\\"\\n    \\"-debug all\\"\\n    \\"-check all\\"\\n    \\"-ftrapuv\\"\\n    \\"-warn\\"\\n    \\"nointerfaces\\")\\n\\nelseif(${CMAKE_Fortran_COMPILER_ID} STREQUAL \\"XL\\" OR Fortran_COMPILER_NAME\\n                                                     MATCHES \\"xlf*\\")\\n\\n  list(APPEND FORTRAN_FLAGS \\"-q64\\" \\"-qrealsize=8\\" \\"-qsuffix=f=f90:cpp=f90\\")\\n  list(APPEND FORTRAN_FLAGS_RELEASE \\"-O3\\" \\"-qstrict\\")\\n  list(APPEND FORTRAN_FLAGS_DEBUG \\"-O0\\" \\"-g\\" \\"-qfullpath\\" \\"-qkeepparm\\")\\n\\nelse()\\n  message(ERROR \\"[ERROR] :: No optimized Fortran compiler flags are known\\")\\nendif()\\n\\ncmake_print_variables(FORTRAN_FLAGS)\\ncmake_print_variables(FORTRAN_FLAGS_RELEASE)\\ncmake_print_variables(FORTRAN_FLAGS_DEBUG)\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/targetCompileOpts.cmake)\\ntarget_compile_options(\\n  ${PROJECT_NAME}\\n  PRIVATE ${TARGET_COMPILE_OPT} ${FORTRAN_FLAGS}\\n          \\"$<$<CONFIG:Debug>:${FORTRAN_FLAGS_DEBUG}>\\"\\n          \\"$<$<CONFIG:Release>:${FORTRAN_FLAGS_RELEASE}>\\")\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/targetIncludeDirs.cmake)\\ntarget_include_directories(\\n  ${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${CMAKE_Fortran_MODULE_DIRECTORY}>\\n                         $<INSTALL_INTERFACE:${INSTALL_INCLUDEDIR}>)\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/targetProperties.cmake) target properties\\nset_target_properties(\\n  ${PROJECT_NAME}\\n  PROPERTIES POSITION_INDEPENDENT_CODE 1\\n             SOVERSION ${VERSION_MAJOR}\\n             OUTPUT_NAME ${PROJECT_NAME}\\n             LIBRARY_OUTPUT_DIRECTORY ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}\\n             ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}\\n             RUNTIME_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}\\n             MACOSX_RPATH ON\\n             WINDOWS_EXPORT_ALL_SYMBOLS ON)\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/targetCompileDefs.cmake)\\noption(USE_REAL32 OFF)\\noption(USE_REAL64 ON)\\n\\nif(USE_REAL32)\\n  list(APPEND TARGET_COMPILE_DEF \\"-DUSE_Real32\\")\\nendif()\\n\\nif(USE_REAL64)\\n  list(APPEND TARGET_COMPILE_DEF \\"-DUSE_Real64\\")\\nendif()\\n\\noption(USE_INT32 ON)\\nif(USE_INT32)\\n  list(APPEND TARGET_COMPILE_DEF \\"-DUSE_Int32\\")\\nendif()\\n\\noption(USE_INT64 OFF)\\nif(USE_INT64)\\n  list(APPEND TARGET_COMPILE_DEF \\"-DUSE_Int64\\")\\nendif()\\n\\nlist(APPEND TARGET_COMPILE_DEF \\"-D${CMAKE_HOST_SYSTEM_NAME}_SYSTEM\\")\\n\\n# DEFINE DEBUG\\nif(${CMAKE_BUILD_TYPE} STREQUAL \\"Debug\\")\\n  list(APPEND TARGET_COMPILE_DEF \\"-DDEBUG_VER\\")\\nendif()\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/install.cmake) Installation\\ninstall(\\n  DIRECTORY ${CMAKE_Fortran_MODULE_DIRECTORY}\\n  DESTINATION \\"./\\"\\n  COMPONENT \\"${PROJECT_NAME}\\")\\n\\ninstall(\\n  EXPORT ${TARGETS_EXPORT_NAME}\\n  FILE \\"${TARGETS_EXPORT_NAME}.cmake\\"\\n  NAMESPACE ${namespace}::\\n  DESTINATION ${INSTALL_CMAKEDIR}\\n  COMPONENT \\"${PROJECT_NAME}\\")\\n\\ninclude(CMakePackageConfigHelpers)\\n\\nwrite_basic_package_version_file(\\n  \\"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake\\"\\n  VERSION \\"${PROJECT_VERSION}\\"\\n  COMPATIBILITY AnyNewerVersion)\\n\\nconfigure_package_config_file(\\n  ${CMAKE_CURRENT_SOURCE_DIR}/cmake/Config.cmake.in\\n  ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake\\n  INSTALL_DESTINATION ${INSTALL_CMAKEDIR}\\n  PATH_VARS INSTALL_INCLUDEDIR)\\n\\ninstall(\\n  FILES \\"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake\\"\\n        \\"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake\\"\\n  DESTINATION ${INSTALL_CMAKEDIR}\\n  COMPONENT \\"${PROJECT_NAME}-dev\\")\\n\\n# linking easifemClasses, \\n# this easifemClasses library is already linked with easifemBase\\n# so no need to link with easifemBase again.\\nfind_package(easifemClasses REQUIRED)\\nif(easifemBase_FOUND)\\n  message(STATUS \\"FOUND easifemClasses\\")\\nelse()\\n  message(ERROR \\"NOT FOUND easifemClasses\\")\\nendif()\\ntarget_link_libraries(${PROJECT_NAME} PUBLIC easifemClasses::easifemClasses)\\n\\n# Add source files\\ninclude(src/modules/CMakeLists.txt)\\ninclude(src/submodules/CMakeLists.txt)\\n\\n# this should be in the end.\\ntarget_compile_definitions(${PROJECT_NAME} PUBLIC ${TARGET_COMPILE_DEF})\\nmessage(STATUS \\"[INFO] :: Compiler definition : ${TARGET_COMPILE_DEF}\\")\\n\\ninstall(\\n  TARGETS ${PROJECT_NAME} ${C_PROJECTS}\\n  EXPORT ${TARGETS_EXPORT_NAME}\\n  COMPONENT \\"${PROJECT_NAME}\\"\\n  ARCHIVE DESTINATION ${INSTALL_LIBDIR}\\n  RUNTIME DESTINATION ${INSTALL_BINDIR}\\n  LIBRARY DESTINATION ${INSTALL_LIBDIR})\\n\\n# include(${PROJECT_SOURCE_DIR}/cmake/packaging.cmake)\\n```\\n\\n</div>\\n</details>\\n\\nThe above see make file needs `Config.cmake.in` file. The content of this file is given below.\\n\\n```cmake title=\\"Config.cmake.in\\"\\n@PACKAGE_INIT@\\n\\nFIND_PACKAGE(easifemClasses REQUIRED)\\n\\nset_and_check(\\n  \\"@PROJECT_NAME@_INCLUDE_DIR\\" \\"@PACKAGE_INSTALL_INCLUDEDIR@\\")\\n\\ninclude(\\n  \\"${CMAKE_CURRENT_LIST_DIR}/@TARGETS_EXPORT_NAME@.cmake\\")\\n\\ncheck_required_components(\\n    \\"@PROJECT_NAME@\\"\\n  )\\n```\\n\\n## Configuration for easifem CLI.\\n\\nNow that we have added the source code and setup the CMake files. We need to specify the toml configuration files for the kernel, so that we can build and install easifemOneDimElasticity kernel using easifem CLI. To do so, create a file called `oneDimElasticity.toml` in the directory where easifem plugins are kept. In our case it is kept at `~/.config/easifem/plugins/oneDimElasticity.toml`. The content of this file is given below.\\n\\n```toml title=\\"oneDimElasticity.toml\\"\\nname = \\"oneDimElasticity\\"\\nisActive = true\\nbuildSystem = \\"cmake\\"\\ngit = \'github.com/easifem/oneDimElasticity.git\'\\nsourceDir = \\"${HOME}/Dropbox/easifem/oneDimElasticity\\"\\ninstallDir = \\"${HOME}/.easifem/install/oneDimElasticity/\\"\\nbuildType = \\"Debug\\"\\nbuildSharedLibs = true\\nbuildStaticLibs = true\\nlibName = \\"easifemOneDimElasticity\\"\\ntargetName = \\"easifemOneDimElasticity\\"\\nprojectName = \\"easifemOneDimElasticity\\"\\n\\nruntest = true\\nlicense = \\"GPL3\\"\\n# buildOptions = [ \\"-D USE_GMSH_SDK:BOOL=ON\\"]\\n\\ndependencies = [\\"classes\\"]\\n```\\n\\n## Building the kernel by using easifem CLI\\n\\nTo build the kernel using easifem CLI, run the following command.\\n\\n```bash\\neasifem dev oneDimElasticity\\n```\\n\\n## Installing the kernel by using easifem CLI\\n\\nTo install the kernel using easifem CLI, run the following command.\\n\\n```bash\\neasifem install oneDimElasticity\\n```\\n\\nTo install the kernel with downloading the files from git, that is, by using the local source files, use the following command. In this case you must specify the sourceDir option in the above toml file.\\n\\n```bash\\neasifem install oneDimElasticity --no-download\\n```"}]}}');

/***/ })

}]);