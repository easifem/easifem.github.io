"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkeasifem_docs"] = globalThis["webpackChunkeasifem_docs"] || []).push([["content---docs-api-append-utility-append-491-bbc"],{

/***/ "./docs/docs-api/AppendUtility/Append.md":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  assets: () => (/* binding */ assets),\n  contentTitle: () => (/* binding */ Append_contentTitle),\n  \"default\": () => (/* binding */ Append_MDXContent),\n  frontMatter: () => (/* binding */ Append_frontMatter),\n  metadata: () => (/* reexport */ site_docs_docs_api_append_utility_append_md_491_namespaceObject),\n  toc: () => (/* binding */ Append_toc)\n});\n\n;// ./.docusaurus/docusaurus-plugin-content-docs/docs-api/site-docs-docs-api-append-utility-append-md-491.json\nconst site_docs_docs_api_append_utility_append_md_491_namespaceObject = /*#__PURE__*/JSON.parse('{\"id\":\"AppendUtility/Append\",\"title\":\"Append\",\"description\":\"Append is a generic subroutine to append entries to vector of real or integer.\",\"source\":\"@site/docs/docs-api/AppendUtility/Append.md\",\"sourceDirName\":\"AppendUtility\",\"slug\":\"/AppendUtility/Append\",\"permalink\":\"/docs-api/AppendUtility/Append\",\"draft\":false,\"unlisted\":false,\"editUrl\":\"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AppendUtility/Append.md\",\"tags\":[],\"version\":\"current\",\"lastUpdatedAt\":1539502055000,\"frontMatter\":{},\"sidebar\":\"tutorialSidebar\",\"previous\":{\"title\":\"AppendUtility\",\"permalink\":\"/docs-api/AppendUtility/\"},\"next\":{\"title\":\"ColConcat\",\"permalink\":\"/docs-api/AppendUtility/ColConcat\"}}');\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(\"./node_modules/react/jsx-runtime.js\");\n// EXTERNAL MODULE: ./node_modules/@mdx-js/react/lib/index.js\nvar lib = __webpack_require__(\"./node_modules/@mdx-js/react/lib/index.js\");\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Tabs/index.js + 2 modules\nvar Tabs = __webpack_require__(\"./node_modules/@docusaurus/theme-classic/lib/theme/Tabs/index.js\");\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/TabItem/index.js + 1 modules\nvar TabItem = __webpack_require__(\"./node_modules/@docusaurus/theme-classic/lib/theme/TabItem/index.js\");\n;// ./docs/docs-api/AppendUtility/examples/_Append_test_1.md\n\n\nconst frontMatter = {};\nconst contentTitle = undefined;\n\n\n\n\n\nconst toc = [];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    pre: \"pre\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n    USE easifemBase\\n    IMPLICIT NONE\\n    INTEGER(I4B), ALLOCATABLE :: intvec1(:)\\n    REAL( DFP ), ALLOCATABLE :: realvec1(:)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now lets us append a single ENTRY to a vector of integers.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL Append(intvec1, 1)\\nCALL OK( ALL(intvec1 .EQ. [1]), \\\"Append single ENTRY\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Appending a vector to a vector.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL Append(intvec1, [2,3])\\nCALL OK( ALL(intvec1 .EQ. [1,2,3]), \\\"Append a vector\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now lets us append a single real value to realvec.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL Append(realvec1, 1.0_DFP)\\nCALL OK( ALL(realvec1 .EQ. [1.0_DFP]), \\\"Append single ENTRY\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Appending vector to a vector.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL Append(realvec1, [2.0_DFP,3.0_DFP])\\nCALL OK( ALL(realvec1 .EQ. [1.0_DFP,2.0_DFP,3.0_DFP]), \\\"Append a vector\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Cleanup\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"    DEALLOCATE(intvec1, realvec1)\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/AppendUtility/examples/_Append_test_2.md\n\n\nconst _Append_test_2_frontMatter = {};\nconst _Append_test_2_contentTitle = undefined;\n\n\n\n\n\nconst _Append_test_2_toc = [];\nfunction _Append_test_2_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    pre: \"pre\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n    USE easifemBase\\n    IMPLICIT NONE\\n    INTEGER(I4B), ALLOCATABLE :: intvec1(:)\\n    REAL( DFP ), ALLOCATABLE :: realvec1(:)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now lets us append a single ENTRY to a vector of integers.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"intvec1 = [1] .append. 2\\nCALL OK( ALL(intvec1 .EQ. [1, 2]), \\\"Append single ENTRY\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Appending a vector to a vector.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"intvec1 = intvec1 .append. [3]\\nCALL OK( ALL(intvec1 .EQ. [1,2,3]), \\\"Append a vector\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now lets us append a single real value to realvec.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"realvec1 = [1.0_DFP] .append. 2.0_DFP\\nCALL OK( ALL(realvec1 .EQ. [1.0_DFP, 2.0_DFP]), \\\"Append single ENTRY\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Appending vector to a vector.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"realvec1 = realvec1 .append. [3.0_DFP]\\nCALL OK( ALL(realvec1 .EQ. [1.0_DFP,2.0_DFP,3.0_DFP]), \\\"Append a vector\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Cleanup\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"    DEALLOCATE(intvec1, realvec1)\\nEND PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _Append_test_2_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_Append_test_2_createMdxContent, {\n      ...props\n    })\n  }) : _Append_test_2_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/AppendUtility/examples/_Append_test_3.md\n\n\nconst _Append_test_3_frontMatter = {};\nconst _Append_test_3_contentTitle = undefined;\n\n\n\n\n\nconst _Append_test_3_toc = [];\nfunction _Append_test_3_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    pre: \"pre\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n    USE easifemBase\\n    IMPLICIT NONE\\n    INTEGER(I4B), ALLOCATABLE :: C(:), B(:), A(:)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        metastring: \"title=\\\"A and B are vectors\\\"\",\n        children: \"A = [1]\\nB = [2]\\nCALL Append(C, A, B)\\nCALL OK( ALL(C .EQ. [1, 2]), \\\"tests(1):\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        metastring: \"title=\\\"A is vector B is scalar\\\"\",\n        children: \"A = [1]\\nCALL Append(C, A, 2)\\nCALL OK( ALL(C .EQ. [1, 2]), \\\"tests(2):\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"END PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _Append_test_3_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_Append_test_3_createMdxContent, {\n      ...props\n    })\n  }) : _Append_test_3_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/AppendUtility/examples/_Append_test_4.md\n\n\nconst _Append_test_4_frontMatter = {};\nconst _Append_test_4_contentTitle = undefined;\n\n\n\n\n\nconst _Append_test_4_toc = [];\nfunction _Append_test_4_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    pre: \"pre\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n    USE easifemBase\\n    IMPLICIT NONE\\n    INTEGER(I4B), ALLOCATABLE :: intvec1(:)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Now lets us append a single ENTRY to a vector.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL Append(intvec1, 1, mask=.true.)\\nCALL Append(intvec1, 1, mask=.false.)\\nCALL OK( ALL(intvec1 .EQ. [1]), \\\"Append single ENTRY\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Appending a vector to a vector.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL Append(intvec1, [2,3], mask=[.true., .true.])\\nCALL Append(intvec1, [4,5], mask=[.true., .false.])\\nCALL OK( ALL(intvec1 .EQ. [1,2,3,4]), \\\"Append a vector\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"END PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _Append_test_4_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_Append_test_4_createMdxContent, {\n      ...props\n    })\n  }) : _Append_test_4_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/AppendUtility/examples/_Append_test_5.md\n\n\nconst _Append_test_5_frontMatter = {};\nconst _Append_test_5_contentTitle = undefined;\n\n\n\n\n\nconst _Append_test_5_toc = [];\nfunction _Append_test_5_createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    pre: \"pre\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PROGRAM main\\n    USE easifemBase\\n    IMPLICIT NONE\\n    INTEGER(I4B), ALLOCATABLE :: C(:), B(:), A(:)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        metastring: \"title=\\\"A and B are vectors\\\"\",\n        children: \"  A = [1, 2]\\n  B = [3, 4]\\n  !!\\n  !! Append B(1) and B(2) to A and assign to C.\\n  !!\\n  CALL Append(C, A, B, mask=[.true., .true.]) \\n  CALL OK( ALL(C .EQ. [1, 2, 3, 4]), \\\"Append:\\\"  )\\n\\n  !!\\n  !! Append B(1) to A and assign to C.\\n  !!\\n  CALL Append(C, A, B, mask=[.true., .false.]) \\n  CALL OK( ALL(C .EQ. [1, 2, 3]), \\\"Append:\\\"  )\\n\\n\\n  !!\\n  !! Do not append B to A, just assign A to C.\\n  !!\\n  CALL Append(C, A, B, mask=[.false., .false.]) \\n  CALL OK( ALL(C .EQ. [1, 2]), \\\"Append:\\\" )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        metastring: \"title=\\\"A is vector B is scalar\\\"\",\n        children: \"  !!\\n  !! Append 3 to A and then assign result to C\\n  !!\\n  CALL Append(C, A, 3, mask=.true.)\\n  CALL OK( ALL(C .EQ. [1, 2, 3]), \\\"Append:\\\"  )\\n\\n  !!\\n  !! Do not append 3 to A, assign result to C, that is C =A\\n  !!\\n  CALL Append(C, A, 3, mask=.false.)\\n  CALL OK( ALL(C .EQ. [1, 2]), \\\"Append:\\\"  )\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"END PROGRAM main\\n\"\n      })\n    })]\n  });\n}\nfunction _Append_test_5_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_Append_test_5_createMdxContent, {\n      ...props\n    })\n  }) : _Append_test_5_createMdxContent(props);\n}\n\n\n;// ./docs/docs-api/AppendUtility/Append.md\n\n\nconst Append_frontMatter = {};\nconst Append_contentTitle = 'Append';\n\nconst assets = {\n\n};\n\n\n\n\n\n\n\n\n\n\nconst Append_toc = [{\n  \"value\": \"Interface 1\",\n  \"id\": \"interface-1\",\n  \"level\": 2\n}, ...toc, ..._Append_test_2_toc, {\n  \"value\": \"Interface 2\",\n  \"id\": \"interface-2\",\n  \"level\": 2\n}, ..._Append_test_3_toc, {\n  \"value\": \"Interface 3\",\n  \"id\": \"interface-3\",\n  \"level\": 2\n}, ..._Append_test_4_toc, {\n  \"value\": \"Interface 4\",\n  \"id\": \"interface-4\",\n  \"level\": 2\n}, ..._Append_test_5_toc];\nfunction Append_createMdxContent(props) {\n  const _components = {\n    admonition: \"admonition\",\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    header: \"header\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.header, {\n      children: (0,jsx_runtime.jsx)(_components.h1, {\n        id: \"append\",\n        children: \"Append\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Append is a generic subroutine to append entries to vector of real or integer.\"\n    }), \"\\n\", \"\\n\", (0,jsx_runtime.jsx)(_components.admonition, {\n      type: \"note\",\n      children: (0,jsx_runtime.jsx)(_components.p, {\n        children: \"While calling Append the initial vector can be unallocated in the begining.\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Calling examples:\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"CALL Append(A, entry)\\nCALL Append(C, A, B)\\nCALL Append(A, entry, mask)\\nCALL Append(C, A, B, mask)\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"interface-1\",\n      children: \"Interface 1\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(Tabs[\"default\"], {\n      children: [(0,jsx_runtime.jsxs)(TabItem[\"default\"], {\n        value: \"append\",\n        label: \"Append (1)\",\n        children: [(0,jsx_runtime.jsx)(_components.pre, {\n          children: (0,jsx_runtime.jsx)(_components.code, {\n            className: \"language-fortran\",\n            children: \"CALL Append(A, entry)\\n\"\n          })\n        }), (0,jsx_runtime.jsx)(_components.p, {\n          children: \"Here,\"\n        }), (0,jsx_runtime.jsxs)(_components.ul, {\n          children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"A\"\n            }), \" can be an allocatable vector of real or integer.\"]\n          }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"entry\"\n            }), \" can be a scalar of real or integer.\"]\n          }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"entry\"\n            }), \" can be a vector of real or integer.\"]\n          }), \"\\n\"]\n        }), (0,jsx_runtime.jsx)(_components.p, {\n          children: \"We can:\"\n        }), (0,jsx_runtime.jsxs)(_components.ul, {\n          children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Append a scalar-integer to an integer-vector\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Append an integer-vector and scalar to an integer-vector\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Append a scalar-real to a real-vector\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Append a real-vector to a real-vector\"\n          }), \"\\n\"]\n        }), (0,jsx_runtime.jsxs)(_components.admonition, {\n          type: \"note\",\n          children: [(0,jsx_runtime.jsx)(_components.p, {\n            children: \"We can also use this method as:\"\n          }), (0,jsx_runtime.jsx)(_components.pre, {\n            children: (0,jsx_runtime.jsx)(_components.code, {\n              className: \"language-fortran\",\n              children: \"A = A .append. entry\\n\"\n            })\n          })]\n        })]\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"example\",\n        label: \"Example 1\",\n        children: (0,jsx_runtime.jsx)(MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"example2\",\n        label: \"Example 2\",\n        children: (0,jsx_runtime.jsx)(_Append_test_2_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"close\",\n        label: \"↢ \"\n      })]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"interface-2\",\n      children: \"Interface 2\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(Tabs[\"default\"], {\n      children: [(0,jsx_runtime.jsxs)(TabItem[\"default\"], {\n        value: \"append\",\n        label: \"Append (2)\",\n        children: [(0,jsx_runtime.jsx)(_components.pre, {\n          children: (0,jsx_runtime.jsx)(_components.code, {\n            className: \"language-fortran\",\n            children: \"CALL Append(C, A, B)\\n\"\n          })\n        }), (0,jsx_runtime.jsx)(_components.p, {\n          children: \"where,\"\n        }), (0,jsx_runtime.jsxs)(_components.ul, {\n          children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [\"Append A and B, then assign it to \", (0,jsx_runtime.jsx)(_components.code, {\n              children: \"C\"\n            })]\n          }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"C\"\n            }), \" can be an allocatable vector of real or integer\"]\n          }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"A\"\n            }), \" can be a vector of real or integer\"]\n          }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"B\"\n            }), \" can be a scalar of real or integer\"]\n          }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"B\"\n            }), \" can be a vector of real or integer\"]\n          }), \"\\n\"]\n        }), (0,jsx_runtime.jsx)(_components.admonition, {\n          type: \"note\",\n          children: (0,jsx_runtime.jsxs)(_components.p, {\n            children: [\"Currently, \", (0,jsx_runtime.jsx)(_components.code, {\n              children: \"A\"\n            }), \" cannot be scalar in the above interface.\"]\n          })\n        }), (0,jsx_runtime.jsx)(_components.p, {\n          children: \"We can:\"\n        }), (0,jsx_runtime.jsxs)(_components.ul, {\n          children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Append a scalar and a vector of int to another vector of int\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Append two vectors of int to another vector of int\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Append a scalar and a vector of real to another vector of real\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Append two vectors of real to another vector of real\"\n          }), \"\\n\"]\n        })]\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"example\",\n        label: \"See example\",\n        children: (0,jsx_runtime.jsx)(_Append_test_3_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"close\",\n        label: \"↢ \"\n      })]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"interface-3\",\n      children: \"Interface 3\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(Tabs[\"default\"], {\n      children: [(0,jsx_runtime.jsxs)(TabItem[\"default\"], {\n        value: \"append\",\n        label: \"Append (3)\",\n        children: [(0,jsx_runtime.jsx)(_components.pre, {\n          children: (0,jsx_runtime.jsx)(_components.code, {\n            className: \"language-fortran\",\n            children: \"CALL Append(A, entry, mask)\\n\"\n          })\n        }), (0,jsx_runtime.jsx)(_components.p, {\n          children: \"here,\"\n        }), (0,jsx_runtime.jsxs)(_components.ul, {\n          children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"A\"\n            }), \" is an allocatable vector of real or integer.\"]\n          }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"entry\"\n            }), \" can be a scalar of real or integer. In this case \", (0,jsx_runtime.jsx)(_components.code, {\n              children: \"mask\"\n            }), \" is a scalar of logical type\"]\n          }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"entry\"\n            }), \" can be a vector of real or integer. In this case, \", (0,jsx_runtime.jsx)(_components.code, {\n              children: \"mask\"\n            }), \" will be a vector of logical types.\"]\n          }), \"\\n\"]\n        }), (0,jsx_runtime.jsx)(_components.admonition, {\n          type: \"note\",\n          children: (0,jsx_runtime.jsxs)(_components.p, {\n            children: [\"The size of \", (0,jsx_runtime.jsx)(_components.code, {\n              children: \"mask\"\n            }), \" should be same as the size of \", (0,jsx_runtime.jsx)(_components.code, {\n              children: \"entry\"\n            }), \".\"]\n          })\n        }), (0,jsx_runtime.jsx)(_components.p, {\n          children: \"We can:\"\n        }), (0,jsx_runtime.jsxs)(_components.ul, {\n          children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Masked append a scalar integer to a vector of int\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Masked append a scalar real to a vector of reals\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Masked append a vector of integer to a vector of integer\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Masked append a vector of real to a vector of real\"\n          }), \"\\n\"]\n        })]\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"example\",\n        label: \"See example\",\n        children: (0,jsx_runtime.jsx)(_Append_test_4_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"close\",\n        label: \"↢ \"\n      })]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"interface-4\",\n      children: \"Interface 4\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(Tabs[\"default\"], {\n      children: [(0,jsx_runtime.jsxs)(TabItem[\"default\"], {\n        value: \"append\",\n        label: \"Append (4)\",\n        children: [(0,jsx_runtime.jsx)(_components.pre, {\n          children: (0,jsx_runtime.jsx)(_components.code, {\n            className: \"language-fortran\",\n            children: \"CALL Append(C, A, B, mask)\\n\"\n          })\n        }), (0,jsx_runtime.jsx)(_components.p, {\n          children: \"where,\"\n        }), (0,jsx_runtime.jsxs)(_components.ul, {\n          children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"C\"\n            }), \" is an allocatable vector of real or integer\"]\n          }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"A\"\n            }), \" is a vector of real or integer\"]\n          }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n            children: [(0,jsx_runtime.jsx)(_components.code, {\n              children: \"B\"\n            }), \" is a vector of real or integer\"]\n          }), \"\\n\"]\n        }), (0,jsx_runtime.jsx)(_components.admonition, {\n          type: \"note\",\n          children: (0,jsx_runtime.jsxs)(_components.p, {\n            children: [\"Currently, we do not allow \", (0,jsx_runtime.jsx)(_components.code, {\n              children: \"A\"\n            }), \" to be a scalar in the above call.\"]\n          })\n        }), (0,jsx_runtime.jsx)(_components.p, {\n          children: \"We can:\"\n        }), (0,jsx_runtime.jsxs)(_components.ul, {\n          children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Masked append a scalar and vector of int to another vector of int\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Masked append a scalar and vector real to another vector of real\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Masked append two vectors of integer to another vector of integer\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"Masked append two vectors of real to another vector of real\"\n          }), \"\\n\"]\n        })]\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"example\",\n        label: \"See example\",\n        children: (0,jsx_runtime.jsx)(_Append_test_5_MDXContent, {})\n      }), (0,jsx_runtime.jsx)(TabItem[\"default\"], {\n        value: \"close\",\n        label: \"↢ \"\n      })]\n    })]\n  });\n}\nfunction Append_MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(Append_createMdxContent, {\n      ...props\n    })\n  }) : Append_createMdxContent(props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9kb2NzL2RvY3MtYXBpL0FwcGVuZFV0aWxpdHkvQXBwZW5kLm1kIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vhc2lmZW0tZG9jcy8uL2RvY3MvZG9jcy1hcGkvQXBwZW5kVXRpbGl0eS9leGFtcGxlcy9fQXBwZW5kX3Rlc3RfMS5tZD8wN2EyIiwid2VicGFjazovL2Vhc2lmZW0tZG9jcy8uL2RvY3MvZG9jcy1hcGkvQXBwZW5kVXRpbGl0eS9leGFtcGxlcy9fQXBwZW5kX3Rlc3RfMi5tZD80YTQ4Iiwid2VicGFjazovL2Vhc2lmZW0tZG9jcy8uL2RvY3MvZG9jcy1hcGkvQXBwZW5kVXRpbGl0eS9leGFtcGxlcy9fQXBwZW5kX3Rlc3RfMy5tZD9lNjY0Iiwid2VicGFjazovL2Vhc2lmZW0tZG9jcy8uL2RvY3MvZG9jcy1hcGkvQXBwZW5kVXRpbGl0eS9leGFtcGxlcy9fQXBwZW5kX3Rlc3RfNC5tZD9lODhkIiwid2VicGFjazovL2Vhc2lmZW0tZG9jcy8uL2RvY3MvZG9jcy1hcGkvQXBwZW5kVXRpbGl0eS9leGFtcGxlcy9fQXBwZW5kX3Rlc3RfNS5tZD9kMjA1Iiwid2VicGFjazovL2Vhc2lmZW0tZG9jcy8uL2RvY3MvZG9jcy1hcGkvQXBwZW5kVXRpbGl0eS9BcHBlbmQubWQ/NWJlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuZXhwb3J0IGNvbnN0IGZyb250TWF0dGVyID0ge307XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gdW5kZWZpbmVkO1xuXG5cblxuaW1wb3J0IHtGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7dXNlTURYQ29tcG9uZW50cyBhcyBfcHJvdmlkZUNvbXBvbmVudHN9IGZyb20gXCJAbWR4LWpzL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgdG9jID0gW107XG5mdW5jdGlvbiBfY3JlYXRlTWR4Q29udGVudChwcm9wcykge1xuICBjb25zdCBfY29tcG9uZW50cyA9IHtcbiAgICBjb2RlOiBcImNvZGVcIixcbiAgICBwOiBcInBcIixcbiAgICBwcmU6IFwicHJlXCIsXG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQUk9HUkFNIG1haW5cXG4gICAgVVNFIGVhc2lmZW1CYXNlXFxuICAgIElNUExJQ0lUIE5PTkVcXG4gICAgSU5URUdFUihJNEIpLCBBTExPQ0FUQUJMRSA6OiBpbnR2ZWMxKDopXFxuICAgIFJFQUwoIERGUCApLCBBTExPQ0FUQUJMRSA6OiByZWFsdmVjMSg6KVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk5vdyBsZXRzIHVzIGFwcGVuZCBhIHNpbmdsZSBFTlRSWSB0byBhIHZlY3RvciBvZiBpbnRlZ2Vycy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIEFwcGVuZChpbnR2ZWMxLCAxKVxcbkNBTEwgT0soIEFMTChpbnR2ZWMxIC5FUS4gWzFdKSwgXFxcIkFwcGVuZCBzaW5nbGUgRU5UUllcXFwiICApXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiQXBwZW5kaW5nIGEgdmVjdG9yIHRvIGEgdmVjdG9yLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgQXBwZW5kKGludHZlYzEsIFsyLDNdKVxcbkNBTEwgT0soIEFMTChpbnR2ZWMxIC5FUS4gWzEsMiwzXSksIFxcXCJBcHBlbmQgYSB2ZWN0b3JcXFwiICApXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiTm93IGxldHMgdXMgYXBwZW5kIGEgc2luZ2xlIHJlYWwgdmFsdWUgdG8gcmVhbHZlYy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIEFwcGVuZChyZWFsdmVjMSwgMS4wX0RGUClcXG5DQUxMIE9LKCBBTEwocmVhbHZlYzEgLkVRLiBbMS4wX0RGUF0pLCBcXFwiQXBwZW5kIHNpbmdsZSBFTlRSWVxcXCIgIClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJBcHBlbmRpbmcgdmVjdG9yIHRvIGEgdmVjdG9yLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgQXBwZW5kKHJlYWx2ZWMxLCBbMi4wX0RGUCwzLjBfREZQXSlcXG5DQUxMIE9LKCBBTEwocmVhbHZlYzEgLkVRLiBbMS4wX0RGUCwyLjBfREZQLDMuMF9ERlBdKSwgXFxcIkFwcGVuZCBhIHZlY3RvclxcXCIgIClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJDbGVhbnVwXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiICAgIERFQUxMT0NBVEUoaW50dmVjMSwgcmVhbHZlYzEpXFxuRU5EIFBST0dSQU0gbWFpblxcblwiXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMgPSB7fSkge1xuICBjb25zdCB7d3JhcHBlcjogTURYTGF5b3V0fSA9IHtcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBNRFhMYXlvdXQgPyBfanN4KE1EWExheW91dCwge1xuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiBfanN4KF9jcmVhdGVNZHhDb250ZW50LCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gIH0pIDogX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpO1xufVxuXG4iLCJcblxuZXhwb3J0IGNvbnN0IGZyb250TWF0dGVyID0ge307XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gdW5kZWZpbmVkO1xuXG5cblxuaW1wb3J0IHtGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7dXNlTURYQ29tcG9uZW50cyBhcyBfcHJvdmlkZUNvbXBvbmVudHN9IGZyb20gXCJAbWR4LWpzL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgdG9jID0gW107XG5mdW5jdGlvbiBfY3JlYXRlTWR4Q29udGVudChwcm9wcykge1xuICBjb25zdCBfY29tcG9uZW50cyA9IHtcbiAgICBjb2RlOiBcImNvZGVcIixcbiAgICBwOiBcInBcIixcbiAgICBwcmU6IFwicHJlXCIsXG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQUk9HUkFNIG1haW5cXG4gICAgVVNFIGVhc2lmZW1CYXNlXFxuICAgIElNUExJQ0lUIE5PTkVcXG4gICAgSU5URUdFUihJNEIpLCBBTExPQ0FUQUJMRSA6OiBpbnR2ZWMxKDopXFxuICAgIFJFQUwoIERGUCApLCBBTExPQ0FUQUJMRSA6OiByZWFsdmVjMSg6KVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk5vdyBsZXRzIHVzIGFwcGVuZCBhIHNpbmdsZSBFTlRSWSB0byBhIHZlY3RvciBvZiBpbnRlZ2Vycy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJpbnR2ZWMxID0gWzFdIC5hcHBlbmQuIDJcXG5DQUxMIE9LKCBBTEwoaW50dmVjMSAuRVEuIFsxLCAyXSksIFxcXCJBcHBlbmQgc2luZ2xlIEVOVFJZXFxcIiAgKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkFwcGVuZGluZyBhIHZlY3RvciB0byBhIHZlY3Rvci5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJpbnR2ZWMxID0gaW50dmVjMSAuYXBwZW5kLiBbM11cXG5DQUxMIE9LKCBBTEwoaW50dmVjMSAuRVEuIFsxLDIsM10pLCBcXFwiQXBwZW5kIGEgdmVjdG9yXFxcIiAgKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk5vdyBsZXRzIHVzIGFwcGVuZCBhIHNpbmdsZSByZWFsIHZhbHVlIHRvIHJlYWx2ZWMuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwicmVhbHZlYzEgPSBbMS4wX0RGUF0gLmFwcGVuZC4gMi4wX0RGUFxcbkNBTEwgT0soIEFMTChyZWFsdmVjMSAuRVEuIFsxLjBfREZQLCAyLjBfREZQXSksIFxcXCJBcHBlbmQgc2luZ2xlIEVOVFJZXFxcIiAgKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIkFwcGVuZGluZyB2ZWN0b3IgdG8gYSB2ZWN0b3IuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwicmVhbHZlYzEgPSByZWFsdmVjMSAuYXBwZW5kLiBbMy4wX0RGUF1cXG5DQUxMIE9LKCBBTEwocmVhbHZlYzEgLkVRLiBbMS4wX0RGUCwyLjBfREZQLDMuMF9ERlBdKSwgXFxcIkFwcGVuZCBhIHZlY3RvclxcXCIgIClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJDbGVhbnVwXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiICAgIERFQUxMT0NBVEUoaW50dmVjMSwgcmVhbHZlYzEpXFxuRU5EIFBST0dSQU0gbWFpblxcblwiXG4gICAgICB9KVxuICAgIH0pXVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMgPSB7fSkge1xuICBjb25zdCB7d3JhcHBlcjogTURYTGF5b3V0fSA9IHtcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBNRFhMYXlvdXQgPyBfanN4KE1EWExheW91dCwge1xuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiBfanN4KF9jcmVhdGVNZHhDb250ZW50LCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gIH0pIDogX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpO1xufVxuXG4iLCJcblxuZXhwb3J0IGNvbnN0IGZyb250TWF0dGVyID0ge307XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gdW5kZWZpbmVkO1xuXG5cblxuaW1wb3J0IHtGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7dXNlTURYQ29tcG9uZW50cyBhcyBfcHJvdmlkZUNvbXBvbmVudHN9IGZyb20gXCJAbWR4LWpzL3JlYWN0XCI7XG5leHBvcnQgY29uc3QgdG9jID0gW107XG5mdW5jdGlvbiBfY3JlYXRlTWR4Q29udGVudChwcm9wcykge1xuICBjb25zdCBfY29tcG9uZW50cyA9IHtcbiAgICBjb2RlOiBcImNvZGVcIixcbiAgICBwcmU6IFwicHJlXCIsXG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQUk9HUkFNIG1haW5cXG4gICAgVVNFIGVhc2lmZW1CYXNlXFxuICAgIElNUExJQ0lUIE5PTkVcXG4gICAgSU5URUdFUihJNEIpLCBBTExPQ0FUQUJMRSA6OiBDKDopLCBCKDopLCBBKDopXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIG1ldGFzdHJpbmc6IFwidGl0bGU9XFxcIkEgYW5kIEIgYXJlIHZlY3RvcnNcXFwiXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkEgPSBbMV1cXG5CID0gWzJdXFxuQ0FMTCBBcHBlbmQoQywgQSwgQilcXG5DQUxMIE9LKCBBTEwoQyAuRVEuIFsxLCAyXSksIFxcXCJ0ZXN0cygxKTpcXFwiICApXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIG1ldGFzdHJpbmc6IFwidGl0bGU9XFxcIkEgaXMgdmVjdG9yIEIgaXMgc2NhbGFyXFxcIlwiLFxuICAgICAgICBjaGlsZHJlbjogXCJBID0gWzFdXFxuQ0FMTCBBcHBlbmQoQywgQSwgMilcXG5DQUxMIE9LKCBBTEwoQyAuRVEuIFsxLCAyXSksIFxcXCJ0ZXN0cygyKTpcXFwiICApXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkVORCBQUk9HUkFNIG1haW5cXG5cIlxuICAgICAgfSlcbiAgICB9KV1cbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzID0ge30pIHtcbiAgY29uc3Qge3dyYXBwZXI6IE1EWExheW91dH0gPSB7XG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gTURYTGF5b3V0ID8gX2pzeChNRFhMYXlvdXQsIHtcbiAgICAuLi5wcm9wcyxcbiAgICBjaGlsZHJlbjogX2pzeChfY3JlYXRlTWR4Q29udGVudCwge1xuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICB9KSA6IF9jcmVhdGVNZHhDb250ZW50KHByb3BzKTtcbn1cblxuIiwiXG5cbmV4cG9ydCBjb25zdCBmcm9udE1hdHRlciA9IHt9O1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUaXRsZSA9IHVuZGVmaW5lZDtcblxuXG5cbmltcG9ydCB7RnJhZ21lbnQgYXMgX0ZyYWdtZW50LCBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4c30gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQge3VzZU1EWENvbXBvbmVudHMgYXMgX3Byb3ZpZGVDb21wb25lbnRzfSBmcm9tIFwiQG1keC1qcy9yZWFjdFwiO1xuZXhwb3J0IGNvbnN0IHRvYyA9IFtdO1xuZnVuY3Rpb24gX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpIHtcbiAgY29uc3QgX2NvbXBvbmVudHMgPSB7XG4gICAgY29kZTogXCJjb2RlXCIsXG4gICAgcDogXCJwXCIsXG4gICAgcHJlOiBcInByZVwiLFxuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIF9qc3hzKF9GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFJPR1JBTSBtYWluXFxuICAgIFVTRSBlYXNpZmVtQmFzZVxcbiAgICBJTVBMSUNJVCBOT05FXFxuICAgIElOVEVHRVIoSTRCKSwgQUxMT0NBVEFCTEUgOjogaW50dmVjMSg6KVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIk5vdyBsZXRzIHVzIGFwcGVuZCBhIHNpbmdsZSBFTlRSWSB0byBhIHZlY3Rvci5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJDQUxMIEFwcGVuZChpbnR2ZWMxLCAxLCBtYXNrPS50cnVlLilcXG5DQUxMIEFwcGVuZChpbnR2ZWMxLCAxLCBtYXNrPS5mYWxzZS4pXFxuQ0FMTCBPSyggQUxMKGludHZlYzEgLkVRLiBbMV0pLCBcXFwiQXBwZW5kIHNpbmdsZSBFTlRSWVxcXCIgIClcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJBcHBlbmRpbmcgYSB2ZWN0b3IgdG8gYSB2ZWN0b3IuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBBcHBlbmQoaW50dmVjMSwgWzIsM10sIG1hc2s9Wy50cnVlLiwgLnRydWUuXSlcXG5DQUxMIEFwcGVuZChpbnR2ZWMxLCBbNCw1XSwgbWFzaz1bLnRydWUuLCAuZmFsc2UuXSlcXG5DQUxMIE9LKCBBTEwoaW50dmVjMSAuRVEuIFsxLDIsMyw0XSksIFxcXCJBcHBlbmQgYSB2ZWN0b3JcXFwiICApXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkVORCBQUk9HUkFNIG1haW5cXG5cIlxuICAgICAgfSlcbiAgICB9KV1cbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzID0ge30pIHtcbiAgY29uc3Qge3dyYXBwZXI6IE1EWExheW91dH0gPSB7XG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gTURYTGF5b3V0ID8gX2pzeChNRFhMYXlvdXQsIHtcbiAgICAuLi5wcm9wcyxcbiAgICBjaGlsZHJlbjogX2pzeChfY3JlYXRlTWR4Q29udGVudCwge1xuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICB9KSA6IF9jcmVhdGVNZHhDb250ZW50KHByb3BzKTtcbn1cblxuIiwiXG5cbmV4cG9ydCBjb25zdCBmcm9udE1hdHRlciA9IHt9O1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUaXRsZSA9IHVuZGVmaW5lZDtcblxuXG5cbmltcG9ydCB7RnJhZ21lbnQgYXMgX0ZyYWdtZW50LCBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4c30gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQge3VzZU1EWENvbXBvbmVudHMgYXMgX3Byb3ZpZGVDb21wb25lbnRzfSBmcm9tIFwiQG1keC1qcy9yZWFjdFwiO1xuZXhwb3J0IGNvbnN0IHRvYyA9IFtdO1xuZnVuY3Rpb24gX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpIHtcbiAgY29uc3QgX2NvbXBvbmVudHMgPSB7XG4gICAgY29kZTogXCJjb2RlXCIsXG4gICAgcHJlOiBcInByZVwiLFxuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIF9qc3hzKF9GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFJPR1JBTSBtYWluXFxuICAgIFVTRSBlYXNpZmVtQmFzZVxcbiAgICBJTVBMSUNJVCBOT05FXFxuICAgIElOVEVHRVIoSTRCKSwgQUxMT0NBVEFCTEUgOjogQyg6KSwgQig6KSwgQSg6KVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBtZXRhc3RyaW5nOiBcInRpdGxlPVxcXCJBIGFuZCBCIGFyZSB2ZWN0b3JzXFxcIlwiLFxuICAgICAgICBjaGlsZHJlbjogXCIgIEEgPSBbMSwgMl1cXG4gIEIgPSBbMywgNF1cXG4gICEhXFxuICAhISBBcHBlbmQgQigxKSBhbmQgQigyKSB0byBBIGFuZCBhc3NpZ24gdG8gQy5cXG4gICEhXFxuICBDQUxMIEFwcGVuZChDLCBBLCBCLCBtYXNrPVsudHJ1ZS4sIC50cnVlLl0pIFxcbiAgQ0FMTCBPSyggQUxMKEMgLkVRLiBbMSwgMiwgMywgNF0pLCBcXFwiQXBwZW5kOlxcXCIgIClcXG5cXG4gICEhXFxuICAhISBBcHBlbmQgQigxKSB0byBBIGFuZCBhc3NpZ24gdG8gQy5cXG4gICEhXFxuICBDQUxMIEFwcGVuZChDLCBBLCBCLCBtYXNrPVsudHJ1ZS4sIC5mYWxzZS5dKSBcXG4gIENBTEwgT0soIEFMTChDIC5FUS4gWzEsIDIsIDNdKSwgXFxcIkFwcGVuZDpcXFwiICApXFxuXFxuXFxuICAhIVxcbiAgISEgRG8gbm90IGFwcGVuZCBCIHRvIEEsIGp1c3QgYXNzaWduIEEgdG8gQy5cXG4gICEhXFxuICBDQUxMIEFwcGVuZChDLCBBLCBCLCBtYXNrPVsuZmFsc2UuLCAuZmFsc2UuXSkgXFxuICBDQUxMIE9LKCBBTEwoQyAuRVEuIFsxLCAyXSksIFxcXCJBcHBlbmQ6XFxcIiApXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIG1ldGFzdHJpbmc6IFwidGl0bGU9XFxcIkEgaXMgdmVjdG9yIEIgaXMgc2NhbGFyXFxcIlwiLFxuICAgICAgICBjaGlsZHJlbjogXCIgICEhXFxuICAhISBBcHBlbmQgMyB0byBBIGFuZCB0aGVuIGFzc2lnbiByZXN1bHQgdG8gQ1xcbiAgISFcXG4gIENBTEwgQXBwZW5kKEMsIEEsIDMsIG1hc2s9LnRydWUuKVxcbiAgQ0FMTCBPSyggQUxMKEMgLkVRLiBbMSwgMiwgM10pLCBcXFwiQXBwZW5kOlxcXCIgIClcXG5cXG4gICEhXFxuICAhISBEbyBub3QgYXBwZW5kIDMgdG8gQSwgYXNzaWduIHJlc3VsdCB0byBDLCB0aGF0IGlzIEMgPUFcXG4gICEhXFxuICBDQUxMIEFwcGVuZChDLCBBLCAzLCBtYXNrPS5mYWxzZS4pXFxuICBDQUxMIE9LKCBBTEwoQyAuRVEuIFsxLCAyXSksIFxcXCJBcHBlbmQ6XFxcIiAgKVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJFTkQgUFJPR1JBTSBtYWluXFxuXCJcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTURYQ29udGVudChwcm9wcyA9IHt9KSB7XG4gIGNvbnN0IHt3cmFwcGVyOiBNRFhMYXlvdXR9ID0ge1xuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIE1EWExheW91dCA/IF9qc3goTURYTGF5b3V0LCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IF9qc3goX2NyZWF0ZU1keENvbnRlbnQsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSlcbiAgfSkgOiBfY3JlYXRlTWR4Q29udGVudChwcm9wcyk7XG59XG5cbiIsIlxuXG5leHBvcnQgY29uc3QgZnJvbnRNYXR0ZXIgPSB7fTtcbmV4cG9ydCBjb25zdCBjb250ZW50VGl0bGUgPSAnQXBwZW5kJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZXRhZGF0YX0gZnJvbSAnQHNpdGUvLmRvY3VzYXVydXMvZG9jdXNhdXJ1cy1wbHVnaW4tY29udGVudC1kb2NzL2RvY3MtYXBpL3NpdGUtZG9jcy1kb2NzLWFwaS1hcHBlbmQtdXRpbGl0eS1hcHBlbmQtbWQtNDkxLmpzb24nXG5leHBvcnQgY29uc3QgYXNzZXRzID0ge1xuXG59O1xuXG5pbXBvcnQge0ZyYWdtZW50IGFzIF9GcmFnbWVudCwganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHN9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHt1c2VNRFhDb21wb25lbnRzIGFzIF9wcm92aWRlQ29tcG9uZW50c30gZnJvbSBcIkBtZHgtanMvcmVhY3RcIjtcbmltcG9ydCBUYWJzIGZyb20gJ0B0aGVtZS9UYWJzJztcbmltcG9ydCBUYWJJdGVtIGZyb20gJ0B0aGVtZS9UYWJJdGVtJztcbmltcG9ydCBFWEFNUExFNjIsIHt0b2MgYXMgX190b2NFWEFNUExFNjJ9IGZyb20gXCIuL2V4YW1wbGVzL19BcHBlbmRfdGVzdF8xLm1kXCI7XG5pbXBvcnQgRVhBTVBMRTY0LCB7dG9jIGFzIF9fdG9jRVhBTVBMRTY0fSBmcm9tIFwiLi9leGFtcGxlcy9fQXBwZW5kX3Rlc3RfMi5tZFwiO1xuaW1wb3J0IEVYQU1QTEUxMDQsIHt0b2MgYXMgX190b2NFWEFNUExFMTA0fSBmcm9tIFwiLi9leGFtcGxlcy9fQXBwZW5kX3Rlc3RfMy5tZFwiO1xuaW1wb3J0IEVYQU1QTEUxNDksIHt0b2MgYXMgX190b2NFWEFNUExFMTQ5fSBmcm9tIFwiLi9leGFtcGxlcy9fQXBwZW5kX3Rlc3RfNC5tZFwiO1xuaW1wb3J0IEVYQU1QTEUxOTMsIHt0b2MgYXMgX190b2NFWEFNUExFMTkzfSBmcm9tIFwiLi9leGFtcGxlcy9fQXBwZW5kX3Rlc3RfNS5tZFwiO1xuZXhwb3J0IGNvbnN0IHRvYyA9IFt7XG4gIFwidmFsdWVcIjogXCJJbnRlcmZhY2UgMVwiLFxuICBcImlkXCI6IFwiaW50ZXJmYWNlLTFcIixcbiAgXCJsZXZlbFwiOiAyXG59LCAuLi5fX3RvY0VYQU1QTEU2MiwgLi4uX190b2NFWEFNUExFNjQsIHtcbiAgXCJ2YWx1ZVwiOiBcIkludGVyZmFjZSAyXCIsXG4gIFwiaWRcIjogXCJpbnRlcmZhY2UtMlwiLFxuICBcImxldmVsXCI6IDJcbn0sIC4uLl9fdG9jRVhBTVBMRTEwNCwge1xuICBcInZhbHVlXCI6IFwiSW50ZXJmYWNlIDNcIixcbiAgXCJpZFwiOiBcImludGVyZmFjZS0zXCIsXG4gIFwibGV2ZWxcIjogMlxufSwgLi4uX190b2NFWEFNUExFMTQ5LCB7XG4gIFwidmFsdWVcIjogXCJJbnRlcmZhY2UgNFwiLFxuICBcImlkXCI6IFwiaW50ZXJmYWNlLTRcIixcbiAgXCJsZXZlbFwiOiAyXG59LCAuLi5fX3RvY0VYQU1QTEUxOTNdO1xuZnVuY3Rpb24gX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpIHtcbiAgY29uc3QgX2NvbXBvbmVudHMgPSB7XG4gICAgYWRtb25pdGlvbjogXCJhZG1vbml0aW9uXCIsXG4gICAgY29kZTogXCJjb2RlXCIsXG4gICAgaDE6IFwiaDFcIixcbiAgICBoMjogXCJoMlwiLFxuICAgIGhlYWRlcjogXCJoZWFkZXJcIixcbiAgICBsaTogXCJsaVwiLFxuICAgIHA6IFwicFwiLFxuICAgIHByZTogXCJwcmVcIixcbiAgICB1bDogXCJ1bFwiLFxuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIF9qc3hzKF9GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5oZWFkZXIsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmgxLCB7XG4gICAgICAgIGlkOiBcImFwcGVuZFwiLFxuICAgICAgICBjaGlsZHJlbjogXCJBcHBlbmRcIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJBcHBlbmQgaXMgYSBnZW5lcmljIHN1YnJvdXRpbmUgdG8gYXBwZW5kIGVudHJpZXMgdG8gdmVjdG9yIG9mIHJlYWwgb3IgaW50ZWdlci5cIlxuICAgIH0pLCBcIlxcblwiLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmFkbW9uaXRpb24sIHtcbiAgICAgIHR5cGU6IFwibm90ZVwiLFxuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgICBjaGlsZHJlbjogXCJXaGlsZSBjYWxsaW5nIEFwcGVuZCB0aGUgaW5pdGlhbCB2ZWN0b3IgY2FuIGJlIHVuYWxsb2NhdGVkIGluIHRoZSBiZWdpbmluZy5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJDYWxsaW5nIGV4YW1wbGVzOlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgQXBwZW5kKEEsIGVudHJ5KVxcbkNBTEwgQXBwZW5kKEMsIEEsIEIpXFxuQ0FMTCBBcHBlbmQoQSwgZW50cnksIG1hc2spXFxuQ0FMTCBBcHBlbmQoQywgQSwgQiwgbWFzaylcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiaW50ZXJmYWNlLTFcIixcbiAgICAgIGNoaWxkcmVuOiBcIkludGVyZmFjZSAxXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoVGFicywge1xuICAgICAgY2hpbGRyZW46IFtfanN4cyhUYWJJdGVtLCB7XG4gICAgICAgIHZhbHVlOiBcImFwcGVuZFwiLFxuICAgICAgICBsYWJlbDogXCJBcHBlbmQgKDEpXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBBcHBlbmQoQSwgZW50cnkpXFxuXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KSwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiSGVyZSxcIlxuICAgICAgICB9KSwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICAgIH0pLCBcIiBjYW4gYmUgYW4gYWxsb2NhdGFibGUgdmVjdG9yIG9mIHJlYWwgb3IgaW50ZWdlci5cIl1cbiAgICAgICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcImVudHJ5XCJcbiAgICAgICAgICAgIH0pLCBcIiBjYW4gYmUgYSBzY2FsYXIgb2YgcmVhbCBvciBpbnRlZ2VyLlwiXVxuICAgICAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiZW50cnlcIlxuICAgICAgICAgICAgfSksIFwiIGNhbiBiZSBhIHZlY3RvciBvZiByZWFsIG9yIGludGVnZXIuXCJdXG4gICAgICAgICAgfSksIFwiXFxuXCJdXG4gICAgICAgIH0pLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJXZSBjYW46XCJcbiAgICAgICAgfSksIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBcHBlbmQgYSBzY2FsYXItaW50ZWdlciB0byBhbiBpbnRlZ2VyLXZlY3RvclwiXG4gICAgICAgICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIkFwcGVuZCBhbiBpbnRlZ2VyLXZlY3RvciBhbmQgc2NhbGFyIHRvIGFuIGludGVnZXItdmVjdG9yXCJcbiAgICAgICAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwiQXBwZW5kIGEgc2NhbGFyLXJlYWwgdG8gYSByZWFsLXZlY3RvclwiXG4gICAgICAgICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIkFwcGVuZCBhIHJlYWwtdmVjdG9yIHRvIGEgcmVhbC12ZWN0b3JcIlxuICAgICAgICAgIH0pLCBcIlxcblwiXVxuICAgICAgICB9KSwgX2pzeHMoX2NvbXBvbmVudHMuYWRtb25pdGlvbiwge1xuICAgICAgICAgIHR5cGU6IFwibm90ZVwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJXZSBjYW4gYWxzbyB1c2UgdGhpcyBtZXRob2QgYXM6XCJcbiAgICAgICAgICB9KSwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQSA9IEEgLmFwcGVuZC4gZW50cnlcXG5cIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSldXG4gICAgICB9KSwgX2pzeChUYWJJdGVtLCB7XG4gICAgICAgIHZhbHVlOiBcImV4YW1wbGVcIixcbiAgICAgICAgbGFiZWw6IFwiRXhhbXBsZSAxXCIsXG4gICAgICAgIGNoaWxkcmVuOiBfanN4KEVYQU1QTEU2Miwge30pXG4gICAgICB9KSwgX2pzeChUYWJJdGVtLCB7XG4gICAgICAgIHZhbHVlOiBcImV4YW1wbGUyXCIsXG4gICAgICAgIGxhYmVsOiBcIkV4YW1wbGUgMlwiLFxuICAgICAgICBjaGlsZHJlbjogX2pzeChFWEFNUExFNjQsIHt9KVxuICAgICAgfSksIF9qc3goVGFiSXRlbSwge1xuICAgICAgICB2YWx1ZTogXCJjbG9zZVwiLFxuICAgICAgICBsYWJlbDogXCLihqIgXCJcbiAgICAgIH0pXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJpbnRlcmZhY2UtMlwiLFxuICAgICAgY2hpbGRyZW46IFwiSW50ZXJmYWNlIDJcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhUYWJzLCB7XG4gICAgICBjaGlsZHJlbjogW19qc3hzKFRhYkl0ZW0sIHtcbiAgICAgICAgdmFsdWU6IFwiYXBwZW5kXCIsXG4gICAgICAgIGxhYmVsOiBcIkFwcGVuZCAoMilcIixcbiAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJDQUxMIEFwcGVuZChDLCBBLCBCKVxcblwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIndoZXJlLFwiXG4gICAgICAgIH0pLCBfanN4cyhfY29tcG9uZW50cy51bCwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXCJBcHBlbmQgQSBhbmQgQiwgdGhlbiBhc3NpZ24gaXQgdG8gXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJDXCJcbiAgICAgICAgICAgIH0pXVxuICAgICAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ1wiXG4gICAgICAgICAgICB9KSwgXCIgY2FuIGJlIGFuIGFsbG9jYXRhYmxlIHZlY3RvciBvZiByZWFsIG9yIGludGVnZXJcIl1cbiAgICAgICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkFcIlxuICAgICAgICAgICAgfSksIFwiIGNhbiBiZSBhIHZlY3RvciBvZiByZWFsIG9yIGludGVnZXJcIl1cbiAgICAgICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkJcIlxuICAgICAgICAgICAgfSksIFwiIGNhbiBiZSBhIHNjYWxhciBvZiByZWFsIG9yIGludGVnZXJcIl1cbiAgICAgICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkJcIlxuICAgICAgICAgICAgfSksIFwiIGNhbiBiZSBhIHZlY3RvciBvZiByZWFsIG9yIGludGVnZXJcIl1cbiAgICAgICAgICB9KSwgXCJcXG5cIl1cbiAgICAgICAgfSksIF9qc3goX2NvbXBvbmVudHMuYWRtb25pdGlvbiwge1xuICAgICAgICAgIHR5cGU6IFwibm90ZVwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW1wiQ3VycmVudGx5LCBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkFcIlxuICAgICAgICAgICAgfSksIFwiIGNhbm5vdCBiZSBzY2FsYXIgaW4gdGhlIGFib3ZlIGludGVyZmFjZS5cIl1cbiAgICAgICAgICB9KVxuICAgICAgICB9KSwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiV2UgY2FuOlwiXG4gICAgICAgIH0pLCBfanN4cyhfY29tcG9uZW50cy51bCwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwiQXBwZW5kIGEgc2NhbGFyIGFuZCBhIHZlY3RvciBvZiBpbnQgdG8gYW5vdGhlciB2ZWN0b3Igb2YgaW50XCJcbiAgICAgICAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwiQXBwZW5kIHR3byB2ZWN0b3JzIG9mIGludCB0byBhbm90aGVyIHZlY3RvciBvZiBpbnRcIlxuICAgICAgICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJBcHBlbmQgYSBzY2FsYXIgYW5kIGEgdmVjdG9yIG9mIHJlYWwgdG8gYW5vdGhlciB2ZWN0b3Igb2YgcmVhbFwiXG4gICAgICAgICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIkFwcGVuZCB0d28gdmVjdG9ycyBvZiByZWFsIHRvIGFub3RoZXIgdmVjdG9yIG9mIHJlYWxcIlxuICAgICAgICAgIH0pLCBcIlxcblwiXVxuICAgICAgICB9KV1cbiAgICAgIH0pLCBfanN4KFRhYkl0ZW0sIHtcbiAgICAgICAgdmFsdWU6IFwiZXhhbXBsZVwiLFxuICAgICAgICBsYWJlbDogXCJTZWUgZXhhbXBsZVwiLFxuICAgICAgICBjaGlsZHJlbjogX2pzeChFWEFNUExFMTA0LCB7fSlcbiAgICAgIH0pLCBfanN4KFRhYkl0ZW0sIHtcbiAgICAgICAgdmFsdWU6IFwiY2xvc2VcIixcbiAgICAgICAgbGFiZWw6IFwi4oaiIFwiXG4gICAgICB9KV1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiaW50ZXJmYWNlLTNcIixcbiAgICAgIGNoaWxkcmVuOiBcIkludGVyZmFjZSAzXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoVGFicywge1xuICAgICAgY2hpbGRyZW46IFtfanN4cyhUYWJJdGVtLCB7XG4gICAgICAgIHZhbHVlOiBcImFwcGVuZFwiLFxuICAgICAgICBsYWJlbDogXCJBcHBlbmQgKDMpXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiQ0FMTCBBcHBlbmQoQSwgZW50cnksIG1hc2spXFxuXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KSwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiaGVyZSxcIlxuICAgICAgICB9KSwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICAgIH0pLCBcIiBpcyBhbiBhbGxvY2F0YWJsZSB2ZWN0b3Igb2YgcmVhbCBvciBpbnRlZ2VyLlwiXVxuICAgICAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiZW50cnlcIlxuICAgICAgICAgICAgfSksIFwiIGNhbiBiZSBhIHNjYWxhciBvZiByZWFsIG9yIGludGVnZXIuIEluIHRoaXMgY2FzZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIm1hc2tcIlxuICAgICAgICAgICAgfSksIFwiIGlzIGEgc2NhbGFyIG9mIGxvZ2ljYWwgdHlwZVwiXVxuICAgICAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiZW50cnlcIlxuICAgICAgICAgICAgfSksIFwiIGNhbiBiZSBhIHZlY3RvciBvZiByZWFsIG9yIGludGVnZXIuIEluIHRoaXMgY2FzZSwgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJtYXNrXCJcbiAgICAgICAgICAgIH0pLCBcIiB3aWxsIGJlIGEgdmVjdG9yIG9mIGxvZ2ljYWwgdHlwZXMuXCJdXG4gICAgICAgICAgfSksIFwiXFxuXCJdXG4gICAgICAgIH0pLCBfanN4KF9jb21wb25lbnRzLmFkbW9uaXRpb24sIHtcbiAgICAgICAgICB0eXBlOiBcIm5vdGVcIixcbiAgICAgICAgICBjaGlsZHJlbjogX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcIlRoZSBzaXplIG9mIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwibWFza1wiXG4gICAgICAgICAgICB9KSwgXCIgc2hvdWxkIGJlIHNhbWUgYXMgdGhlIHNpemUgb2YgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJlbnRyeVwiXG4gICAgICAgICAgICB9KSwgXCIuXCJdXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIldlIGNhbjpcIlxuICAgICAgICB9KSwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIk1hc2tlZCBhcHBlbmQgYSBzY2FsYXIgaW50ZWdlciB0byBhIHZlY3RvciBvZiBpbnRcIlxuICAgICAgICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJNYXNrZWQgYXBwZW5kIGEgc2NhbGFyIHJlYWwgdG8gYSB2ZWN0b3Igb2YgcmVhbHNcIlxuICAgICAgICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJNYXNrZWQgYXBwZW5kIGEgdmVjdG9yIG9mIGludGVnZXIgdG8gYSB2ZWN0b3Igb2YgaW50ZWdlclwiXG4gICAgICAgICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIk1hc2tlZCBhcHBlbmQgYSB2ZWN0b3Igb2YgcmVhbCB0byBhIHZlY3RvciBvZiByZWFsXCJcbiAgICAgICAgICB9KSwgXCJcXG5cIl1cbiAgICAgICAgfSldXG4gICAgICB9KSwgX2pzeChUYWJJdGVtLCB7XG4gICAgICAgIHZhbHVlOiBcImV4YW1wbGVcIixcbiAgICAgICAgbGFiZWw6IFwiU2VlIGV4YW1wbGVcIixcbiAgICAgICAgY2hpbGRyZW46IF9qc3goRVhBTVBMRTE0OSwge30pXG4gICAgICB9KSwgX2pzeChUYWJJdGVtLCB7XG4gICAgICAgIHZhbHVlOiBcImNsb3NlXCIsXG4gICAgICAgIGxhYmVsOiBcIuKGoiBcIlxuICAgICAgfSldXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImludGVyZmFjZS00XCIsXG4gICAgICBjaGlsZHJlbjogXCJJbnRlcmZhY2UgNFwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKFRhYnMsIHtcbiAgICAgIGNoaWxkcmVuOiBbX2pzeHMoVGFiSXRlbSwge1xuICAgICAgICB2YWx1ZTogXCJhcHBlbmRcIixcbiAgICAgICAgbGFiZWw6IFwiQXBwZW5kICg0KVwiLFxuICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIkNBTEwgQXBwZW5kKEMsIEEsIEIsIG1hc2spXFxuXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KSwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwid2hlcmUsXCJcbiAgICAgICAgfSksIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ1wiXG4gICAgICAgICAgICB9KSwgXCIgaXMgYW4gYWxsb2NhdGFibGUgdmVjdG9yIG9mIHJlYWwgb3IgaW50ZWdlclwiXVxuICAgICAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQVwiXG4gICAgICAgICAgICB9KSwgXCIgaXMgYSB2ZWN0b3Igb2YgcmVhbCBvciBpbnRlZ2VyXCJdXG4gICAgICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJCXCJcbiAgICAgICAgICAgIH0pLCBcIiBpcyBhIHZlY3RvciBvZiByZWFsIG9yIGludGVnZXJcIl1cbiAgICAgICAgICB9KSwgXCJcXG5cIl1cbiAgICAgICAgfSksIF9qc3goX2NvbXBvbmVudHMuYWRtb25pdGlvbiwge1xuICAgICAgICAgIHR5cGU6IFwibm90ZVwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW1wiQ3VycmVudGx5LCB3ZSBkbyBub3QgYWxsb3cgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICAgICAgICAgIH0pLCBcIiB0byBiZSBhIHNjYWxhciBpbiB0aGUgYWJvdmUgY2FsbC5cIl1cbiAgICAgICAgICB9KVxuICAgICAgICB9KSwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiV2UgY2FuOlwiXG4gICAgICAgIH0pLCBfanN4cyhfY29tcG9uZW50cy51bCwge1xuICAgICAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwiTWFza2VkIGFwcGVuZCBhIHNjYWxhciBhbmQgdmVjdG9yIG9mIGludCB0byBhbm90aGVyIHZlY3RvciBvZiBpbnRcIlxuICAgICAgICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJNYXNrZWQgYXBwZW5kIGEgc2NhbGFyIGFuZCB2ZWN0b3IgcmVhbCB0byBhbm90aGVyIHZlY3RvciBvZiByZWFsXCJcbiAgICAgICAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFwiTWFza2VkIGFwcGVuZCB0d28gdmVjdG9ycyBvZiBpbnRlZ2VyIHRvIGFub3RoZXIgdmVjdG9yIG9mIGludGVnZXJcIlxuICAgICAgICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJNYXNrZWQgYXBwZW5kIHR3byB2ZWN0b3JzIG9mIHJlYWwgdG8gYW5vdGhlciB2ZWN0b3Igb2YgcmVhbFwiXG4gICAgICAgICAgfSksIFwiXFxuXCJdXG4gICAgICAgIH0pXVxuICAgICAgfSksIF9qc3goVGFiSXRlbSwge1xuICAgICAgICB2YWx1ZTogXCJleGFtcGxlXCIsXG4gICAgICAgIGxhYmVsOiBcIlNlZSBleGFtcGxlXCIsXG4gICAgICAgIGNoaWxkcmVuOiBfanN4KEVYQU1QTEUxOTMsIHt9KVxuICAgICAgfSksIF9qc3goVGFiSXRlbSwge1xuICAgICAgICB2YWx1ZTogXCJjbG9zZVwiLFxuICAgICAgICBsYWJlbDogXCLihqIgXCJcbiAgICAgIH0pXVxuICAgIH0pXVxuICB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMgPSB7fSkge1xuICBjb25zdCB7d3JhcHBlcjogTURYTGF5b3V0fSA9IHtcbiAgICAuLi5fcHJvdmlkZUNvbXBvbmVudHMoKSxcbiAgICAuLi5wcm9wcy5jb21wb25lbnRzXG4gIH07XG4gIHJldHVybiBNRFhMYXlvdXQgPyBfanN4KE1EWExheW91dCwge1xuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiBfanN4KF9jcmVhdGVNZHhDb250ZW50LCB7XG4gICAgICAuLi5wcm9wc1xuICAgIH0pXG4gIH0pIDogX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./docs/docs-api/AppendUtility/Append.md\n");

/***/ })

}]);