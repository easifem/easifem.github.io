"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkeasifem_docs"] = globalThis["webpackChunkeasifem_docs"] || []).push([["content---docs-api-abstract-mesh-elem-data-ad-0-2c4"],{

/***/ "./docs/docs-api/AbstractMesh/ElemData_.md":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  assets: () => (/* binding */ assets),\n  contentTitle: () => (/* binding */ contentTitle),\n  \"default\": () => (/* binding */ MDXContent),\n  frontMatter: () => (/* binding */ frontMatter),\n  metadata: () => (/* reexport */ site_docs_docs_api_abstract_mesh_elem_data_md_ad0_namespaceObject),\n  toc: () => (/* binding */ toc)\n});\n\n;// ./.docusaurus/docusaurus-plugin-content-docs/docs-api/site-docs-docs-api-abstract-mesh-elem-data-md-ad0.json\nconst site_docs_docs_api_abstract_mesh_elem_data_md_ad0_namespaceObject = /*#__PURE__*/JSON.parse('{\"id\":\"AbstractMesh/ElemData_\",\"title\":\"ElemData\",\"description\":\"It is a data type for storing the element-data information.\",\"source\":\"@site/docs/docs-api/AbstractMesh/ElemData_.md\",\"sourceDirName\":\"AbstractMesh\",\"slug\":\"/AbstractMesh/ElemData_\",\"permalink\":\"/docs-api/AbstractMesh/ElemData_\",\"draft\":false,\"unlisted\":false,\"editUrl\":\"https://github.com/easifem/easifem.github.io/tree/main/docs/docs-api/AbstractMesh/ElemData_.md\",\"tags\":[],\"version\":\"current\",\"lastUpdatedAt\":1539502055000,\"sidebarPosition\":3,\"frontMatter\":{\"sidebar_position\":3},\"sidebar\":\"tutorialSidebar\",\"previous\":{\"title\":\"Structure\",\"permalink\":\"/docs-api/AbstractMesh/AbstractMesh_\"},\"next\":{\"title\":\"NodeData\",\"permalink\":\"/docs-api/AbstractMesh/NodeData_\"}}');\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(\"./node_modules/react/jsx-runtime.js\");\n// EXTERNAL MODULE: ./node_modules/@mdx-js/react/lib/index.js\nvar lib = __webpack_require__(\"./node_modules/@mdx-js/react/lib/index.js\");\n;// ./docs/docs-api/AbstractMesh/ElemData_.md\n\n\nconst frontMatter = {\n\tsidebar_position: 3\n};\nconst contentTitle = 'ElemData';\n\nconst assets = {\n\n};\n\n\n\nconst toc = [{\n  \"value\": \"Structure\",\n  \"id\": \"structure\",\n  \"level\": 2\n}, {\n  \"value\": \"<code>isActive</code>\",\n  \"id\": \"isactive\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>globalElements</code>\",\n  \"id\": \"globalelements\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>localElemNum</code>\",\n  \"id\": \"localelemnum\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>elementType</code>\",\n  \"id\": \"elementtype\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>name</code>\",\n  \"id\": \"name\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>meshID</code>\",\n  \"id\": \"meshid\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>material</code>\",\n  \"id\": \"material\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>globalNodes</code>\",\n  \"id\": \"globalnodes\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>globalEdges</code> and <code>edgeOrient</code>\",\n  \"id\": \"globaledges-and-edgeorient\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>globalFaces</code> and <code>faceOrient</code>\",\n  \"id\": \"globalfaces-and-faceorient\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>globalElements</code>\",\n  \"id\": \"globalelements-1\",\n  \"level\": 3\n}, {\n  \"value\": \"<code>boundaryData</code>\",\n  \"id\": \"boundarydata\",\n  \"level\": 3\n}, {\n  \"value\": \"ElemdataType\",\n  \"id\": \"elemdatatype\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_Copy\",\n  \"id\": \"elemdata_copy\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_Display\",\n  \"id\": \"elemdata_display\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_ElemType2String\",\n  \"id\": \"elemdata_elemtype2string\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_Deallocate\",\n  \"id\": \"elemdata_deallocate\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_SetTotalMaterial\",\n  \"id\": \"elemdata_settotalmaterial\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_Set\",\n  \"id\": \"elemdata_set\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_Pointer\",\n  \"id\": \"elemdata_pointer\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_lt\",\n  \"id\": \"elemdata_lt\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_eq\",\n  \"id\": \"elemdata_eq\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_SetID\",\n  \"id\": \"elemdata_setid\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetGlobalFaceCon\",\n  \"id\": \"elemdata_getglobalfacecon\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetConnectivity\",\n  \"id\": \"elemdata_getconnectivity\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetConnectivity2\",\n  \"id\": \"elemdata_getconnectivity2\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalEntities\",\n  \"id\": \"elemdata_gettotalentities\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetVertex\",\n  \"id\": \"elemdata_getvertex\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetEdge\",\n  \"id\": \"elemdata_getedge\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetFace\",\n  \"id\": \"elemdata_getface\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetCell\",\n  \"id\": \"elemdata_getcell\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalEdgeDOF\",\n  \"id\": \"elemdata_gettotaledgedof\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalFaceDOF\",\n  \"id\": \"elemdata_gettotalfacedof\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalCellDOF\",\n  \"id\": \"elemdata_gettotalcelldof\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetElementToElements1\",\n  \"id\": \"elemdata_getelementtoelements1\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetElementToElements2\",\n  \"id\": \"elemdata_getelementtoelements2\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetEdgeConnectivity\",\n  \"id\": \"elemdata_getedgeconnectivity\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_isActive\",\n  \"id\": \"elemdata_isactive\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_globalElemNum\",\n  \"id\": \"elemdata_globalelemnum\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_localElemNum\",\n  \"id\": \"elemdata_localelemnum\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_name\",\n  \"id\": \"elemdata_name\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_topoName\",\n  \"id\": \"elemdata_toponame\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_topoIndx\",\n  \"id\": \"elemdata_topoindx\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_meshid\",\n  \"id\": \"elemdata_meshid\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalMaterial\",\n  \"id\": \"elemdata_gettotalmaterial\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalGlobalNodes\",\n  \"id\": \"elemdata_gettotalglobalnodes\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalGlobalEdges\",\n  \"id\": \"elemdata_gettotalglobaledges\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalEdgeOrient\",\n  \"id\": \"elemdata_gettotaledgeorient\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalGlobalFaces\",\n  \"id\": \"elemdata_gettotalglobalfaces\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalFaceOrient\",\n  \"id\": \"elemdata_gettotalfaceorient\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalGlobalElements\",\n  \"id\": \"elemdata_gettotalglobalelements\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetTotalBoundaryData\",\n  \"id\": \"elemdata_gettotalboundarydata\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetMaterial\",\n  \"id\": \"elemdata_getmaterial\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetGlobalNodes\",\n  \"id\": \"elemdata_getglobalnodes\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetGlobalEdges\",\n  \"id\": \"elemdata_getglobaledges\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetGlobalFaces\",\n  \"id\": \"elemdata_getglobalfaces\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetGlobalFaceNumber\",\n  \"id\": \"elemdata_getglobalfacenumber\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetGlobalEdgeNumber\",\n  \"id\": \"elemdata_getglobaledgenumber\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetGlobalElements\",\n  \"id\": \"elemdata_getglobalelements\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetBoundaryData\",\n  \"id\": \"elemdata_getboundarydata\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetGlobalNodesPointer\",\n  \"id\": \"elemdata_getglobalnodespointer\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetEdgeOrient\",\n  \"id\": \"elemdata_getedgeorient\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetFaceOrient\",\n  \"id\": \"elemdata_getfaceorient\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_GetOrientation\",\n  \"id\": \"elemdata_getorientation\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_FindFace\",\n  \"id\": \"elemdata_findface\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_FindEdge\",\n  \"id\": \"elemdata_findedge\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_IsBoundaryElement\",\n  \"id\": \"elemdata_isboundaryelement\",\n  \"level\": 2\n}, {\n  \"value\": \"Elemdata_Order\",\n  \"id\": \"elemdata_order\",\n  \"level\": 2\n}];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    admonition: \"admonition\",\n    annotation: \"annotation\",\n    code: \"code\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    header: \"header\",\n    li: \"li\",\n    math: \"math\",\n    mo: \"mo\",\n    mrow: \"mrow\",\n    p: \"p\",\n    pre: \"pre\",\n    semantics: \"semantics\",\n    span: \"span\",\n    ul: \"ul\",\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {\n    children: [(0,jsx_runtime.jsx)(_components.header, {\n      children: (0,jsx_runtime.jsx)(_components.h1, {\n        id: \"elemdata\",\n        children: \"ElemData\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"It is a data type for storing the element-data information.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"structure\",\n      children: \"Structure\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE :: ElemData_\\n  LOGICAL(LGT) :: isActive = .TRUE.\\n    !! Is element in active stage\\n  INTEGER(I4B) :: globalElemNum = 0_I4B\\n    !! global element number\\n    !! cell connectivity number\\n  INTEGER(I4B) :: localElemNum = 0_I4B\\n    !! local element number\\n  INTEGER(I4B) :: elementType = INTERNAL_ELEMENT\\n    !! BOUNDARY_ELEMENT: If the element contqains the boundary node\\n    !! it will be called the boundary element\\n    !! INTERNAL_ELEMENT: If the element does not contain the boundary node\\n    !! then it will be called the internal element\\n  INTEGER(I4B) :: name = 0\\n    !! This is name of the element\\n    !! It can be Triangle, Triangle3, Triangle6, etc.\\n    !! Quadrangle,\\n  INTEGER(I4B) :: meshID = 0\\n    !! ID of mesh to which the element belong\\n    !! This is a gmsh concept\\n  INTEGER(INT8), ALLOCATABLE :: material(:)\\n    !! materials mapped to the mesh\\n    !! material(1) is the material-id (type of material) of medium 1\\n    !! material(2) is the material-id (type of material) of medium 2\\n    !!\\n    !! ...\\n    !!\\n    !! For example, soil is a porous medium with n = 1,\\n    !! fluid is a medium with n =2\\n    !! then material(1) denotes the type of soil => clay, sand, silt\\n    !! and material(2) denotes the type of fluid => water, oil, air\\n  INTEGER(I4B), ALLOCATABLE :: globalNodes(:)\\n    !! nodes contained in the element, connectivity\\n    !! Vertex connectivity\\n  INTEGER(I4B), ALLOCATABLE :: globalEdges(:)\\n    !! Edge connectivity\\n  INTEGER(INT8), ALLOCATABLE :: edgeOrient(:)\\n    !! Orientation of edge\\n  INTEGER(I4B), ALLOCATABLE :: globalFaces(:)\\n    !! Face connectivity\\n  INTEGER(INT8), ALLOCATABLE :: faceOrient(:, :)\\n    !! Orientation of face\\n  INTEGER(I4B), ALLOCATABLE :: globalElements(:)\\n    !! Contains the information about the element surrounding an element\\n    !! Lets us say that `globalElem1`, `globalElem2`, `globalElem3`\\n    !! surrounds a local element ielem (its global element number is\\n    !! globalElem), then\\n    !! - globalElements( [1,2,3] ) contains globalElem1, pFace, nFace\\n    !! - globalElements( [4,5,6] ) contains globalElem2, pFace, nFace\\n    !! - globalElements( [7,8,9] ) contains globalElem3, pFace, nFace.\\n    !! Here,\\n    !! - pFace is the local facet number of parent element\\n    !! globalElem (ielem) which is connected to the nFace of the neighbor\\n    !! element\\n    !! All element numbers are global element number\\n  INTEGER(I4B), ALLOCATABLE :: boundaryData(:)\\n    !! If `iel` is boundary element, then boudnaryData contains\\n    !! the local facet number of iel which concides with the\\n    !! mesh boundary.\\n    !! If an element contains the boundary node then it is considered\\n    !! as a boundary element.\\n    !! It may happen that a boundary element has no boundary face, in which\\n    !! case boundaryData will have zero size\\nEND TYPE ElemData_\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h3, {\n      id: \"isactive\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"isActive\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"If the element is active or not.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h3, {\n      id: \"globalelements\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalElements\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [(0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalElemNum\"\n      }), \" global element number, this number is given by the mesh generator.\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h3, {\n      id: \"localelemnum\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"localElemNum\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [(0,jsx_runtime.jsx)(_components.code, {\n        children: \"localElemNum\"\n      }), \" local element number, This number is decided internally. It represents the internal storage address.\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h3, {\n      id: \"elementtype\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"elementType\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [(0,jsx_runtime.jsx)(_components.code, {\n        children: \"elementType\"\n      }), \" has following meaning as of 2024-04-14\"]\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"BOUNDARY_ELEMENT\"\n        }), \": If the element contains a facet which coincides with the boundary then, then it will be called the boundary element\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"INTERNAL_ELEMENT\"\n        }), \": Otherwise the element is classified as the internal element.\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h3, {\n      id: \"name\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"name\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Name of the element. You can find more information about this on following pages:\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: (0,jsx_runtime.jsx)(_components.a, {\n          href: \"/docs-api/GlobalData/\",\n          children: \"GlobalData\"\n        })\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: (0,jsx_runtime.jsx)(_components.a, {\n          href: \"../ReferenceElement\",\n          children: \"ReferenceElement\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h3, {\n      id: \"meshid\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"meshID\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"It represent the mesh region. This parameter can be used to assign material properties, boundary conditions, etc to a region of the mesh.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h3, {\n      id: \"material\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"material\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [(0,jsx_runtime.jsx)(_components.code, {\n        children: \"material\"\n      }), \" maps the material to the mesh, for example\"]\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"material(1)\"\n        }), \" is the material-id of medium 1 (here 1 may denote soil)\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"material(2)\"\n        }), \" is the material-id of medium 2 (here, 2 may denote water)\"]\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: (0,jsx_runtime.jsxs)(_components.span, {\n          className: \"katex\",\n          children: [(0,jsx_runtime.jsx)(_components.span, {\n            className: \"katex-mathml\",\n            children: (0,jsx_runtime.jsx)(_components.math, {\n              xmlns: \"http://www.w3.org/1998/Math/MathML\",\n              children: (0,jsx_runtime.jsxs)(_components.semantics, {\n                children: [(0,jsx_runtime.jsx)(_components.mrow, {\n                  children: (0,jsx_runtime.jsx)(_components.mo, {\n                    children: \"⋯\"\n                  })\n                }), (0,jsx_runtime.jsx)(_components.annotation, {\n                  encoding: \"application/x-tex\",\n                  children: \"\\\\cdots\"\n                })]\n              })\n            })\n          }), (0,jsx_runtime.jsx)(_components.span, {\n            className: \"katex-html\",\n            \"aria-hidden\": \"true\",\n            children: (0,jsx_runtime.jsxs)(_components.span, {\n              className: \"base\",\n              children: [(0,jsx_runtime.jsx)(_components.span, {\n                className: \"strut\",\n                style: {\n                  height: \"0.313em\"\n                }\n              }), (0,jsx_runtime.jsx)(_components.span, {\n                className: \"minner\",\n                children: \"⋯\"\n              })]\n            })\n          })]\n        })\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"material(n)\"\n        }), \" is the material-id of medium n\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"For example, soil is a porous medium with material id = 1, fluid is a medium with id=2. Then, material(1) denotes the type of soil, that is, clay, sand, and silt. Also, material(2) denotes the type of fluid, water, oil, air.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [\"The size of \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"material\"\n      }), \" denotes the total number of materials assigned to the element.\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h3, {\n      id: \"globalnodes\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalNodes\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [(0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalNodes\"\n      }), \" nodes contained in the element, i.e., vertex connectivity.\"]\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.h3, {\n      id: \"globaledges-and-edgeorient\",\n      children: [(0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalEdges\"\n      }), \" and \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"edgeOrient\"\n      })]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"edge connectivity and edge orientation.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.h3, {\n      id: \"globalfaces-and-faceorient\",\n      children: [(0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalFaces\"\n      }), \" and \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"faceOrient\"\n      })]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"face connectivity and face orientation.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h3, {\n      id: \"globalelements-1\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalElements\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [(0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalElements\"\n      }), \" contains the information about the elements surrounding an element. This is explained below:\"]\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [\"Let us say that \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalElem1\"\n      }), \", \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalElem2\"\n      }), \", and \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalElem3\"\n      }), \" surround a local element \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"ielem\"\n      }), \" (its global element number is \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalElem\"\n      }), \"), then\"]\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"globalElements( [1,2,3] )\"\n        }), \" contains \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"globalElem1\"\n        }), \", \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"pFace\"\n        }), \", \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"nFace\"\n        })]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"globalElements( [4,5,6] )\"\n        }), \" contains \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"globalElem2\"\n        }), \", \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"pFace\"\n        }), \", \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"nFace\"\n        })]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"globalElements( [7,8,9] )\"\n        }), \" contains \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"globalElem3\"\n        }), \", \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"pFace\"\n        }), \", \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"nFace\"\n        }), \".\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"pFace\"\n        }), \" is the local facet number of parent element\"]\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [(0,jsx_runtime.jsx)(_components.code, {\n          children: \"nFace\"\n        }), \" is the local facet number of the neighbor\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [\"Here, \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"pFace\"\n      }), \" is the local facet number of parent element, (i.e., \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"globalElem (ielem)\"\n      }), \"). The \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"nFace\"\n      }), \" (local-facet-number) of the neighboring element.\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h3, {\n      id: \"boundarydata\",\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        children: \"boundaryData\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"It represents the information about the boundary element. It should be used only when the element is a boundary element.\"\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"If an element \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"iel\"\n        }), \" is a boundary element, then \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"boundaryData\"\n        }), \" contains the local facet numbers of \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"iel\"\n        }), \" which coincides with the mesh boundary. It may happen that a boundary element has no boundary face (but only a single boundary node), in this case \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"boundaryData\"\n        }), \" will have zero size.\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [\"In addition we have defined \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"ElemdataPointer_\"\n      }), \" which is a pointer to \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"Elemdata_\"\n      }), \" type. The pointer is defined as follows:\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE ElemdataPointer_\\n  CLASS(Elemdata_), POINTER :: ptr => NULL()\\nEND TYPE ElemdataPointer_\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdatatype\",\n      children: \"ElemdataType\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.p, {\n      children: [\"The \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"ElemdataType_\"\n      }), \" is a derived type which contains the information about the element data. The structure of the \", (0,jsx_runtime.jsx)(_components.code, {\n        children: \"ElemdataType_\"\n      }), \" is as follows:\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"TYPE ElemdataType_\\n  INTEGER(I4B) :: internal = INTERNAL_ELEMENT\\n  INTEGER(I4B) :: boundary = BOUNDARY_ELEMENT\\n  INTEGER(I4B) :: domainBoundary = DOMAIN_BOUNDARY_ELEMENT\\n  INTEGER(I4B) :: ghost = GHOST_ELEMENT\\nEND TYPE ElemdataType_\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.admonition, {\n      type: \"info\",\n      children: (0,jsx_runtime.jsxs)(_components.p, {\n        children: [\"The \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"ElemdataType_\"\n        }), \" is private but you can use its instance called \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"TypeElem\"\n        }), \". For example to get the field \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"internal\"\n        }), \" you should use \", (0,jsx_runtime.jsx)(_components.code, {\n          children: \"TypeElem%internal\"\n        }), \".\"]\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This module exposes following methods.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_copy\",\n      children: \"Elemdata_Copy\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Copy obj2 to obj1\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_Copy(obj1, obj2)\\n  TYPE(Elemdata_), INTENT(INOUT) :: obj1\\n  TYPE(Elemdata_), INTENT(IN) :: obj2\\nEND SUBROUTINE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_display\",\n      children: \"Elemdata_Display\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Display the element data information.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_Display(obj)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\nEND SUBROUTINE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_elemtype2string\",\n      children: \"Elemdata_ElemType2String\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Convert the element type to string.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_ElemType2String(elementType) RESULT(ans)\\n  INTEGER(I4B), INTENT(IN) :: elementType\\n  CHARACTER(:), ALLOCATABLE :: ans\\nEND FUNCTION\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_deallocate\",\n      children: \"Elemdata_Deallocate\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Deallocate the element data.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_Deallocate(obj)\\n  TYPE(Elemdata_), INTENT(INOUT) :: obj\\nEND SUBROUTINE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_settotalmaterial\",\n      children: \"Elemdata_SetTotalMaterial\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Set the total number of materials.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_SetTotalMaterial(obj, n)\\n  TYPE(Elemdata_), INTENT(INOUT) :: obj\\n  INTEGER(I4B), INTENT(IN) :: n\\nEND SUBROUTINE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_set\",\n      children: \"Elemdata_Set\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Set the element data.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE SUBROUTINE Elemdata_Set(obj, globalElemNum, localElemNum, &\\n        elementType, globalNodes, globalElements, boundaryData, globalEdges, &\\n   globalFaces, name, topoName, isActive, meshID, medium, material, materials)\\n  ! obj%elementData(ii)%globalElemNum = elemNumber(ii)\\n  ! obj%elementData(ii)%localElemNum = ii\\n  ! obj%elementData(ii)%globalNodes = connectivity(:, ii)\\n  TYPE(Elemdata_), INTENT(INOUT) :: obj\\n  !! element data object\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalElemNum\\n  !! global element number\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: localElemNum\\n  !! local element number\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: elementType\\n  !! element type: internal element, boundary element, etc.\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalNodes(:)\\n  !! vertex connectivity\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalElements(:)\\n  !! element to element mapping\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: boundaryData(:)\\n  !! boundary data\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalEdges(:)\\n  !! edge connectivity\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalFaces(:)\\n  !! gace connectivity\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: name\\n  !! Type of element, triangle, triangle3, Quadrangle4, etc\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: topoName\\n  !! topology  name of the element\\n  LOGICAL(LGT), OPTIONAL, INTENT(IN) :: isActive\\n  !! is element active\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: meshID\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: medium\\n  !! medium id like soil,water, etc\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: material\\n  !! material like soil1, soil2, wate1, water2, etc\\n  INTEGER(I4B), OPTIONAL, INTENT(IN) :: materials(:)\\n  !! materials\\nEND SUBROUTINE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_pointer\",\n      children: \"Elemdata_Pointer\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Create a pointer to the element data.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_Pointer() RESULT(ans)\\n  CLASS(Elemdata_), POINTER :: ans\\n  ALLOCATE (Elemdata_ :: ans)\\nEND FUNCTION Elemdata_Pointer\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_lt\",\n      children: \"Elemdata_lt\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Compare two element data objects. Less than operator.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_lt(obj, obj2) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  TYPE(Elemdata_), INTENT(IN) :: obj2\\n  LOGICAL(LGT) :: ans\\n  ans = obj%globalElemNum .GT. obj2%globalElemNum\\nEND FUNCTION Elemdata_lt\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_eq\",\n      children: \"Elemdata_eq\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Compare two element data objects. Equal operator.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_eq(obj, obj2) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  TYPE(Elemdata_), INTENT(IN) :: obj2\\n  LOGICAL(LGT) :: ans\\n  ans = obj%globalElemNum .EQ. obj2%globalElemNum\\nEND FUNCTION Elemdata_eq\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_setid\",\n      children: \"Elemdata_SetID\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Set the element ID.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_SetID(obj, id)\\n  TYPE(Elemdata_), INTENT(INOUT) :: obj\\n  INTEGER(I4B), INTENT(IN) :: id\\nEND SUBROUTINE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getglobalfacecon\",\n      children: \"Elemdata_GetGlobalFaceCon\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"Get the global face connectivity. Returns the vertex connectivity of global face of elements.\"\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_GetGlobalFaceCon(obj, globalFaceCon, localFaceCon)\\n  TYPE(Elemdata_), INTENT(INOUT) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: globalFaceCon(:, :)\\n  INTEGER(I4B), OPTIONAL, INTENT(INOUT) :: localFaceCon(:, :)\\nEND SUBROUTINE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getconnectivity\",\n      children: \"Elemdata_GetConnectivity\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the connectivity of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n      children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"tsize is the size of data written in con\"\n      }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n        children: \"con is the connectivity array, it should be allocated\"\n      }), \"\\n\", (0,jsx_runtime.jsxs)(_components.li, {\n        children: [\"opt is the type of connectivity, following options are allowed\", \"\\n\", (0,jsx_runtime.jsxs)(_components.ul, {\n          children: [\"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"\\\"V\\\" or \\\"v\\\" : vertex connectivity\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"\\\"E\\\" or \\\"e\\\" : edge connectivity\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"\\\"F\\\" or \\\"f\\\" : face connectivity\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"\\\"C\\\" or \\\"c\\\" : cell connectivity\"\n          }), \"\\n\", (0,jsx_runtime.jsx)(_components.li, {\n            children: \"\\\"A\\\" or \\\"a\\\" : all connectivity\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_GetConnectivity(obj, con, tsize, opt)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: con(:)\\n  INTEGER(I4B), INTENT(OUT) :: tsize\\n  CHARACTER(*), INTENT(IN), OPTIONAL :: opt\\nEND SUBROUTINE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getconnectivity2\",\n      children: \"Elemdata_GetConnectivity2\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the connectivity of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_GetConnectivity2(obj, cellCon, faceCon, edgeCon, nodeCon, &\\n                                     tCellCon, tFaceCon, tEdgeCon, tNodeCon)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: cellCon(:)\\n  !! cell connectivity\\n  INTEGER(I4B), INTENT(INOUT) :: faceCon(:)\\n  !! face connectivity\\n  INTEGER(I4B), INTENT(INOUT) :: edgeCon(:)\\n  !! edge connectivity\\n  INTEGER(I4B), INTENT(INOUT) :: nodeCon(:)\\n  !! node connectivity\\n  INTEGER(I4B), INTENT(OUT) :: tCellCon\\n  !! total data written in cellCon\\n  INTEGER(I4B), INTENT(OUT) :: tFaceCon\\n  !! total data written in faceCon\\n  INTEGER(I4B), INTENT(OUT) :: tEdgeCon\\n  !! total data written in edgeCon\\n  INTEGER(I4B), INTENT(OUT) :: tNodeCon\\n  !! total data written in nodeCon\\nEND SUBROUTINE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotalentities\",\n      children: \"Elemdata_GetTotalEntities\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the total number of vertex, edge, face and cell entities in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_GetTotalEntities(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B) :: ans(4)\\n  ans(1) = SIZE(obj%globalNodes)\\n  ans(2) = SIZE(obj%globalEdges)\\n  ans(3) = SIZE(obj%globalFaces)\\n  ans(4) = 1\\nEND FUNCTION Elemdata_GetTotalEntities\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getvertex\",\n      children: \"Elemdata_GetVertex\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the global vertex number of a given local vertex number.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_GetVertex(obj, ii) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(in) :: ii\\n  !! local vertex number\\n  INTEGER(I4B) :: ans\\n  !! global vertex number\\n  \\n  ans = obj%globalNodes(ii)\\nEND FUNCTION Elemdata_GetVertex\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getedge\",\n      children: \"Elemdata_GetEdge\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the global edge number of a given local edge number.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_GetEdge(obj, ii) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(in) :: ii\\n  !! local edge number\\n  INTEGER(I4B) :: ans\\n  !! global edge number\\n  ans = obj%globalEdges(ii)\\nEND FUNCTION Elemdata_GetEdge\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getface\",\n      children: \"Elemdata_GetFace\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the global face number of a given local face number.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_GetFace(obj, ii) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(in) :: ii\\n  !! local face number\\n  INTEGER(I4B) :: ans\\n  !! global face number\\n  ans = obj%globalFaces(ii)\\nEND FUNCTION Elemdata_GetFace\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getcell\",\n      children: \"Elemdata_GetCell\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the global or local cell number of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_GetCell(obj, islocal) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  LOGICAL(LGT), INTENT(in) :: islocal\\n  !! If true then local cell number is returned\\n  INTEGER(I4B) :: ans\\n  !! global or local element number (cell number)\\n\\n  IF (islocal) THEN\\n    ans = obj%localElemNum\\n  ELSE\\n    ans = obj%globalElemNum\\n  END IF\\nEND FUNCTION Elemdata_GetCell\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotaledgedof\",\n      children: \"Elemdata_GetTotalEdgeDOF\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the total number of edge dof on the edge of an element. It does not return the edge dof on the boundary of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_GetTotalEdgeDOF(obj, ii, order, baseContinuity, &\\n                                  baseInterpolation) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  !! Element data object\\n  INTEGER(I4B), INTENT(IN) :: ii\\n  !! Local edge number\\n  INTEGER(I4B), INTENT(IN) :: order\\n  !! Order on the edge\\n  CHARACTER(*), INTENT(IN) :: baseContinuity\\n  !! base continuity: H1, HDiv, HCurl\\n  CHARACTER(*), INTENT(IN) :: baseInterpolation\\n  !! base interpolation type\\n  INTEGER(I4B) :: ans\\n  !! Total number of dof on edge\\n  ans = MAX(order - 2, 0_I4B)\\nEND FUNCTION Elemdata_GetTotalEdgeDOF\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotalfacedof\",\n      children: \"Elemdata_GetTotalFaceDOF\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the total number of face dofs on the face of an element.\\nAll dofs are internal to face, that is edge and vertex dof are not included.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_GetTotalFaceDOF(obj, ii, order, baseContinuity, &\\n                                  baseInterpolation) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  !! Element data object\\n  INTEGER(I4B), INTENT(IN) :: ii\\n  !! Local face number\\n  INTEGER(I4B), INTENT(IN) :: order\\n  !! Order on the edge\\n  CHARACTER(*), INTENT(IN) :: baseContinuity\\n  !! base continuity: H1, HDiv, HCurl\\n  CHARACTER(*), INTENT(IN) :: baseInterpolation\\n  !! base interpolation type\\n  INTEGER(I4B) :: ans\\n  !! Total number of dof on edge\\nEND FUNCTION Elemdata_GetTotalFaceDOF\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotalcelldof\",\n      children: \"Elemdata_GetTotalCellDOF\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the total number of cell dofs on the cell of an element. All dofs are internal to cell, that is edge and vertex dof are not included.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_GetTotalCellDOF(obj, order, baseContinuity, &\\n                                  baseInterpolation) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  !! Element data object\\n  INTEGER(I4B), INTENT(IN) :: order\\n  !! Order on the edge\\n  CHARACTER(*), INTENT(IN) :: baseContinuity\\n  !! base continuity: H1, HDiv, HCurl\\n  CHARACTER(*), INTENT(IN) :: baseInterpolation\\n  !! base interpolation type\\n  INTEGER(I4B) :: ans\\n  !! Total number of dof on edge\\nEND FUNCTION Elemdata_GetTotalCellDOF\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getelementtoelements1\",\n      children: \"Elemdata_GetElementToElements1\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the global element number of elements which surrounds the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_GetElementToElements1(obj, ans, tsize)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\\n  !! Element to element, it should be allocated by user before calling\\n  INTEGER(I4B), INTENT(OUT) :: tsize\\n  !! The size of data written to ans\\nEND SUBROUTINE Elemdata_GetElementToElements1\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getelementtoelements2\",\n      children: \"Elemdata_GetElementToElements2\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Get the element to element mapping including the local face number of the element and its neighbor.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_GetElementToElements2(obj, ans, nrow, ncol, &\\n                                          includeBoundaryElement)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:, :)\\n  !! Element to element, it should be allocated by user before calling\\n  !! each row denotes the information of a neighbor element.\\n  !! Therefore nrow is the total number of neighboring elements\\n  !! number of columns is 3. \\n  !! The first column is global element of the neighbor element\\n  !! The second column is local face number of parent element (this element)\\n  !! The third column is local face number of neighbor element\\n  INTEGER(I4B), INTENT(OUT) :: nrow\\n  !! Number of rows written to ans\\n  INTEGER(I4B), INTENT(OUT) :: ncol\\n  !! Number of columns written to ans\\n  LOGICAL(LGT), OPTIONAL, INTENT(IN) :: includeBoundaryElement\\n  !! If includeBoundaryElement is present and true, \\n  !! then the boundary element data is included in ans\\n  !! In this case the current element is considered as the boundary element\\n  !! ans(nrow, 1) contains the global element number of the current element\\n  !! ans(nrow, 2) contains the boundary data (local face number which coincides with\\n  !! the mesh boundary)\\n  !! ans(nrow, 3) is set to 0\\nEND SUBROUTINE Elemdata_GetElementToElements2\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getedgeconnectivity\",\n      children: \"Elemdata_GetEdgeConnectivity\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"Get the connectivity of the local edge.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_GetEdgeConnectivity(obj, ans, tsize, ii)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  !! Element data object\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\\n  !! edge connectivity, node numbers are global\\n  INTEGER(I4B), INTENT(OUT) :: tsize\\n  !! total data written to ans\\n  INTEGER(I4B), INTENT(IN) :: ii\\n  !! Edge number (local)\\nEND SUBROUTINE\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_isactive\",\n      children: \"Elemdata_isActive\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function return true if the element is active, false otherwise.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_isActive(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  LOGICAL(LGT) :: ans\\n  ans = obj%isActive\\nEND FUNCTION Elemdata_isActive\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_globalelemnum\",\n      children: \"Elemdata_globalElemNum\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the global element number of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_globalElemNum(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = obj%globalElemNum\\nEND FUNCTION Elemdata_globalElemNum\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_localelemnum\",\n      children: \"Elemdata_localElemNum\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the local element number of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_localElemNum(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = obj%localElemNum\\nEND FUNCTION Elemdata_localElemNum\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_name\",\n      children: \"Elemdata_name\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the name of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_name(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = obj%name\\nEND FUNCTION Elemdata_name\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_toponame\",\n      children: \"Elemdata_topoName\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the topology name of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_topoName(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = obj%topoName\\nEND FUNCTION Elemdata_topoName\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_topoindx\",\n      children: \"Elemdata_topoIndx\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the topology index of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_topoIndx(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = GetElementIndex(obj%topoName)\\nEND FUNCTION Elemdata_topoIndx\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_meshid\",\n      children: \"Elemdata_meshid\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the mesh id of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_meshid(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = obj%meshid\\nEND FUNCTION Elemdata_meshid\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotalmaterial\",\n      children: \"Elemdata_GetTotalMaterial\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the total number of materials in the element (that is material assigned the element).\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_GetTotalMaterial(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = SIZE(obj%material)\\nEND FUNCTION Elemdata_GetTotalMaterial\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotalglobalnodes\",\n      children: \"Elemdata_GetTotalGlobalNodes\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the total number of global nodes in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_GetTotalGlobalNodes(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = SIZE(obj%globalNodes)\\nEND FUNCTION Elemdata_GetTotalGlobalNodes\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotalglobaledges\",\n      children: \"Elemdata_GetTotalGlobalEdges\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the total number of global edges in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_GetTotalGlobalEdges(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = SIZE(obj%globalEdges)\\nEND FUNCTION Elemdata_GetTotalGlobalEdges\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotaledgeorient\",\n      children: \"Elemdata_GetTotalEdgeOrient\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the size of edgeOrient array.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_GetTotalEdgeOrient(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = SIZE(obj%edgeOrient)\\nEND FUNCTION Elemdata_GetTotalEdgeOrient\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotalglobalfaces\",\n      children: \"Elemdata_GetTotalGlobalFaces\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the size of globalFaces array.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotalfaceorient\",\n      children: \"Elemdata_GetTotalFaceOrient\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the size of faceOrient array.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotalglobalelements\",\n      children: \"Elemdata_GetTotalGlobalElements\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the size of globalElements array.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_gettotalboundarydata\",\n      children: \"Elemdata_GetTotalBoundaryData\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the size of boundaryData array.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getmaterial\",\n      children: \"Elemdata_GetMaterial\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the materials assigned to the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE SUBROUTINE Elemdata_GetMaterial(obj, ans, tsize)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\\n  INTEGER(I4B), INTENT(OUT) :: tsize\\nEND SUBROUTINE Elemdata_GetMaterial\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getglobalnodes\",\n      children: \"Elemdata_GetGlobalNodes\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the list of global nodes in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE SUBROUTINE Elemdata_GetGlobalNodes(obj, ans, tsize)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\\n  INTEGER(I4B), INTENT(OUT) :: tsize\\nEND SUBROUTINE Elemdata_GetGlobalNodes\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getglobaledges\",\n      children: \"Elemdata_GetGlobalEdges\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the list of global edges in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE SUBROUTINE Elemdata_GetGlobalEdges(obj, ans, tsize)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\\n  INTEGER(I4B), INTENT(OUT) :: tsize\\nEND SUBROUTINE Elemdata_GetGlobalEdges\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getglobalfaces\",\n      children: \"Elemdata_GetGlobalFaces\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the list of global faces in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE SUBROUTINE Elemdata_GetGlobalFaces(obj, ans, tsize)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\\n  INTEGER(I4B), INTENT(OUT) :: tsize\\nEND SUBROUTINE Elemdata_GetGlobalFaces\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getglobalfacenumber\",\n      children: \"Elemdata_GetGlobalFaceNumber\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the global face number from a local face number.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_GetGlobalFaceNumber(obj, localFaceNumber) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B), INTENT(IN) :: localFaceNumber\\n  !! local face number\\n  INTEGER(I4B) :: ans\\n  !! global face number\\nEND FUNCTION Elemdata_GetGlobalFaceNumber\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getglobaledgenumber\",\n      children: \"Elemdata_GetGlobalEdgeNumber\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the global edge number from a local edge number.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_GetGlobalEdgeNumber(obj, localEdgeNumber) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B), INTENT(IN) :: localEdgeNumber\\n  !! local edge number\\n  INTEGER(I4B) :: ans\\n  !! global edge number\\nEND FUNCTION Elemdata_GetGlobalEdgeNumber\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getglobalelements\",\n      children: \"Elemdata_GetGlobalElements\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the list of globalElements in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE SUBROUTINE Elemdata_GetGlobalElements(obj, ans, tsize)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\\n  INTEGER(I4B), INTENT(OUT) :: tsize\\nEND SUBROUTINE Elemdata_GetGlobalElements\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.admonition, {\n      type: \"note\",\n      children: (0,jsx_runtime.jsxs)(_components.p, {\n        children: [\"This routine returns all the entries of globalElements, so you should look at the meaning of globalElements in the \", (0,jsx_runtime.jsx)(_components.a, {\n          href: \"#structure\",\n          children: \"Structure\"\n        }), \" section.\"]\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getboundarydata\",\n      children: \"Elemdata_GetBoundaryData\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the list of boundaryData in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE SUBROUTINE Elemdata_GetBoundaryData(obj, ans, tsize)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\\n  !! boundary data, see the boundaryData in the type definition\\n  INTEGER(I4B), INTENT(OUT) :: tsize\\nEND SUBROUTINE Elemdata_GetBoundaryData\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getglobalnodespointer\",\n      children: \"Elemdata_GetGlobalNodesPointer\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the pointer to the globalNodes in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_GetGlobalNodesPointer(obj) RESULT(ans)\\n  TYPE(Elemdata_), TARGET, INTENT(IN) :: obj\\n  INTEGER(I4B), POINTER :: ans(:)\\n  ans => obj%globalNodes\\nEND FUNCTION Elemdata_GetGlobalNodesPointer\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getedgeorient\",\n      children: \"Elemdata_GetEdgeOrient\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the list of edgeOrient vector in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE SUBROUTINE Elemdata_GetEdgeOrient(obj, ans, tsize)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:)\\n  INTEGER(I4B), INTENT(OUT) :: tsize\\nEND SUBROUTINE Elemdata_GetEdgeOrient\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getfaceorient\",\n      children: \"Elemdata_GetFaceOrient\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the list of faceOrient vector in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE SUBROUTINE Elemdata_GetFaceOrient(obj, ans, nrow, ncol)\\n  TYPE(Elemdata_), INTENT(in) :: obj\\n  INTEGER(I4B), INTENT(INOUT) :: ans(:, :)\\n  INTEGER(I4B), INTENT(OUT) :: nrow, ncol\\nEND SUBROUTINE Elemdata_GetFaceOrient\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_getorientation\",\n      children: \"Elemdata_GetOrientation\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine returns the orientation related vectors in the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE SUBROUTINE Elemdata_GetOrientation(obj, cellOrient, faceOrient, &\\n                            edgeOrient, tCellOrient, tFaceOrient, tEdgeOrient)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  !! element dataa\\n  INTEGER(I4B), INTENT(INOUT) :: cellOrient(:)\\n  !! cell connectivity of element\\n  INTEGER(I4B), INTENT(INOUT) :: faceOrient(:, :)\\n  !! face connectivity of element\\n  INTEGER(I4B), INTENT(INOUT) :: edgeOrient(:)\\n  !! edge connectivity of element\\n  INTEGER(I4B), INTENT(OUT) :: tCellOrient\\n  !! size of data written in cellCon\\n  INTEGER(I4B), INTENT(OUT) :: tFaceOrient(2)\\n  !! size of data written in faceCon\\n  INTEGER(I4B), INTENT(OUT) :: tEdgeOrient\\n  !! size of data written in edgecon\\nEND SUBROUTINE Elemdata_GetOrientation\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_findface\",\n      children: \"Elemdata_FindFace\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine finds the local face number of the element which contains the given face. The given face is described by its connectivity of the vertices.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_FindFace(obj, faceCon, isFace, &\\n                             localFaceNumber, onlyBoundaryElement)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n    !! abstract mesh\\n  INTEGER(I4B), INTENT(IN) :: faceCon(:)\\n    !! vertex connectivity of face\\n  LOGICAL(LGT), INTENT(OUT) :: isFace\\n    !! if faceCon is a face of globalElement then it is true, else false\\n  INTEGER(I4B), INTENT(OUT) :: localFaceNumber\\n    !! local face number if found, else 0\\n  LOGICAL(LGT), INTENT(IN) :: onlyBoundaryElement\\n    !! if true then we will search if the element is boundary element\\nEND SUBROUTINE Elemdata_FindFace\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_findedge\",\n      children: \"Elemdata_FindEdge\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This subroutine finds the local edge number of the element which contains the given edge. The given edge is described by its connectivity of the vertices.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"SUBROUTINE Elemdata_FindEdge(obj, edgeCon, isEdge, localEdgeNumber, &\\n                             onlyBoundaryElement)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  !! abstract mesh\\n  INTEGER(I4B), INTENT(IN) :: edgeCon(:)\\n  !! vertex connectivity of Edge\\n  LOGICAL(LGT), INTENT(OUT) :: isEdge\\n  !! if EdgeCon is a Edge of globalElement then it is true, else false\\n  INTEGER(I4B), INTENT(OUT) :: localEdgeNumber\\n  !! local Edge number if found, else 0\\n  LOGICAL(LGT), INTENT(IN) :: onlyBoundaryElement\\n  !! if true then we will search if the element is boundary element\\nEND SUBROUTINE Elemdata_FindEdge\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_isboundaryelement\",\n      children: \"Elemdata_IsBoundaryElement\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns true if the element is a boundary element, false otherwise.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"FUNCTION Elemdata_IsBoundaryElement(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  LOGICAL(LGT) :: ans\\n  ans = (obj%elementType .EQ. TypeElem%boundary) .OR. &\\n        (obj%elementType .EQ. TypeElem%domainBoundary)\\nEND FUNCTION Elemdata_IsBoundaryElement\\n\"\n      })\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.h2, {\n      id: \"elemdata_order\",\n      children: \"Elemdata_Order\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.p, {\n      children: \"This function returns the order of the element.\"\n    }), \"\\n\", (0,jsx_runtime.jsx)(_components.pre, {\n      children: (0,jsx_runtime.jsx)(_components.code, {\n        className: \"language-fortran\",\n        children: \"PURE FUNCTION Elemdata_Order(obj) RESULT(ans)\\n  TYPE(Elemdata_), INTENT(IN) :: obj\\n  INTEGER(I4B) :: ans\\n  ans = ElementOrder(obj%name)\\nEND FUNCTION Elemdata_Order\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ...(0,lib.useMDXComponents)(),\n    ...props.components\n  };\n  return MDXLayout ? (0,jsx_runtime.jsx)(MDXLayout, {\n    ...props,\n    children: (0,jsx_runtime.jsx)(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9kb2NzL2RvY3MtYXBpL0Fic3RyYWN0TWVzaC9FbGVtRGF0YV8ubWQiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vhc2lmZW0tZG9jcy8uL2RvY3MvZG9jcy1hcGkvQWJzdHJhY3RNZXNoL0VsZW1EYXRhXy5tZD8yODU0Il0sInNvdXJjZXNDb250ZW50IjpbIlxuXG5leHBvcnQgY29uc3QgZnJvbnRNYXR0ZXIgPSB7XG5cdHNpZGViYXJfcG9zaXRpb246IDNcbn07XG5leHBvcnQgY29uc3QgY29udGVudFRpdGxlID0gJ0VsZW1EYXRhJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZXRhZGF0YX0gZnJvbSAnQHNpdGUvLmRvY3VzYXVydXMvZG9jdXNhdXJ1cy1wbHVnaW4tY29udGVudC1kb2NzL2RvY3MtYXBpL3NpdGUtZG9jcy1kb2NzLWFwaS1hYnN0cmFjdC1tZXNoLWVsZW0tZGF0YS1tZC1hZDAuanNvbidcbmV4cG9ydCBjb25zdCBhc3NldHMgPSB7XG5cbn07XG5cbmltcG9ydCB7RnJhZ21lbnQgYXMgX0ZyYWdtZW50LCBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4c30gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQge3VzZU1EWENvbXBvbmVudHMgYXMgX3Byb3ZpZGVDb21wb25lbnRzfSBmcm9tIFwiQG1keC1qcy9yZWFjdFwiO1xuZXhwb3J0IGNvbnN0IHRvYyA9IFt7XG4gIFwidmFsdWVcIjogXCJTdHJ1Y3R1cmVcIixcbiAgXCJpZFwiOiBcInN0cnVjdHVyZVwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIjxjb2RlPmlzQWN0aXZlPC9jb2RlPlwiLFxuICBcImlkXCI6IFwiaXNhY3RpdmVcIixcbiAgXCJsZXZlbFwiOiAzXG59LCB7XG4gIFwidmFsdWVcIjogXCI8Y29kZT5nbG9iYWxFbGVtZW50czwvY29kZT5cIixcbiAgXCJpZFwiOiBcImdsb2JhbGVsZW1lbnRzXCIsXG4gIFwibGV2ZWxcIjogM1xufSwge1xuICBcInZhbHVlXCI6IFwiPGNvZGU+bG9jYWxFbGVtTnVtPC9jb2RlPlwiLFxuICBcImlkXCI6IFwibG9jYWxlbGVtbnVtXCIsXG4gIFwibGV2ZWxcIjogM1xufSwge1xuICBcInZhbHVlXCI6IFwiPGNvZGU+ZWxlbWVudFR5cGU8L2NvZGU+XCIsXG4gIFwiaWRcIjogXCJlbGVtZW50dHlwZVwiLFxuICBcImxldmVsXCI6IDNcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIjxjb2RlPm5hbWU8L2NvZGU+XCIsXG4gIFwiaWRcIjogXCJuYW1lXCIsXG4gIFwibGV2ZWxcIjogM1xufSwge1xuICBcInZhbHVlXCI6IFwiPGNvZGU+bWVzaElEPC9jb2RlPlwiLFxuICBcImlkXCI6IFwibWVzaGlkXCIsXG4gIFwibGV2ZWxcIjogM1xufSwge1xuICBcInZhbHVlXCI6IFwiPGNvZGU+bWF0ZXJpYWw8L2NvZGU+XCIsXG4gIFwiaWRcIjogXCJtYXRlcmlhbFwiLFxuICBcImxldmVsXCI6IDNcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIjxjb2RlPmdsb2JhbE5vZGVzPC9jb2RlPlwiLFxuICBcImlkXCI6IFwiZ2xvYmFsbm9kZXNcIixcbiAgXCJsZXZlbFwiOiAzXG59LCB7XG4gIFwidmFsdWVcIjogXCI8Y29kZT5nbG9iYWxFZGdlczwvY29kZT4gYW5kIDxjb2RlPmVkZ2VPcmllbnQ8L2NvZGU+XCIsXG4gIFwiaWRcIjogXCJnbG9iYWxlZGdlcy1hbmQtZWRnZW9yaWVudFwiLFxuICBcImxldmVsXCI6IDNcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIjxjb2RlPmdsb2JhbEZhY2VzPC9jb2RlPiBhbmQgPGNvZGU+ZmFjZU9yaWVudDwvY29kZT5cIixcbiAgXCJpZFwiOiBcImdsb2JhbGZhY2VzLWFuZC1mYWNlb3JpZW50XCIsXG4gIFwibGV2ZWxcIjogM1xufSwge1xuICBcInZhbHVlXCI6IFwiPGNvZGU+Z2xvYmFsRWxlbWVudHM8L2NvZGU+XCIsXG4gIFwiaWRcIjogXCJnbG9iYWxlbGVtZW50cy0xXCIsXG4gIFwibGV2ZWxcIjogM1xufSwge1xuICBcInZhbHVlXCI6IFwiPGNvZGU+Ym91bmRhcnlEYXRhPC9jb2RlPlwiLFxuICBcImlkXCI6IFwiYm91bmRhcnlkYXRhXCIsXG4gIFwibGV2ZWxcIjogM1xufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFUeXBlXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YXR5cGVcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9Db3B5XCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9jb3B5XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfRGlzcGxheVwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZGlzcGxheVwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0VsZW1UeXBlMlN0cmluZ1wiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZWxlbXR5cGUyc3RyaW5nXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfRGVhbGxvY2F0ZVwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZGVhbGxvY2F0ZVwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX1NldFRvdGFsTWF0ZXJpYWxcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX3NldHRvdGFsbWF0ZXJpYWxcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9TZXRcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX3NldFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX1BvaW50ZXJcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX3BvaW50ZXJcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9sdFwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfbHRcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9lcVwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZXFcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9TZXRJRFwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfc2V0aWRcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRHbG9iYWxGYWNlQ29uXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXRnbG9iYWxmYWNlY29uXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfR2V0Q29ubmVjdGl2aXR5XCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXRjb25uZWN0aXZpdHlcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRDb25uZWN0aXZpdHkyXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXRjb25uZWN0aXZpdHkyXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfR2V0VG90YWxFbnRpdGllc1wiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0dG90YWxlbnRpdGllc1wiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0dldFZlcnRleFwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0dmVydGV4XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfR2V0RWRnZVwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0ZWRnZVwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0dldEZhY2VcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX2dldGZhY2VcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRDZWxsXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXRjZWxsXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfR2V0VG90YWxFZGdlRE9GXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXR0b3RhbGVkZ2Vkb2ZcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRUb3RhbEZhY2VET0ZcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX2dldHRvdGFsZmFjZWRvZlwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0dldFRvdGFsQ2VsbERPRlwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0dG90YWxjZWxsZG9mXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfR2V0RWxlbWVudFRvRWxlbWVudHMxXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXRlbGVtZW50dG9lbGVtZW50czFcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRFbGVtZW50VG9FbGVtZW50czJcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX2dldGVsZW1lbnR0b2VsZW1lbnRzMlwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0dldEVkZ2VDb25uZWN0aXZpdHlcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX2dldGVkZ2Vjb25uZWN0aXZpdHlcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9pc0FjdGl2ZVwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfaXNhY3RpdmVcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9nbG9iYWxFbGVtTnVtXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nbG9iYWxlbGVtbnVtXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfbG9jYWxFbGVtTnVtXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9sb2NhbGVsZW1udW1cIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9uYW1lXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9uYW1lXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfdG9wb05hbWVcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX3RvcG9uYW1lXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfdG9wb0luZHhcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX3RvcG9pbmR4XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfbWVzaGlkXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9tZXNoaWRcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRUb3RhbE1hdGVyaWFsXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXR0b3RhbG1hdGVyaWFsXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfR2V0VG90YWxHbG9iYWxOb2Rlc1wiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0dG90YWxnbG9iYWxub2Rlc1wiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0dldFRvdGFsR2xvYmFsRWRnZXNcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX2dldHRvdGFsZ2xvYmFsZWRnZXNcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRUb3RhbEVkZ2VPcmllbnRcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX2dldHRvdGFsZWRnZW9yaWVudFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0dldFRvdGFsR2xvYmFsRmFjZXNcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX2dldHRvdGFsZ2xvYmFsZmFjZXNcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRUb3RhbEZhY2VPcmllbnRcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX2dldHRvdGFsZmFjZW9yaWVudFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0dldFRvdGFsR2xvYmFsRWxlbWVudHNcIixcbiAgXCJpZFwiOiBcImVsZW1kYXRhX2dldHRvdGFsZ2xvYmFsZWxlbWVudHNcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRUb3RhbEJvdW5kYXJ5RGF0YVwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0dG90YWxib3VuZGFyeWRhdGFcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRNYXRlcmlhbFwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0bWF0ZXJpYWxcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRHbG9iYWxOb2Rlc1wiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0Z2xvYmFsbm9kZXNcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRHbG9iYWxFZGdlc1wiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0Z2xvYmFsZWRnZXNcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRHbG9iYWxGYWNlc1wiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0Z2xvYmFsZmFjZXNcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRHbG9iYWxGYWNlTnVtYmVyXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXRnbG9iYWxmYWNlbnVtYmVyXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfR2V0R2xvYmFsRWRnZU51bWJlclwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0Z2xvYmFsZWRnZW51bWJlclwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0dldEdsb2JhbEVsZW1lbnRzXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXRnbG9iYWxlbGVtZW50c1wiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0dldEJvdW5kYXJ5RGF0YVwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0Ym91bmRhcnlkYXRhXCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfR2V0R2xvYmFsTm9kZXNQb2ludGVyXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXRnbG9iYWxub2Rlc3BvaW50ZXJcIixcbiAgXCJsZXZlbFwiOiAyXG59LCB7XG4gIFwidmFsdWVcIjogXCJFbGVtZGF0YV9HZXRFZGdlT3JpZW50XCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXRlZGdlb3JpZW50XCIsXG4gIFwibGV2ZWxcIjogMlxufSwge1xuICBcInZhbHVlXCI6IFwiRWxlbWRhdGFfR2V0RmFjZU9yaWVudFwiLFxuICBcImlkXCI6IFwiZWxlbWRhdGFfZ2V0ZmFjZW9yaWVudFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0dldE9yaWVudGF0aW9uXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9nZXRvcmllbnRhdGlvblwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0ZpbmRGYWNlXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9maW5kZmFjZVwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0ZpbmRFZGdlXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9maW5kZWRnZVwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX0lzQm91bmRhcnlFbGVtZW50XCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9pc2JvdW5kYXJ5ZWxlbWVudFwiLFxuICBcImxldmVsXCI6IDJcbn0sIHtcbiAgXCJ2YWx1ZVwiOiBcIkVsZW1kYXRhX09yZGVyXCIsXG4gIFwiaWRcIjogXCJlbGVtZGF0YV9vcmRlclwiLFxuICBcImxldmVsXCI6IDJcbn1dO1xuZnVuY3Rpb24gX2NyZWF0ZU1keENvbnRlbnQocHJvcHMpIHtcbiAgY29uc3QgX2NvbXBvbmVudHMgPSB7XG4gICAgYTogXCJhXCIsXG4gICAgYWRtb25pdGlvbjogXCJhZG1vbml0aW9uXCIsXG4gICAgYW5ub3RhdGlvbjogXCJhbm5vdGF0aW9uXCIsXG4gICAgY29kZTogXCJjb2RlXCIsXG4gICAgaDE6IFwiaDFcIixcbiAgICBoMjogXCJoMlwiLFxuICAgIGgzOiBcImgzXCIsXG4gICAgaGVhZGVyOiBcImhlYWRlclwiLFxuICAgIGxpOiBcImxpXCIsXG4gICAgbWF0aDogXCJtYXRoXCIsXG4gICAgbW86IFwibW9cIixcbiAgICBtcm93OiBcIm1yb3dcIixcbiAgICBwOiBcInBcIixcbiAgICBwcmU6IFwicHJlXCIsXG4gICAgc2VtYW50aWNzOiBcInNlbWFudGljc1wiLFxuICAgIHNwYW46IFwic3BhblwiLFxuICAgIHVsOiBcInVsXCIsXG4gICAgLi4uX3Byb3ZpZGVDb21wb25lbnRzKCksXG4gICAgLi4ucHJvcHMuY29tcG9uZW50c1xuICB9O1xuICByZXR1cm4gX2pzeHMoX0ZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmhlYWRlciwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuaDEsIHtcbiAgICAgICAgaWQ6IFwiZWxlbWRhdGFcIixcbiAgICAgICAgY2hpbGRyZW46IFwiRWxlbURhdGFcIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJJdCBpcyBhIGRhdGEgdHlwZSBmb3Igc3RvcmluZyB0aGUgZWxlbWVudC1kYXRhIGluZm9ybWF0aW9uLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcInN0cnVjdHVyZVwiLFxuICAgICAgY2hpbGRyZW46IFwiU3RydWN0dXJlXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiVFlQRSA6OiBFbGVtRGF0YV9cXG4gIExPR0lDQUwoTEdUKSA6OiBpc0FjdGl2ZSA9IC5UUlVFLlxcbiAgICAhISBJcyBlbGVtZW50IGluIGFjdGl2ZSBzdGFnZVxcbiAgSU5URUdFUihJNEIpIDo6IGdsb2JhbEVsZW1OdW0gPSAwX0k0QlxcbiAgICAhISBnbG9iYWwgZWxlbWVudCBudW1iZXJcXG4gICAgISEgY2VsbCBjb25uZWN0aXZpdHkgbnVtYmVyXFxuICBJTlRFR0VSKEk0QikgOjogbG9jYWxFbGVtTnVtID0gMF9JNEJcXG4gICAgISEgbG9jYWwgZWxlbWVudCBudW1iZXJcXG4gIElOVEVHRVIoSTRCKSA6OiBlbGVtZW50VHlwZSA9IElOVEVSTkFMX0VMRU1FTlRcXG4gICAgISEgQk9VTkRBUllfRUxFTUVOVDogSWYgdGhlIGVsZW1lbnQgY29udHFhaW5zIHRoZSBib3VuZGFyeSBub2RlXFxuICAgICEhIGl0IHdpbGwgYmUgY2FsbGVkIHRoZSBib3VuZGFyeSBlbGVtZW50XFxuICAgICEhIElOVEVSTkFMX0VMRU1FTlQ6IElmIHRoZSBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gdGhlIGJvdW5kYXJ5IG5vZGVcXG4gICAgISEgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCB0aGUgaW50ZXJuYWwgZWxlbWVudFxcbiAgSU5URUdFUihJNEIpIDo6IG5hbWUgPSAwXFxuICAgICEhIFRoaXMgaXMgbmFtZSBvZiB0aGUgZWxlbWVudFxcbiAgICAhISBJdCBjYW4gYmUgVHJpYW5nbGUsIFRyaWFuZ2xlMywgVHJpYW5nbGU2LCBldGMuXFxuICAgICEhIFF1YWRyYW5nbGUsXFxuICBJTlRFR0VSKEk0QikgOjogbWVzaElEID0gMFxcbiAgICAhISBJRCBvZiBtZXNoIHRvIHdoaWNoIHRoZSBlbGVtZW50IGJlbG9uZ1xcbiAgICAhISBUaGlzIGlzIGEgZ21zaCBjb25jZXB0XFxuICBJTlRFR0VSKElOVDgpLCBBTExPQ0FUQUJMRSA6OiBtYXRlcmlhbCg6KVxcbiAgICAhISBtYXRlcmlhbHMgbWFwcGVkIHRvIHRoZSBtZXNoXFxuICAgICEhIG1hdGVyaWFsKDEpIGlzIHRoZSBtYXRlcmlhbC1pZCAodHlwZSBvZiBtYXRlcmlhbCkgb2YgbWVkaXVtIDFcXG4gICAgISEgbWF0ZXJpYWwoMikgaXMgdGhlIG1hdGVyaWFsLWlkICh0eXBlIG9mIG1hdGVyaWFsKSBvZiBtZWRpdW0gMlxcbiAgICAhIVxcbiAgICAhISAuLi5cXG4gICAgISFcXG4gICAgISEgRm9yIGV4YW1wbGUsIHNvaWwgaXMgYSBwb3JvdXMgbWVkaXVtIHdpdGggbiA9IDEsXFxuICAgICEhIGZsdWlkIGlzIGEgbWVkaXVtIHdpdGggbiA9MlxcbiAgICAhISB0aGVuIG1hdGVyaWFsKDEpIGRlbm90ZXMgdGhlIHR5cGUgb2Ygc29pbCA9PiBjbGF5LCBzYW5kLCBzaWx0XFxuICAgICEhIGFuZCBtYXRlcmlhbCgyKSBkZW5vdGVzIHRoZSB0eXBlIG9mIGZsdWlkID0+IHdhdGVyLCBvaWwsIGFpclxcbiAgSU5URUdFUihJNEIpLCBBTExPQ0FUQUJMRSA6OiBnbG9iYWxOb2Rlcyg6KVxcbiAgICAhISBub2RlcyBjb250YWluZWQgaW4gdGhlIGVsZW1lbnQsIGNvbm5lY3Rpdml0eVxcbiAgICAhISBWZXJ0ZXggY29ubmVjdGl2aXR5XFxuICBJTlRFR0VSKEk0QiksIEFMTE9DQVRBQkxFIDo6IGdsb2JhbEVkZ2VzKDopXFxuICAgICEhIEVkZ2UgY29ubmVjdGl2aXR5XFxuICBJTlRFR0VSKElOVDgpLCBBTExPQ0FUQUJMRSA6OiBlZGdlT3JpZW50KDopXFxuICAgICEhIE9yaWVudGF0aW9uIG9mIGVkZ2VcXG4gIElOVEVHRVIoSTRCKSwgQUxMT0NBVEFCTEUgOjogZ2xvYmFsRmFjZXMoOilcXG4gICAgISEgRmFjZSBjb25uZWN0aXZpdHlcXG4gIElOVEVHRVIoSU5UOCksIEFMTE9DQVRBQkxFIDo6IGZhY2VPcmllbnQoOiwgOilcXG4gICAgISEgT3JpZW50YXRpb24gb2YgZmFjZVxcbiAgSU5URUdFUihJNEIpLCBBTExPQ0FUQUJMRSA6OiBnbG9iYWxFbGVtZW50cyg6KVxcbiAgICAhISBDb250YWlucyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVsZW1lbnQgc3Vycm91bmRpbmcgYW4gZWxlbWVudFxcbiAgICAhISBMZXRzIHVzIHNheSB0aGF0IGBnbG9iYWxFbGVtMWAsIGBnbG9iYWxFbGVtMmAsIGBnbG9iYWxFbGVtM2BcXG4gICAgISEgc3Vycm91bmRzIGEgbG9jYWwgZWxlbWVudCBpZWxlbSAoaXRzIGdsb2JhbCBlbGVtZW50IG51bWJlciBpc1xcbiAgICAhISBnbG9iYWxFbGVtKSwgdGhlblxcbiAgICAhISAtIGdsb2JhbEVsZW1lbnRzKCBbMSwyLDNdICkgY29udGFpbnMgZ2xvYmFsRWxlbTEsIHBGYWNlLCBuRmFjZVxcbiAgICAhISAtIGdsb2JhbEVsZW1lbnRzKCBbNCw1LDZdICkgY29udGFpbnMgZ2xvYmFsRWxlbTIsIHBGYWNlLCBuRmFjZVxcbiAgICAhISAtIGdsb2JhbEVsZW1lbnRzKCBbNyw4LDldICkgY29udGFpbnMgZ2xvYmFsRWxlbTMsIHBGYWNlLCBuRmFjZS5cXG4gICAgISEgSGVyZSxcXG4gICAgISEgLSBwRmFjZSBpcyB0aGUgbG9jYWwgZmFjZXQgbnVtYmVyIG9mIHBhcmVudCBlbGVtZW50XFxuICAgICEhIGdsb2JhbEVsZW0gKGllbGVtKSB3aGljaCBpcyBjb25uZWN0ZWQgdG8gdGhlIG5GYWNlIG9mIHRoZSBuZWlnaGJvclxcbiAgICAhISBlbGVtZW50XFxuICAgICEhIEFsbCBlbGVtZW50IG51bWJlcnMgYXJlIGdsb2JhbCBlbGVtZW50IG51bWJlclxcbiAgSU5URUdFUihJNEIpLCBBTExPQ0FUQUJMRSA6OiBib3VuZGFyeURhdGEoOilcXG4gICAgISEgSWYgYGllbGAgaXMgYm91bmRhcnkgZWxlbWVudCwgdGhlbiBib3VkbmFyeURhdGEgY29udGFpbnNcXG4gICAgISEgdGhlIGxvY2FsIGZhY2V0IG51bWJlciBvZiBpZWwgd2hpY2ggY29uY2lkZXMgd2l0aCB0aGVcXG4gICAgISEgbWVzaCBib3VuZGFyeS5cXG4gICAgISEgSWYgYW4gZWxlbWVudCBjb250YWlucyB0aGUgYm91bmRhcnkgbm9kZSB0aGVuIGl0IGlzIGNvbnNpZGVyZWRcXG4gICAgISEgYXMgYSBib3VuZGFyeSBlbGVtZW50LlxcbiAgICAhISBJdCBtYXkgaGFwcGVuIHRoYXQgYSBib3VuZGFyeSBlbGVtZW50IGhhcyBubyBib3VuZGFyeSBmYWNlLCBpbiB3aGljaFxcbiAgICAhISBjYXNlIGJvdW5kYXJ5RGF0YSB3aWxsIGhhdmUgemVybyBzaXplXFxuRU5EIFRZUEUgRWxlbURhdGFfXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDMsIHtcbiAgICAgIGlkOiBcImlzYWN0aXZlXCIsXG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImlzQWN0aXZlXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSWYgdGhlIGVsZW1lbnQgaXMgYWN0aXZlIG9yIG5vdC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgzLCB7XG4gICAgICBpZDogXCJnbG9iYWxlbGVtZW50c1wiLFxuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJnbG9iYWxFbGVtZW50c1wiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJnbG9iYWxFbGVtTnVtXCJcbiAgICAgIH0pLCBcIiBnbG9iYWwgZWxlbWVudCBudW1iZXIsIHRoaXMgbnVtYmVyIGlzIGdpdmVuIGJ5IHRoZSBtZXNoIGdlbmVyYXRvci5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMywge1xuICAgICAgaWQ6IFwibG9jYWxlbGVtbnVtXCIsXG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImxvY2FsRWxlbU51bVwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJsb2NhbEVsZW1OdW1cIlxuICAgICAgfSksIFwiIGxvY2FsIGVsZW1lbnQgbnVtYmVyLCBUaGlzIG51bWJlciBpcyBkZWNpZGVkIGludGVybmFsbHkuIEl0IHJlcHJlc2VudHMgdGhlIGludGVybmFsIHN0b3JhZ2UgYWRkcmVzcy5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMywge1xuICAgICAgaWQ6IFwiZWxlbWVudHR5cGVcIixcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZWxlbWVudFR5cGVcIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZWxlbWVudFR5cGVcIlxuICAgICAgfSksIFwiIGhhcyBmb2xsb3dpbmcgbWVhbmluZyBhcyBvZiAyMDI0LTA0LTE0XCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiQk9VTkRBUllfRUxFTUVOVFwiXG4gICAgICAgIH0pLCBcIjogSWYgdGhlIGVsZW1lbnQgY29udGFpbnMgYSBmYWNldCB3aGljaCBjb2luY2lkZXMgd2l0aCB0aGUgYm91bmRhcnkgdGhlbiwgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCB0aGUgYm91bmRhcnkgZWxlbWVudFwiXVxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiSU5URVJOQUxfRUxFTUVOVFwiXG4gICAgICAgIH0pLCBcIjogT3RoZXJ3aXNlIHRoZSBlbGVtZW50IGlzIGNsYXNzaWZpZWQgYXMgdGhlIGludGVybmFsIGVsZW1lbnQuXCJdXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMywge1xuICAgICAgaWQ6IFwibmFtZVwiLFxuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJuYW1lXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiTmFtZSBvZiB0aGUgZWxlbWVudC4gWW91IGNhbiBmaW5kIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBvbiBmb2xsb3dpbmcgcGFnZXM6XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5hLCB7XG4gICAgICAgICAgaHJlZjogXCIvZG9jcy1hcGkvR2xvYmFsRGF0YS9cIixcbiAgICAgICAgICBjaGlsZHJlbjogXCJHbG9iYWxEYXRhXCJcbiAgICAgICAgfSlcbiAgICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmEsIHtcbiAgICAgICAgICBocmVmOiBcIi4uL1JlZmVyZW5jZUVsZW1lbnRcIixcbiAgICAgICAgICBjaGlsZHJlbjogXCJSZWZlcmVuY2VFbGVtZW50XCJcbiAgICAgICAgfSlcbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgzLCB7XG4gICAgICBpZDogXCJtZXNoaWRcIixcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwibWVzaElEXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiSXQgcmVwcmVzZW50IHRoZSBtZXNoIHJlZ2lvbi4gVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gYXNzaWduIG1hdGVyaWFsIHByb3BlcnRpZXMsIGJvdW5kYXJ5IGNvbmRpdGlvbnMsIGV0YyB0byBhIHJlZ2lvbiBvZiB0aGUgbWVzaC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgzLCB7XG4gICAgICBpZDogXCJtYXRlcmlhbFwiLFxuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJtYXRlcmlhbFwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJtYXRlcmlhbFwiXG4gICAgICB9KSwgXCIgbWFwcyB0aGUgbWF0ZXJpYWwgdG8gdGhlIG1lc2gsIGZvciBleGFtcGxlXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwibWF0ZXJpYWwoMSlcIlxuICAgICAgICB9KSwgXCIgaXMgdGhlIG1hdGVyaWFsLWlkIG9mIG1lZGl1bSAxIChoZXJlIDEgbWF5IGRlbm90ZSBzb2lsKVwiXVxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwibWF0ZXJpYWwoMilcIlxuICAgICAgICB9KSwgXCIgaXMgdGhlIG1hdGVyaWFsLWlkIG9mIG1lZGl1bSAyIChoZXJlLCAyIG1heSBkZW5vdGUgd2F0ZXIpXCJdXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogX2pzeHMoX2NvbXBvbmVudHMuc3Bhbiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJrYXRleFwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5zcGFuLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwia2F0ZXgtbWF0aG1sXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5tYXRoLCB7XG4gICAgICAgICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IF9qc3hzKF9jb21wb25lbnRzLnNlbWFudGljcywge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5tcm93LCB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5tbywge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCLii69cIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KSwgX2pzeChfY29tcG9uZW50cy5hbm5vdGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICBlbmNvZGluZzogXCJhcHBsaWNhdGlvbi94LXRleFwiLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiXFxcXGNkb3RzXCJcbiAgICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIF9qc3goX2NvbXBvbmVudHMuc3Bhbiwge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImthdGV4LWh0bWxcIixcbiAgICAgICAgICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogX2pzeHMoX2NvbXBvbmVudHMuc3Bhbiwge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiYmFzZVwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuc3Bhbiwge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJzdHJ1dFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMC4zMTNlbVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgX2pzeChfY29tcG9uZW50cy5zcGFuLCB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm1pbm5lclwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIuKLr1wiXG4gICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSlcbiAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIm1hdGVyaWFsKG4pXCJcbiAgICAgICAgfSksIFwiIGlzIHRoZSBtYXRlcmlhbC1pZCBvZiBtZWRpdW0gblwiXVxuICAgICAgfSksIFwiXFxuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiRm9yIGV4YW1wbGUsIHNvaWwgaXMgYSBwb3JvdXMgbWVkaXVtIHdpdGggbWF0ZXJpYWwgaWQgPSAxLCBmbHVpZCBpcyBhIG1lZGl1bSB3aXRoIGlkPTIuIFRoZW4sIG1hdGVyaWFsKDEpIGRlbm90ZXMgdGhlIHR5cGUgb2Ygc29pbCwgdGhhdCBpcywgY2xheSwgc2FuZCwgYW5kIHNpbHQuIEFsc28sIG1hdGVyaWFsKDIpIGRlbm90ZXMgdGhlIHR5cGUgb2YgZmx1aWQsIHdhdGVyLCBvaWwsIGFpci5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiVGhlIHNpemUgb2YgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJtYXRlcmlhbFwiXG4gICAgICB9KSwgXCIgZGVub3RlcyB0aGUgdG90YWwgbnVtYmVyIG9mIG1hdGVyaWFscyBhc3NpZ25lZCB0byB0aGUgZWxlbWVudC5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMywge1xuICAgICAgaWQ6IFwiZ2xvYmFsbm9kZXNcIixcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZ2xvYmFsTm9kZXNcIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZ2xvYmFsTm9kZXNcIlxuICAgICAgfSksIFwiIG5vZGVzIGNvbnRhaW5lZCBpbiB0aGUgZWxlbWVudCwgaS5lLiwgdmVydGV4IGNvbm5lY3Rpdml0eS5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMuaDMsIHtcbiAgICAgIGlkOiBcImdsb2JhbGVkZ2VzLWFuZC1lZGdlb3JpZW50XCIsXG4gICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJnbG9iYWxFZGdlc1wiXG4gICAgICB9KSwgXCIgYW5kIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZWRnZU9yaWVudFwiXG4gICAgICB9KV1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJlZGdlIGNvbm5lY3Rpdml0eSBhbmQgZWRnZSBvcmllbnRhdGlvbi5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5oMywge1xuICAgICAgaWQ6IFwiZ2xvYmFsZmFjZXMtYW5kLWZhY2VvcmllbnRcIixcbiAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImdsb2JhbEZhY2VzXCJcbiAgICAgIH0pLCBcIiBhbmQgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJmYWNlT3JpZW50XCJcbiAgICAgIH0pXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcImZhY2UgY29ubmVjdGl2aXR5IGFuZCBmYWNlIG9yaWVudGF0aW9uLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDMsIHtcbiAgICAgIGlkOiBcImdsb2JhbGVsZW1lbnRzLTFcIixcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZ2xvYmFsRWxlbWVudHNcIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZ2xvYmFsRWxlbWVudHNcIlxuICAgICAgfSksIFwiIGNvbnRhaW5zIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZWxlbWVudHMgc3Vycm91bmRpbmcgYW4gZWxlbWVudC4gVGhpcyBpcyBleHBsYWluZWQgYmVsb3c6XCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJMZXQgdXMgc2F5IHRoYXQgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJnbG9iYWxFbGVtMVwiXG4gICAgICB9KSwgXCIsIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZ2xvYmFsRWxlbTJcIlxuICAgICAgfSksIFwiLCBhbmQgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJnbG9iYWxFbGVtM1wiXG4gICAgICB9KSwgXCIgc3Vycm91bmQgYSBsb2NhbCBlbGVtZW50IFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiaWVsZW1cIlxuICAgICAgfSksIFwiIChpdHMgZ2xvYmFsIGVsZW1lbnQgbnVtYmVyIGlzIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiZ2xvYmFsRWxlbVwiXG4gICAgICB9KSwgXCIpLCB0aGVuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiZ2xvYmFsRWxlbWVudHMoIFsxLDIsM10gKVwiXG4gICAgICAgIH0pLCBcIiBjb250YWlucyBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiZ2xvYmFsRWxlbTFcIlxuICAgICAgICB9KSwgXCIsIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJwRmFjZVwiXG4gICAgICAgIH0pLCBcIiwgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIm5GYWNlXCJcbiAgICAgICAgfSldXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJnbG9iYWxFbGVtZW50cyggWzQsNSw2XSApXCJcbiAgICAgICAgfSksIFwiIGNvbnRhaW5zIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJnbG9iYWxFbGVtMlwiXG4gICAgICAgIH0pLCBcIiwgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcInBGYWNlXCJcbiAgICAgICAgfSksIFwiLCBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwibkZhY2VcIlxuICAgICAgICB9KV1cbiAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcImdsb2JhbEVsZW1lbnRzKCBbNyw4LDldIClcIlxuICAgICAgICB9KSwgXCIgY29udGFpbnMgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcImdsb2JhbEVsZW0zXCJcbiAgICAgICAgfSksIFwiLCBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwicEZhY2VcIlxuICAgICAgICB9KSwgXCIsIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJuRmFjZVwiXG4gICAgICAgIH0pLCBcIi5cIl1cbiAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcInBGYWNlXCJcbiAgICAgICAgfSksIFwiIGlzIHRoZSBsb2NhbCBmYWNldCBudW1iZXIgb2YgcGFyZW50IGVsZW1lbnRcIl1cbiAgICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogW19qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIm5GYWNlXCJcbiAgICAgICAgfSksIFwiIGlzIHRoZSBsb2NhbCBmYWNldCBudW1iZXIgb2YgdGhlIG5laWdoYm9yXCJdXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIkhlcmUsIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwicEZhY2VcIlxuICAgICAgfSksIFwiIGlzIHRoZSBsb2NhbCBmYWNldCBudW1iZXIgb2YgcGFyZW50IGVsZW1lbnQsIChpLmUuLCBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcImdsb2JhbEVsZW0gKGllbGVtKVwiXG4gICAgICB9KSwgXCIpLiBUaGUgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJuRmFjZVwiXG4gICAgICB9KSwgXCIgKGxvY2FsLWZhY2V0LW51bWJlcikgb2YgdGhlIG5laWdoYm9yaW5nIGVsZW1lbnQuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDMsIHtcbiAgICAgIGlkOiBcImJvdW5kYXJ5ZGF0YVwiLFxuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjaGlsZHJlbjogXCJib3VuZGFyeURhdGFcIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJJdCByZXByZXNlbnRzIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYm91bmRhcnkgZWxlbWVudC4gSXQgc2hvdWxkIGJlIHVzZWQgb25seSB3aGVuIHRoZSBlbGVtZW50IGlzIGEgYm91bmRhcnkgZWxlbWVudC5cIlxuICAgICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJJZiBhbiBlbGVtZW50IFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJpZWxcIlxuICAgICAgICB9KSwgXCIgaXMgYSBib3VuZGFyeSBlbGVtZW50LCB0aGVuIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJib3VuZGFyeURhdGFcIlxuICAgICAgICB9KSwgXCIgY29udGFpbnMgdGhlIGxvY2FsIGZhY2V0IG51bWJlcnMgb2YgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcImllbFwiXG4gICAgICAgIH0pLCBcIiB3aGljaCBjb2luY2lkZXMgd2l0aCB0aGUgbWVzaCBib3VuZGFyeS4gSXQgbWF5IGhhcHBlbiB0aGF0IGEgYm91bmRhcnkgZWxlbWVudCBoYXMgbm8gYm91bmRhcnkgZmFjZSAoYnV0IG9ubHkgYSBzaW5nbGUgYm91bmRhcnkgbm9kZSksIGluIHRoaXMgY2FzZSBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiYm91bmRhcnlEYXRhXCJcbiAgICAgICAgfSksIFwiIHdpbGwgaGF2ZSB6ZXJvIHNpemUuXCJdXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFtcIkluIGFkZGl0aW9uIHdlIGhhdmUgZGVmaW5lZCBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhUG9pbnRlcl9cIlxuICAgICAgfSksIFwiIHdoaWNoIGlzIGEgcG9pbnRlciB0byBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX1wiXG4gICAgICB9KSwgXCIgdHlwZS4gVGhlIHBvaW50ZXIgaXMgZGVmaW5lZCBhcyBmb2xsb3dzOlwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJUWVBFIEVsZW1kYXRhUG9pbnRlcl9cXG4gIENMQVNTKEVsZW1kYXRhXyksIFBPSU5URVIgOjogcHRyID0+IE5VTEwoKVxcbkVORCBUWVBFIEVsZW1kYXRhUG9pbnRlcl9cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGF0eXBlXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YVR5cGVcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogW1wiVGhlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFUeXBlX1wiXG4gICAgICB9KSwgXCIgaXMgYSBkZXJpdmVkIHR5cGUgd2hpY2ggY29udGFpbnMgdGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlbGVtZW50IGRhdGEuIFRoZSBzdHJ1Y3R1cmUgb2YgdGhlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFUeXBlX1wiXG4gICAgICB9KSwgXCIgaXMgYXMgZm9sbG93czpcIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiVFlQRSBFbGVtZGF0YVR5cGVfXFxuICBJTlRFR0VSKEk0QikgOjogaW50ZXJuYWwgPSBJTlRFUk5BTF9FTEVNRU5UXFxuICBJTlRFR0VSKEk0QikgOjogYm91bmRhcnkgPSBCT1VOREFSWV9FTEVNRU5UXFxuICBJTlRFR0VSKEk0QikgOjogZG9tYWluQm91bmRhcnkgPSBET01BSU5fQk9VTkRBUllfRUxFTUVOVFxcbiAgSU5URUdFUihJNEIpIDo6IGdob3N0ID0gR0hPU1RfRUxFTUVOVFxcbkVORCBUWVBFIEVsZW1kYXRhVHlwZV9cXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5hZG1vbml0aW9uLCB7XG4gICAgICB0eXBlOiBcImluZm9cIixcbiAgICAgIGNoaWxkcmVuOiBfanN4cyhfY29tcG9uZW50cy5wLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJUaGUgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhVHlwZV9cIlxuICAgICAgICB9KSwgXCIgaXMgcHJpdmF0ZSBidXQgeW91IGNhbiB1c2UgaXRzIGluc3RhbmNlIGNhbGxlZCBcIiwgX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFwiVHlwZUVsZW1cIlxuICAgICAgICB9KSwgXCIuIEZvciBleGFtcGxlIHRvIGdldCB0aGUgZmllbGQgXCIsIF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcImludGVybmFsXCJcbiAgICAgICAgfSksIFwiIHlvdSBzaG91bGQgdXNlIFwiLCBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgICBjaGlsZHJlbjogXCJUeXBlRWxlbSVpbnRlcm5hbFwiXG4gICAgICAgIH0pLCBcIi5cIl1cbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBtb2R1bGUgZXhwb3NlcyBmb2xsb3dpbmcgbWV0aG9kcy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9jb3B5XCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9Db3B5XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJDb3B5IG9iajIgdG8gb2JqMVwiXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiU1VCUk9VVElORSBFbGVtZGF0YV9Db3B5KG9iajEsIG9iajIpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTk9VVCkgOjogb2JqMVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoSU4pIDo6IG9iajJcXG5FTkQgU1VCUk9VVElORVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9kaXNwbGF5XCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9EaXNwbGF5XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJEaXNwbGF5IHRoZSBlbGVtZW50IGRhdGEgaW5mb3JtYXRpb24uXCJcbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJTVUJST1VUSU5FIEVsZW1kYXRhX0Rpc3BsYXkob2JqKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoSU4pIDo6IG9ialxcbkVORCBTVUJST1VUSU5FXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX2VsZW10eXBlMnN0cmluZ1wiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfRWxlbVR5cGUyU3RyaW5nXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJDb252ZXJ0IHRoZSBlbGVtZW50IHR5cGUgdG8gc3RyaW5nLlwiXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiRlVOQ1RJT04gRWxlbWRhdGFfRWxlbVR5cGUyU3RyaW5nKGVsZW1lbnRUeXBlKSBSRVNVTFQoYW5zKVxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU4pIDo6IGVsZW1lbnRUeXBlXFxuICBDSEFSQUNURVIoOiksIEFMTE9DQVRBQkxFIDo6IGFuc1xcbkVORCBGVU5DVElPTlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9kZWFsbG9jYXRlXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9EZWFsbG9jYXRlXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJEZWFsbG9jYXRlIHRoZSBlbGVtZW50IGRhdGEuXCJcbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJTVUJST1VUSU5FIEVsZW1kYXRhX0RlYWxsb2NhdGUob2JqKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoSU5PVVQpIDo6IG9ialxcbkVORCBTVUJST1VUSU5FXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX3NldHRvdGFsbWF0ZXJpYWxcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX1NldFRvdGFsTWF0ZXJpYWxcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy51bCwge1xuICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIlNldCB0aGUgdG90YWwgbnVtYmVyIG9mIG1hdGVyaWFscy5cIlxuICAgICAgfSksIFwiXFxuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlNVQlJPVVRJTkUgRWxlbWRhdGFfU2V0VG90YWxNYXRlcmlhbChvYmosIG4pXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTk9VVCkgOjogb2JqXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTikgOjogblxcbkVORCBTVUJST1VUSU5FXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX3NldFwiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfU2V0XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJTZXQgdGhlIGVsZW1lbnQgZGF0YS5cIlxuICAgICAgfSksIFwiXFxuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlBVUkUgU1VCUk9VVElORSBFbGVtZGF0YV9TZXQob2JqLCBnbG9iYWxFbGVtTnVtLCBsb2NhbEVsZW1OdW0sICZcXG4gICAgICAgIGVsZW1lbnRUeXBlLCBnbG9iYWxOb2RlcywgZ2xvYmFsRWxlbWVudHMsIGJvdW5kYXJ5RGF0YSwgZ2xvYmFsRWRnZXMsICZcXG4gICBnbG9iYWxGYWNlcywgbmFtZSwgdG9wb05hbWUsIGlzQWN0aXZlLCBtZXNoSUQsIG1lZGl1bSwgbWF0ZXJpYWwsIG1hdGVyaWFscylcXG4gICEgb2JqJWVsZW1lbnREYXRhKGlpKSVnbG9iYWxFbGVtTnVtID0gZWxlbU51bWJlcihpaSlcXG4gICEgb2JqJWVsZW1lbnREYXRhKGlpKSVsb2NhbEVsZW1OdW0gPSBpaVxcbiAgISBvYmolZWxlbWVudERhdGEoaWkpJWdsb2JhbE5vZGVzID0gY29ubmVjdGl2aXR5KDosIGlpKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoSU5PVVQpIDo6IG9ialxcbiAgISEgZWxlbWVudCBkYXRhIG9iamVjdFxcbiAgSU5URUdFUihJNEIpLCBPUFRJT05BTCwgSU5URU5UKElOKSA6OiBnbG9iYWxFbGVtTnVtXFxuICAhISBnbG9iYWwgZWxlbWVudCBudW1iZXJcXG4gIElOVEVHRVIoSTRCKSwgT1BUSU9OQUwsIElOVEVOVChJTikgOjogbG9jYWxFbGVtTnVtXFxuICAhISBsb2NhbCBlbGVtZW50IG51bWJlclxcbiAgSU5URUdFUihJNEIpLCBPUFRJT05BTCwgSU5URU5UKElOKSA6OiBlbGVtZW50VHlwZVxcbiAgISEgZWxlbWVudCB0eXBlOiBpbnRlcm5hbCBlbGVtZW50LCBib3VuZGFyeSBlbGVtZW50LCBldGMuXFxuICBJTlRFR0VSKEk0QiksIE9QVElPTkFMLCBJTlRFTlQoSU4pIDo6IGdsb2JhbE5vZGVzKDopXFxuICAhISB2ZXJ0ZXggY29ubmVjdGl2aXR5XFxuICBJTlRFR0VSKEk0QiksIE9QVElPTkFMLCBJTlRFTlQoSU4pIDo6IGdsb2JhbEVsZW1lbnRzKDopXFxuICAhISBlbGVtZW50IHRvIGVsZW1lbnQgbWFwcGluZ1xcbiAgSU5URUdFUihJNEIpLCBPUFRJT05BTCwgSU5URU5UKElOKSA6OiBib3VuZGFyeURhdGEoOilcXG4gICEhIGJvdW5kYXJ5IGRhdGFcXG4gIElOVEVHRVIoSTRCKSwgT1BUSU9OQUwsIElOVEVOVChJTikgOjogZ2xvYmFsRWRnZXMoOilcXG4gICEhIGVkZ2UgY29ubmVjdGl2aXR5XFxuICBJTlRFR0VSKEk0QiksIE9QVElPTkFMLCBJTlRFTlQoSU4pIDo6IGdsb2JhbEZhY2VzKDopXFxuICAhISBnYWNlIGNvbm5lY3Rpdml0eVxcbiAgSU5URUdFUihJNEIpLCBPUFRJT05BTCwgSU5URU5UKElOKSA6OiBuYW1lXFxuICAhISBUeXBlIG9mIGVsZW1lbnQsIHRyaWFuZ2xlLCB0cmlhbmdsZTMsIFF1YWRyYW5nbGU0LCBldGNcXG4gIElOVEVHRVIoSTRCKSwgT1BUSU9OQUwsIElOVEVOVChJTikgOjogdG9wb05hbWVcXG4gICEhIHRvcG9sb2d5ICBuYW1lIG9mIHRoZSBlbGVtZW50XFxuICBMT0dJQ0FMKExHVCksIE9QVElPTkFMLCBJTlRFTlQoSU4pIDo6IGlzQWN0aXZlXFxuICAhISBpcyBlbGVtZW50IGFjdGl2ZVxcbiAgSU5URUdFUihJNEIpLCBPUFRJT05BTCwgSU5URU5UKElOKSA6OiBtZXNoSURcXG4gIElOVEVHRVIoSTRCKSwgT1BUSU9OQUwsIElOVEVOVChJTikgOjogbWVkaXVtXFxuICAhISBtZWRpdW0gaWQgbGlrZSBzb2lsLHdhdGVyLCBldGNcXG4gIElOVEVHRVIoSTRCKSwgT1BUSU9OQUwsIElOVEVOVChJTikgOjogbWF0ZXJpYWxcXG4gICEhIG1hdGVyaWFsIGxpa2Ugc29pbDEsIHNvaWwyLCB3YXRlMSwgd2F0ZXIyLCBldGNcXG4gIElOVEVHRVIoSTRCKSwgT1BUSU9OQUwsIElOVEVOVChJTikgOjogbWF0ZXJpYWxzKDopXFxuICAhISBtYXRlcmlhbHNcXG5FTkQgU1VCUk9VVElORVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9wb2ludGVyXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9Qb2ludGVyXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJDcmVhdGUgYSBwb2ludGVyIHRvIHRoZSBlbGVtZW50IGRhdGEuXCJcbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJGVU5DVElPTiBFbGVtZGF0YV9Qb2ludGVyKCkgUkVTVUxUKGFucylcXG4gIENMQVNTKEVsZW1kYXRhXyksIFBPSU5URVIgOjogYW5zXFxuICBBTExPQ0FURSAoRWxlbWRhdGFfIDo6IGFucylcXG5FTkQgRlVOQ1RJT04gRWxlbWRhdGFfUG9pbnRlclxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9sdFwiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfbHRcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4cyhfY29tcG9uZW50cy51bCwge1xuICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgIGNoaWxkcmVuOiBcIkNvbXBhcmUgdHdvIGVsZW1lbnQgZGF0YSBvYmplY3RzLiBMZXNzIHRoYW4gb3BlcmF0b3IuXCJcbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJGVU5DVElPTiBFbGVtZGF0YV9sdChvYmosIG9iajIpIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqMlxcbiAgTE9HSUNBTChMR1QpIDo6IGFuc1xcbiAgYW5zID0gb2JqJWdsb2JhbEVsZW1OdW0gLkdULiBvYmoyJWdsb2JhbEVsZW1OdW1cXG5FTkQgRlVOQ1RJT04gRWxlbWRhdGFfbHRcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZXFcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX2VxXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJDb21wYXJlIHR3byBlbGVtZW50IGRhdGEgb2JqZWN0cy4gRXF1YWwgb3BlcmF0b3IuXCJcbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJGVU5DVElPTiBFbGVtZGF0YV9lcShvYmosIG9iajIpIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqMlxcbiAgTE9HSUNBTChMR1QpIDo6IGFuc1xcbiAgYW5zID0gb2JqJWdsb2JhbEVsZW1OdW0gLkVRLiBvYmoyJWdsb2JhbEVsZW1OdW1cXG5FTkQgRlVOQ1RJT04gRWxlbWRhdGFfZXFcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfc2V0aWRcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX1NldElEXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJTZXQgdGhlIGVsZW1lbnQgSUQuXCJcbiAgICAgIH0pLCBcIlxcblwiXVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJTVUJST1VUSU5FIEVsZW1kYXRhX1NldElEKG9iaiwgaWQpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTk9VVCkgOjogb2JqXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTikgOjogaWRcXG5FTkQgU1VCUk9VVElORVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXRnbG9iYWxmYWNlY29uXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRHbG9iYWxGYWNlQ29uXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMudWwsIHtcbiAgICAgIGNoaWxkcmVuOiBbXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJHZXQgdGhlIGdsb2JhbCBmYWNlIGNvbm5lY3Rpdml0eS4gUmV0dXJucyB0aGUgdmVydGV4IGNvbm5lY3Rpdml0eSBvZiBnbG9iYWwgZmFjZSBvZiBlbGVtZW50cy5cIlxuICAgICAgfSksIFwiXFxuXCJdXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlNVQlJPVVRJTkUgRWxlbWRhdGFfR2V0R2xvYmFsRmFjZUNvbihvYmosIGdsb2JhbEZhY2VDb24sIGxvY2FsRmFjZUNvbilcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKElOT1VUKSA6OiBvYmpcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKElOT1VUKSA6OiBnbG9iYWxGYWNlQ29uKDosIDopXFxuICBJTlRFR0VSKEk0QiksIE9QVElPTkFMLCBJTlRFTlQoSU5PVVQpIDo6IGxvY2FsRmFjZUNvbig6LCA6KVxcbkVORCBTVUJST1VUSU5FXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX2dldGNvbm5lY3Rpdml0eVwiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfR2V0Q29ubmVjdGl2aXR5XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIHN1YnJvdXRpbmUgcmV0dXJucyB0aGUgY29ubmVjdGl2aXR5IG9mIHRoZSBlbGVtZW50LlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICBjaGlsZHJlbjogW1wiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFwidHNpemUgaXMgdGhlIHNpemUgb2YgZGF0YSB3cml0dGVuIGluIGNvblwiXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5saSwge1xuICAgICAgICBjaGlsZHJlbjogXCJjb24gaXMgdGhlIGNvbm5lY3Rpdml0eSBhcnJheSwgaXQgc2hvdWxkIGJlIGFsbG9jYXRlZFwiXG4gICAgICB9KSwgXCJcXG5cIiwgX2pzeHMoX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgY2hpbGRyZW46IFtcIm9wdCBpcyB0aGUgdHlwZSBvZiBjb25uZWN0aXZpdHksIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhbGxvd2VkXCIsIFwiXFxuXCIsIF9qc3hzKF9jb21wb25lbnRzLnVsLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFtcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmxpLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogXCJcXFwiVlxcXCIgb3IgXFxcInZcXFwiIDogdmVydGV4IGNvbm5lY3Rpdml0eVwiXG4gICAgICAgICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIlxcXCJFXFxcIiBvciBcXFwiZVxcXCIgOiBlZGdlIGNvbm5lY3Rpdml0eVwiXG4gICAgICAgICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIlxcXCJGXFxcIiBvciBcXFwiZlxcXCIgOiBmYWNlIGNvbm5lY3Rpdml0eVwiXG4gICAgICAgICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIlxcXCJDXFxcIiBvciBcXFwiY1xcXCIgOiBjZWxsIGNvbm5lY3Rpdml0eVwiXG4gICAgICAgICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMubGksIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBcIlxcXCJBXFxcIiBvciBcXFwiYVxcXCIgOiBhbGwgY29ubmVjdGl2aXR5XCJcbiAgICAgICAgICB9KSwgXCJcXG5cIl1cbiAgICAgICAgfSksIFwiXFxuXCJdXG4gICAgICB9KSwgXCJcXG5cIl1cbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiU1VCUk9VVElORSBFbGVtZGF0YV9HZXRDb25uZWN0aXZpdHkob2JqLCBjb24sIHRzaXplLCBvcHQpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTk9VVCkgOjogY29uKDopXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChPVVQpIDo6IHRzaXplXFxuICBDSEFSQUNURVIoKiksIElOVEVOVChJTiksIE9QVElPTkFMIDo6IG9wdFxcbkVORCBTVUJST1VUSU5FXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX2dldGNvbm5lY3Rpdml0eTJcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldENvbm5lY3Rpdml0eTJcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgc3Vicm91dGluZSByZXR1cm5zIHRoZSBjb25uZWN0aXZpdHkgb2YgdGhlIGVsZW1lbnQuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiU1VCUk9VVElORSBFbGVtZGF0YV9HZXRDb25uZWN0aXZpdHkyKG9iaiwgY2VsbENvbiwgZmFjZUNvbiwgZWRnZUNvbiwgbm9kZUNvbiwgJlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Q2VsbENvbiwgdEZhY2VDb24sIHRFZGdlQ29uLCB0Tm9kZUNvbilcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKElOKSA6OiBvYmpcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKElOT1VUKSA6OiBjZWxsQ29uKDopXFxuICAhISBjZWxsIGNvbm5lY3Rpdml0eVxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU5PVVQpIDo6IGZhY2VDb24oOilcXG4gICEhIGZhY2UgY29ubmVjdGl2aXR5XFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTk9VVCkgOjogZWRnZUNvbig6KVxcbiAgISEgZWRnZSBjb25uZWN0aXZpdHlcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKElOT1VUKSA6OiBub2RlQ29uKDopXFxuICAhISBub2RlIGNvbm5lY3Rpdml0eVxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoT1VUKSA6OiB0Q2VsbENvblxcbiAgISEgdG90YWwgZGF0YSB3cml0dGVuIGluIGNlbGxDb25cXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKE9VVCkgOjogdEZhY2VDb25cXG4gICEhIHRvdGFsIGRhdGEgd3JpdHRlbiBpbiBmYWNlQ29uXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChPVVQpIDo6IHRFZGdlQ29uXFxuICAhISB0b3RhbCBkYXRhIHdyaXR0ZW4gaW4gZWRnZUNvblxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoT1VUKSA6OiB0Tm9kZUNvblxcbiAgISEgdG90YWwgZGF0YSB3cml0dGVuIGluIG5vZGVDb25cXG5FTkQgU1VCUk9VVElORVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXR0b3RhbGVudGl0aWVzXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRUb3RhbEVudGl0aWVzXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiB2ZXJ0ZXgsIGVkZ2UsIGZhY2UgYW5kIGNlbGwgZW50aXRpZXMgaW4gdGhlIGVsZW1lbnQuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiRlVOQ1RJT04gRWxlbWRhdGFfR2V0VG90YWxFbnRpdGllcyhvYmopIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChpbikgOjogb2JqXFxuICBJTlRFR0VSKEk0QikgOjogYW5zKDQpXFxuICBhbnMoMSkgPSBTSVpFKG9iaiVnbG9iYWxOb2RlcylcXG4gIGFucygyKSA9IFNJWkUob2JqJWdsb2JhbEVkZ2VzKVxcbiAgYW5zKDMpID0gU0laRShvYmolZ2xvYmFsRmFjZXMpXFxuICBhbnMoNCkgPSAxXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX0dldFRvdGFsRW50aXRpZXNcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0dmVydGV4XCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRWZXJ0ZXhcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgZ2xvYmFsIHZlcnRleCBudW1iZXIgb2YgYSBnaXZlbiBsb2NhbCB2ZXJ0ZXggbnVtYmVyLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkZVTkNUSU9OIEVsZW1kYXRhX0dldFZlcnRleChvYmosIGlpKSBSRVNVTFQoYW5zKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoaW4pIDo6IG9ialxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoaW4pIDo6IGlpXFxuICAhISBsb2NhbCB2ZXJ0ZXggbnVtYmVyXFxuICBJTlRFR0VSKEk0QikgOjogYW5zXFxuICAhISBnbG9iYWwgdmVydGV4IG51bWJlclxcbiAgXFxuICBhbnMgPSBvYmolZ2xvYmFsTm9kZXMoaWkpXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX0dldFZlcnRleFxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXRlZGdlXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRFZGdlXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGdsb2JhbCBlZGdlIG51bWJlciBvZiBhIGdpdmVuIGxvY2FsIGVkZ2UgbnVtYmVyLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkZVTkNUSU9OIEVsZW1kYXRhX0dldEVkZ2Uob2JqLCBpaSkgUkVTVUxUKGFucylcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKGluKSA6OiBvYmpcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKGluKSA6OiBpaVxcbiAgISEgbG9jYWwgZWRnZSBudW1iZXJcXG4gIElOVEVHRVIoSTRCKSA6OiBhbnNcXG4gICEhIGdsb2JhbCBlZGdlIG51bWJlclxcbiAgYW5zID0gb2JqJWdsb2JhbEVkZ2VzKGlpKVxcbkVORCBGVU5DVElPTiBFbGVtZGF0YV9HZXRFZGdlXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX2dldGZhY2VcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldEZhY2VcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgZ2xvYmFsIGZhY2UgbnVtYmVyIG9mIGEgZ2l2ZW4gbG9jYWwgZmFjZSBudW1iZXIuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiRlVOQ1RJT04gRWxlbWRhdGFfR2V0RmFjZShvYmosIGlpKSBSRVNVTFQoYW5zKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoaW4pIDo6IG9ialxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoaW4pIDo6IGlpXFxuICAhISBsb2NhbCBmYWNlIG51bWJlclxcbiAgSU5URUdFUihJNEIpIDo6IGFuc1xcbiAgISEgZ2xvYmFsIGZhY2UgbnVtYmVyXFxuICBhbnMgPSBvYmolZ2xvYmFsRmFjZXMoaWkpXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX0dldEZhY2VcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0Y2VsbFwiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfR2V0Q2VsbFwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBnbG9iYWwgb3IgbG9jYWwgY2VsbCBudW1iZXIgb2YgdGhlIGVsZW1lbnQuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiRlVOQ1RJT04gRWxlbWRhdGFfR2V0Q2VsbChvYmosIGlzbG9jYWwpIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChpbikgOjogb2JqXFxuICBMT0dJQ0FMKExHVCksIElOVEVOVChpbikgOjogaXNsb2NhbFxcbiAgISEgSWYgdHJ1ZSB0aGVuIGxvY2FsIGNlbGwgbnVtYmVyIGlzIHJldHVybmVkXFxuICBJTlRFR0VSKEk0QikgOjogYW5zXFxuICAhISBnbG9iYWwgb3IgbG9jYWwgZWxlbWVudCBudW1iZXIgKGNlbGwgbnVtYmVyKVxcblxcbiAgSUYgKGlzbG9jYWwpIFRIRU5cXG4gICAgYW5zID0gb2JqJWxvY2FsRWxlbU51bVxcbiAgRUxTRVxcbiAgICBhbnMgPSBvYmolZ2xvYmFsRWxlbU51bVxcbiAgRU5EIElGXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX0dldENlbGxcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0dG90YWxlZGdlZG9mXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRUb3RhbEVkZ2VET0ZcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGVkZ2UgZG9mIG9uIHRoZSBlZGdlIG9mIGFuIGVsZW1lbnQuIEl0IGRvZXMgbm90IHJldHVybiB0aGUgZWRnZSBkb2Ygb24gdGhlIGJvdW5kYXJ5IG9mIHRoZSBlbGVtZW50LlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkZVTkNUSU9OIEVsZW1kYXRhX0dldFRvdGFsRWRnZURPRihvYmosIGlpLCBvcmRlciwgYmFzZUNvbnRpbnVpdHksICZcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUludGVycG9sYXRpb24pIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChpbikgOjogb2JqXFxuICAhISBFbGVtZW50IGRhdGEgb2JqZWN0XFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTikgOjogaWlcXG4gICEhIExvY2FsIGVkZ2UgbnVtYmVyXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTikgOjogb3JkZXJcXG4gICEhIE9yZGVyIG9uIHRoZSBlZGdlXFxuICBDSEFSQUNURVIoKiksIElOVEVOVChJTikgOjogYmFzZUNvbnRpbnVpdHlcXG4gICEhIGJhc2UgY29udGludWl0eTogSDEsIEhEaXYsIEhDdXJsXFxuICBDSEFSQUNURVIoKiksIElOVEVOVChJTikgOjogYmFzZUludGVycG9sYXRpb25cXG4gICEhIGJhc2UgaW50ZXJwb2xhdGlvbiB0eXBlXFxuICBJTlRFR0VSKEk0QikgOjogYW5zXFxuICAhISBUb3RhbCBudW1iZXIgb2YgZG9mIG9uIGVkZ2VcXG4gIGFucyA9IE1BWChvcmRlciAtIDIsIDBfSTRCKVxcbkVORCBGVU5DVElPTiBFbGVtZGF0YV9HZXRUb3RhbEVkZ2VET0ZcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0dG90YWxmYWNlZG9mXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRUb3RhbEZhY2VET0ZcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGZhY2UgZG9mcyBvbiB0aGUgZmFjZSBvZiBhbiBlbGVtZW50LlxcbkFsbCBkb2ZzIGFyZSBpbnRlcm5hbCB0byBmYWNlLCB0aGF0IGlzIGVkZ2UgYW5kIHZlcnRleCBkb2YgYXJlIG5vdCBpbmNsdWRlZC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJGVU5DVElPTiBFbGVtZGF0YV9HZXRUb3RhbEZhY2VET0Yob2JqLCBpaSwgb3JkZXIsIGJhc2VDb250aW51aXR5LCAmXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VJbnRlcnBvbGF0aW9uKSBSRVNVTFQoYW5zKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoaW4pIDo6IG9ialxcbiAgISEgRWxlbWVudCBkYXRhIG9iamVjdFxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU4pIDo6IGlpXFxuICAhISBMb2NhbCBmYWNlIG51bWJlclxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU4pIDo6IG9yZGVyXFxuICAhISBPcmRlciBvbiB0aGUgZWRnZVxcbiAgQ0hBUkFDVEVSKCopLCBJTlRFTlQoSU4pIDo6IGJhc2VDb250aW51aXR5XFxuICAhISBiYXNlIGNvbnRpbnVpdHk6IEgxLCBIRGl2LCBIQ3VybFxcbiAgQ0hBUkFDVEVSKCopLCBJTlRFTlQoSU4pIDo6IGJhc2VJbnRlcnBvbGF0aW9uXFxuICAhISBiYXNlIGludGVycG9sYXRpb24gdHlwZVxcbiAgSU5URUdFUihJNEIpIDo6IGFuc1xcbiAgISEgVG90YWwgbnVtYmVyIG9mIGRvZiBvbiBlZGdlXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX0dldFRvdGFsRmFjZURPRlxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXR0b3RhbGNlbGxkb2ZcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldFRvdGFsQ2VsbERPRlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgY2VsbCBkb2ZzIG9uIHRoZSBjZWxsIG9mIGFuIGVsZW1lbnQuIEFsbCBkb2ZzIGFyZSBpbnRlcm5hbCB0byBjZWxsLCB0aGF0IGlzIGVkZ2UgYW5kIHZlcnRleCBkb2YgYXJlIG5vdCBpbmNsdWRlZC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJGVU5DVElPTiBFbGVtZGF0YV9HZXRUb3RhbENlbGxET0Yob2JqLCBvcmRlciwgYmFzZUNvbnRpbnVpdHksICZcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUludGVycG9sYXRpb24pIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChpbikgOjogb2JqXFxuICAhISBFbGVtZW50IGRhdGEgb2JqZWN0XFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTikgOjogb3JkZXJcXG4gICEhIE9yZGVyIG9uIHRoZSBlZGdlXFxuICBDSEFSQUNURVIoKiksIElOVEVOVChJTikgOjogYmFzZUNvbnRpbnVpdHlcXG4gICEhIGJhc2UgY29udGludWl0eTogSDEsIEhEaXYsIEhDdXJsXFxuICBDSEFSQUNURVIoKiksIElOVEVOVChJTikgOjogYmFzZUludGVycG9sYXRpb25cXG4gICEhIGJhc2UgaW50ZXJwb2xhdGlvbiB0eXBlXFxuICBJTlRFR0VSKEk0QikgOjogYW5zXFxuICAhISBUb3RhbCBudW1iZXIgb2YgZG9mIG9uIGVkZ2VcXG5FTkQgRlVOQ1RJT04gRWxlbWRhdGFfR2V0VG90YWxDZWxsRE9GXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX2dldGVsZW1lbnR0b2VsZW1lbnRzMVwiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfR2V0RWxlbWVudFRvRWxlbWVudHMxXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIHN1YnJvdXRpbmUgcmV0dXJucyB0aGUgZ2xvYmFsIGVsZW1lbnQgbnVtYmVyIG9mIGVsZW1lbnRzIHdoaWNoIHN1cnJvdW5kcyB0aGUgZWxlbWVudC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJTVUJST1VUSU5FIEVsZW1kYXRhX0dldEVsZW1lbnRUb0VsZW1lbnRzMShvYmosIGFucywgdHNpemUpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTk9VVCkgOjogYW5zKDopXFxuICAhISBFbGVtZW50IHRvIGVsZW1lbnQsIGl0IHNob3VsZCBiZSBhbGxvY2F0ZWQgYnkgdXNlciBiZWZvcmUgY2FsbGluZ1xcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoT1VUKSA6OiB0c2l6ZVxcbiAgISEgVGhlIHNpemUgb2YgZGF0YSB3cml0dGVuIHRvIGFuc1xcbkVORCBTVUJST1VUSU5FIEVsZW1kYXRhX0dldEVsZW1lbnRUb0VsZW1lbnRzMVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXRlbGVtZW50dG9lbGVtZW50czJcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldEVsZW1lbnRUb0VsZW1lbnRzMlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiR2V0IHRoZSBlbGVtZW50IHRvIGVsZW1lbnQgbWFwcGluZyBpbmNsdWRpbmcgdGhlIGxvY2FsIGZhY2UgbnVtYmVyIG9mIHRoZSBlbGVtZW50IGFuZCBpdHMgbmVpZ2hib3IuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiU1VCUk9VVElORSBFbGVtZGF0YV9HZXRFbGVtZW50VG9FbGVtZW50czIob2JqLCBhbnMsIG5yb3csIG5jb2wsICZcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlQm91bmRhcnlFbGVtZW50KVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoSU4pIDo6IG9ialxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU5PVVQpIDo6IGFucyg6LCA6KVxcbiAgISEgRWxlbWVudCB0byBlbGVtZW50LCBpdCBzaG91bGQgYmUgYWxsb2NhdGVkIGJ5IHVzZXIgYmVmb3JlIGNhbGxpbmdcXG4gICEhIGVhY2ggcm93IGRlbm90ZXMgdGhlIGluZm9ybWF0aW9uIG9mIGEgbmVpZ2hib3IgZWxlbWVudC5cXG4gICEhIFRoZXJlZm9yZSBucm93IGlzIHRoZSB0b3RhbCBudW1iZXIgb2YgbmVpZ2hib3JpbmcgZWxlbWVudHNcXG4gICEhIG51bWJlciBvZiBjb2x1bW5zIGlzIDMuIFxcbiAgISEgVGhlIGZpcnN0IGNvbHVtbiBpcyBnbG9iYWwgZWxlbWVudCBvZiB0aGUgbmVpZ2hib3IgZWxlbWVudFxcbiAgISEgVGhlIHNlY29uZCBjb2x1bW4gaXMgbG9jYWwgZmFjZSBudW1iZXIgb2YgcGFyZW50IGVsZW1lbnQgKHRoaXMgZWxlbWVudClcXG4gICEhIFRoZSB0aGlyZCBjb2x1bW4gaXMgbG9jYWwgZmFjZSBudW1iZXIgb2YgbmVpZ2hib3IgZWxlbWVudFxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoT1VUKSA6OiBucm93XFxuICAhISBOdW1iZXIgb2Ygcm93cyB3cml0dGVuIHRvIGFuc1xcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoT1VUKSA6OiBuY29sXFxuICAhISBOdW1iZXIgb2YgY29sdW1ucyB3cml0dGVuIHRvIGFuc1xcbiAgTE9HSUNBTChMR1QpLCBPUFRJT05BTCwgSU5URU5UKElOKSA6OiBpbmNsdWRlQm91bmRhcnlFbGVtZW50XFxuICAhISBJZiBpbmNsdWRlQm91bmRhcnlFbGVtZW50IGlzIHByZXNlbnQgYW5kIHRydWUsIFxcbiAgISEgdGhlbiB0aGUgYm91bmRhcnkgZWxlbWVudCBkYXRhIGlzIGluY2x1ZGVkIGluIGFuc1xcbiAgISEgSW4gdGhpcyBjYXNlIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgY29uc2lkZXJlZCBhcyB0aGUgYm91bmRhcnkgZWxlbWVudFxcbiAgISEgYW5zKG5yb3csIDEpIGNvbnRhaW5zIHRoZSBnbG9iYWwgZWxlbWVudCBudW1iZXIgb2YgdGhlIGN1cnJlbnQgZWxlbWVudFxcbiAgISEgYW5zKG5yb3csIDIpIGNvbnRhaW5zIHRoZSBib3VuZGFyeSBkYXRhIChsb2NhbCBmYWNlIG51bWJlciB3aGljaCBjb2luY2lkZXMgd2l0aFxcbiAgISEgdGhlIG1lc2ggYm91bmRhcnkpXFxuICAhISBhbnMobnJvdywgMykgaXMgc2V0IHRvIDBcXG5FTkQgU1VCUk9VVElORSBFbGVtZGF0YV9HZXRFbGVtZW50VG9FbGVtZW50czJcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0ZWRnZWNvbm5lY3Rpdml0eVwiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfR2V0RWRnZUNvbm5lY3Rpdml0eVwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiR2V0IHRoZSBjb25uZWN0aXZpdHkgb2YgdGhlIGxvY2FsIGVkZ2UuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiU1VCUk9VVElORSBFbGVtZGF0YV9HZXRFZGdlQ29ubmVjdGl2aXR5KG9iaiwgYW5zLCB0c2l6ZSwgaWkpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICAhISBFbGVtZW50IGRhdGEgb2JqZWN0XFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTk9VVCkgOjogYW5zKDopXFxuICAhISBlZGdlIGNvbm5lY3Rpdml0eSwgbm9kZSBudW1iZXJzIGFyZSBnbG9iYWxcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKE9VVCkgOjogdHNpemVcXG4gICEhIHRvdGFsIGRhdGEgd3JpdHRlbiB0byBhbnNcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKElOKSA6OiBpaVxcbiAgISEgRWRnZSBudW1iZXIgKGxvY2FsKVxcbkVORCBTVUJST1VUSU5FXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX2lzYWN0aXZlXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9pc0FjdGl2ZVwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBmdW5jdGlvbiByZXR1cm4gdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBhY3RpdmUsIGZhbHNlIG90aGVyd2lzZS5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQVVJFIEZVTkNUSU9OIEVsZW1kYXRhX2lzQWN0aXZlKG9iaikgUkVTVUxUKGFucylcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKElOKSA6OiBvYmpcXG4gIExPR0lDQUwoTEdUKSA6OiBhbnNcXG4gIGFucyA9IG9iaiVpc0FjdGl2ZVxcbkVORCBGVU5DVElPTiBFbGVtZGF0YV9pc0FjdGl2ZVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nbG9iYWxlbGVtbnVtXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9nbG9iYWxFbGVtTnVtXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGdsb2JhbCBlbGVtZW50IG51bWJlciBvZiB0aGUgZWxlbWVudC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQVVJFIEZVTkNUSU9OIEVsZW1kYXRhX2dsb2JhbEVsZW1OdW0ob2JqKSBSRVNVTFQoYW5zKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoSU4pIDo6IG9ialxcbiAgSU5URUdFUihJNEIpIDo6IGFuc1xcbiAgYW5zID0gb2JqJWdsb2JhbEVsZW1OdW1cXG5FTkQgRlVOQ1RJT04gRWxlbWRhdGFfZ2xvYmFsRWxlbU51bVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9sb2NhbGVsZW1udW1cIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX2xvY2FsRWxlbU51bVwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBsb2NhbCBlbGVtZW50IG51bWJlciBvZiB0aGUgZWxlbWVudC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQVVJFIEZVTkNUSU9OIEVsZW1kYXRhX2xvY2FsRWxlbU51bShvYmopIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICBJTlRFR0VSKEk0QikgOjogYW5zXFxuICBhbnMgPSBvYmolbG9jYWxFbGVtTnVtXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX2xvY2FsRWxlbU51bVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9uYW1lXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9uYW1lXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFVSRSBGVU5DVElPTiBFbGVtZGF0YV9uYW1lKG9iaikgUkVTVUxUKGFucylcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKElOKSA6OiBvYmpcXG4gIElOVEVHRVIoSTRCKSA6OiBhbnNcXG4gIGFucyA9IG9iaiVuYW1lXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX25hbWVcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfdG9wb25hbWVcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX3RvcG9OYW1lXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRvcG9sb2d5IG5hbWUgb2YgdGhlIGVsZW1lbnQuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFVSRSBGVU5DVElPTiBFbGVtZGF0YV90b3BvTmFtZShvYmopIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICBJTlRFR0VSKEk0QikgOjogYW5zXFxuICBhbnMgPSBvYmoldG9wb05hbWVcXG5FTkQgRlVOQ1RJT04gRWxlbWRhdGFfdG9wb05hbWVcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfdG9wb2luZHhcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX3RvcG9JbmR4XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRvcG9sb2d5IGluZGV4IG9mIHRoZSBlbGVtZW50LlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlBVUkUgRlVOQ1RJT04gRWxlbWRhdGFfdG9wb0luZHgob2JqKSBSRVNVTFQoYW5zKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoSU4pIDo6IG9ialxcbiAgSU5URUdFUihJNEIpIDo6IGFuc1xcbiAgYW5zID0gR2V0RWxlbWVudEluZGV4KG9iaiV0b3BvTmFtZSlcXG5FTkQgRlVOQ1RJT04gRWxlbWRhdGFfdG9wb0luZHhcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfbWVzaGlkXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9tZXNoaWRcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgbWVzaCBpZCBvZiB0aGUgZWxlbWVudC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQVVJFIEZVTkNUSU9OIEVsZW1kYXRhX21lc2hpZChvYmopIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICBJTlRFR0VSKEk0QikgOjogYW5zXFxuICBhbnMgPSBvYmolbWVzaGlkXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX21lc2hpZFxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXR0b3RhbG1hdGVyaWFsXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRUb3RhbE1hdGVyaWFsXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBtYXRlcmlhbHMgaW4gdGhlIGVsZW1lbnQgKHRoYXQgaXMgbWF0ZXJpYWwgYXNzaWduZWQgdGhlIGVsZW1lbnQpLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlBVUkUgRlVOQ1RJT04gRWxlbWRhdGFfR2V0VG90YWxNYXRlcmlhbChvYmopIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICBJTlRFR0VSKEk0QikgOjogYW5zXFxuICBhbnMgPSBTSVpFKG9iaiVtYXRlcmlhbClcXG5FTkQgRlVOQ1RJT04gRWxlbWRhdGFfR2V0VG90YWxNYXRlcmlhbFxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXR0b3RhbGdsb2JhbG5vZGVzXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRUb3RhbEdsb2JhbE5vZGVzXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBnbG9iYWwgbm9kZXMgaW4gdGhlIGVsZW1lbnQuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFVSRSBGVU5DVElPTiBFbGVtZGF0YV9HZXRUb3RhbEdsb2JhbE5vZGVzKG9iaikgUkVTVUxUKGFucylcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKElOKSA6OiBvYmpcXG4gIElOVEVHRVIoSTRCKSA6OiBhbnNcXG4gIGFucyA9IFNJWkUob2JqJWdsb2JhbE5vZGVzKVxcbkVORCBGVU5DVElPTiBFbGVtZGF0YV9HZXRUb3RhbEdsb2JhbE5vZGVzXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX2dldHRvdGFsZ2xvYmFsZWRnZXNcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldFRvdGFsR2xvYmFsRWRnZXNcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGdsb2JhbCBlZGdlcyBpbiB0aGUgZWxlbWVudC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQVVJFIEZVTkNUSU9OIEVsZW1kYXRhX0dldFRvdGFsR2xvYmFsRWRnZXMob2JqKSBSRVNVTFQoYW5zKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoSU4pIDo6IG9ialxcbiAgSU5URUdFUihJNEIpIDo6IGFuc1xcbiAgYW5zID0gU0laRShvYmolZ2xvYmFsRWRnZXMpXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX0dldFRvdGFsR2xvYmFsRWRnZXNcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0dG90YWxlZGdlb3JpZW50XCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRUb3RhbEVkZ2VPcmllbnRcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgc2l6ZSBvZiBlZGdlT3JpZW50IGFycmF5LlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlBVUkUgRlVOQ1RJT04gRWxlbWRhdGFfR2V0VG90YWxFZGdlT3JpZW50KG9iaikgUkVTVUxUKGFucylcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKElOKSA6OiBvYmpcXG4gIElOVEVHRVIoSTRCKSA6OiBhbnNcXG4gIGFucyA9IFNJWkUob2JqJWVkZ2VPcmllbnQpXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX0dldFRvdGFsRWRnZU9yaWVudFxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXR0b3RhbGdsb2JhbGZhY2VzXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRUb3RhbEdsb2JhbEZhY2VzXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHNpemUgb2YgZ2xvYmFsRmFjZXMgYXJyYXkuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0dG90YWxmYWNlb3JpZW50XCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRUb3RhbEZhY2VPcmllbnRcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgc2l6ZSBvZiBmYWNlT3JpZW50IGFycmF5LlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX2dldHRvdGFsZ2xvYmFsZWxlbWVudHNcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldFRvdGFsR2xvYmFsRWxlbWVudHNcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgc2l6ZSBvZiBnbG9iYWxFbGVtZW50cyBhcnJheS5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXR0b3RhbGJvdW5kYXJ5ZGF0YVwiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfR2V0VG90YWxCb3VuZGFyeURhdGFcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgc2l6ZSBvZiBib3VuZGFyeURhdGEgYXJyYXkuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0bWF0ZXJpYWxcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldE1hdGVyaWFsXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIHN1YnJvdXRpbmUgcmV0dXJucyB0aGUgbWF0ZXJpYWxzIGFzc2lnbmVkIHRvIHRoZSBlbGVtZW50LlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlBVUkUgU1VCUk9VVElORSBFbGVtZGF0YV9HZXRNYXRlcmlhbChvYmosIGFucywgdHNpemUpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChpbikgOjogb2JqXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTk9VVCkgOjogYW5zKDopXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChPVVQpIDo6IHRzaXplXFxuRU5EIFNVQlJPVVRJTkUgRWxlbWRhdGFfR2V0TWF0ZXJpYWxcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0Z2xvYmFsbm9kZXNcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldEdsb2JhbE5vZGVzXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIHN1YnJvdXRpbmUgcmV0dXJucyB0aGUgbGlzdCBvZiBnbG9iYWwgbm9kZXMgaW4gdGhlIGVsZW1lbnQuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFVSRSBTVUJST1VUSU5FIEVsZW1kYXRhX0dldEdsb2JhbE5vZGVzKG9iaiwgYW5zLCB0c2l6ZSlcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKGluKSA6OiBvYmpcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKElOT1VUKSA6OiBhbnMoOilcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKE9VVCkgOjogdHNpemVcXG5FTkQgU1VCUk9VVElORSBFbGVtZGF0YV9HZXRHbG9iYWxOb2Rlc1xcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXRnbG9iYWxlZGdlc1wiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfR2V0R2xvYmFsRWRnZXNcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgc3Vicm91dGluZSByZXR1cm5zIHRoZSBsaXN0IG9mIGdsb2JhbCBlZGdlcyBpbiB0aGUgZWxlbWVudC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQVVJFIFNVQlJPVVRJTkUgRWxlbWRhdGFfR2V0R2xvYmFsRWRnZXMob2JqLCBhbnMsIHRzaXplKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoaW4pIDo6IG9ialxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU5PVVQpIDo6IGFucyg6KVxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoT1VUKSA6OiB0c2l6ZVxcbkVORCBTVUJST1VUSU5FIEVsZW1kYXRhX0dldEdsb2JhbEVkZ2VzXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX2dldGdsb2JhbGZhY2VzXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRHbG9iYWxGYWNlc1wiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBzdWJyb3V0aW5lIHJldHVybnMgdGhlIGxpc3Qgb2YgZ2xvYmFsIGZhY2VzIGluIHRoZSBlbGVtZW50LlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlBVUkUgU1VCUk9VVElORSBFbGVtZGF0YV9HZXRHbG9iYWxGYWNlcyhvYmosIGFucywgdHNpemUpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChpbikgOjogb2JqXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTk9VVCkgOjogYW5zKDopXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChPVVQpIDo6IHRzaXplXFxuRU5EIFNVQlJPVVRJTkUgRWxlbWRhdGFfR2V0R2xvYmFsRmFjZXNcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0Z2xvYmFsZmFjZW51bWJlclwiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfR2V0R2xvYmFsRmFjZU51bWJlclwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBnbG9iYWwgZmFjZSBudW1iZXIgZnJvbSBhIGxvY2FsIGZhY2UgbnVtYmVyLlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlBVUkUgRlVOQ1RJT04gRWxlbWRhdGFfR2V0R2xvYmFsRmFjZU51bWJlcihvYmosIGxvY2FsRmFjZU51bWJlcikgUkVTVUxUKGFucylcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKElOKSA6OiBvYmpcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKElOKSA6OiBsb2NhbEZhY2VOdW1iZXJcXG4gICEhIGxvY2FsIGZhY2UgbnVtYmVyXFxuICBJTlRFR0VSKEk0QikgOjogYW5zXFxuICAhISBnbG9iYWwgZmFjZSBudW1iZXJcXG5FTkQgRlVOQ1RJT04gRWxlbWRhdGFfR2V0R2xvYmFsRmFjZU51bWJlclxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXRnbG9iYWxlZGdlbnVtYmVyXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRHbG9iYWxFZGdlTnVtYmVyXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGdsb2JhbCBlZGdlIG51bWJlciBmcm9tIGEgbG9jYWwgZWRnZSBudW1iZXIuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFVSRSBGVU5DVElPTiBFbGVtZGF0YV9HZXRHbG9iYWxFZGdlTnVtYmVyKG9iaiwgbG9jYWxFZGdlTnVtYmVyKSBSRVNVTFQoYW5zKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoSU4pIDo6IG9ialxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU4pIDo6IGxvY2FsRWRnZU51bWJlclxcbiAgISEgbG9jYWwgZWRnZSBudW1iZXJcXG4gIElOVEVHRVIoSTRCKSA6OiBhbnNcXG4gICEhIGdsb2JhbCBlZGdlIG51bWJlclxcbkVORCBGVU5DVElPTiBFbGVtZGF0YV9HZXRHbG9iYWxFZGdlTnVtYmVyXFxuXCJcbiAgICAgIH0pXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMuaDIsIHtcbiAgICAgIGlkOiBcImVsZW1kYXRhX2dldGdsb2JhbGVsZW1lbnRzXCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRHbG9iYWxFbGVtZW50c1wiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBzdWJyb3V0aW5lIHJldHVybnMgdGhlIGxpc3Qgb2YgZ2xvYmFsRWxlbWVudHMgaW4gdGhlIGVsZW1lbnQuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFVSRSBTVUJST1VUSU5FIEVsZW1kYXRhX0dldEdsb2JhbEVsZW1lbnRzKG9iaiwgYW5zLCB0c2l6ZSlcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKGluKSA6OiBvYmpcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKElOT1VUKSA6OiBhbnMoOilcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKE9VVCkgOjogdHNpemVcXG5FTkQgU1VCUk9VVElORSBFbGVtZGF0YV9HZXRHbG9iYWxFbGVtZW50c1xcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmFkbW9uaXRpb24sIHtcbiAgICAgIHR5cGU6IFwibm90ZVwiLFxuICAgICAgY2hpbGRyZW46IF9qc3hzKF9jb21wb25lbnRzLnAsIHtcbiAgICAgICAgY2hpbGRyZW46IFtcIlRoaXMgcm91dGluZSByZXR1cm5zIGFsbCB0aGUgZW50cmllcyBvZiBnbG9iYWxFbGVtZW50cywgc28geW91IHNob3VsZCBsb29rIGF0IHRoZSBtZWFuaW5nIG9mIGdsb2JhbEVsZW1lbnRzIGluIHRoZSBcIiwgX2pzeChfY29tcG9uZW50cy5hLCB7XG4gICAgICAgICAgaHJlZjogXCIjc3RydWN0dXJlXCIsXG4gICAgICAgICAgY2hpbGRyZW46IFwiU3RydWN0dXJlXCJcbiAgICAgICAgfSksIFwiIHNlY3Rpb24uXCJdXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXRib3VuZGFyeWRhdGFcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldEJvdW5kYXJ5RGF0YVwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBzdWJyb3V0aW5lIHJldHVybnMgdGhlIGxpc3Qgb2YgYm91bmRhcnlEYXRhIGluIHRoZSBlbGVtZW50LlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlBVUkUgU1VCUk9VVElORSBFbGVtZGF0YV9HZXRCb3VuZGFyeURhdGEob2JqLCBhbnMsIHRzaXplKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoaW4pIDo6IG9ialxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU5PVVQpIDo6IGFucyg6KVxcbiAgISEgYm91bmRhcnkgZGF0YSwgc2VlIHRoZSBib3VuZGFyeURhdGEgaW4gdGhlIHR5cGUgZGVmaW5pdGlvblxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoT1VUKSA6OiB0c2l6ZVxcbkVORCBTVUJST1VUSU5FIEVsZW1kYXRhX0dldEJvdW5kYXJ5RGF0YVxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXRnbG9iYWxub2Rlc3BvaW50ZXJcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldEdsb2JhbE5vZGVzUG9pbnRlclwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucCwge1xuICAgICAgY2hpbGRyZW46IFwiVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBwb2ludGVyIHRvIHRoZSBnbG9iYWxOb2RlcyBpbiB0aGUgZWxlbWVudC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJGVU5DVElPTiBFbGVtZGF0YV9HZXRHbG9iYWxOb2Rlc1BvaW50ZXIob2JqKSBSRVNVTFQoYW5zKVxcbiAgVFlQRShFbGVtZGF0YV8pLCBUQVJHRVQsIElOVEVOVChJTikgOjogb2JqXFxuICBJTlRFR0VSKEk0QiksIFBPSU5URVIgOjogYW5zKDopXFxuICBhbnMgPT4gb2JqJWdsb2JhbE5vZGVzXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX0dldEdsb2JhbE5vZGVzUG9pbnRlclxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXRlZGdlb3JpZW50XCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRFZGdlT3JpZW50XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIHN1YnJvdXRpbmUgcmV0dXJucyB0aGUgbGlzdCBvZiBlZGdlT3JpZW50IHZlY3RvciBpbiB0aGUgZWxlbWVudC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQVVJFIFNVQlJPVVRJTkUgRWxlbWRhdGFfR2V0RWRnZU9yaWVudChvYmosIGFucywgdHNpemUpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChpbikgOjogb2JqXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTk9VVCkgOjogYW5zKDopXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChPVVQpIDo6IHRzaXplXFxuRU5EIFNVQlJPVVRJTkUgRWxlbWRhdGFfR2V0RWRnZU9yaWVudFxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9nZXRmYWNlb3JpZW50XCIsXG4gICAgICBjaGlsZHJlbjogXCJFbGVtZGF0YV9HZXRGYWNlT3JpZW50XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIHN1YnJvdXRpbmUgcmV0dXJucyB0aGUgbGlzdCBvZiBmYWNlT3JpZW50IHZlY3RvciBpbiB0aGUgZWxlbWVudC5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJQVVJFIFNVQlJPVVRJTkUgRWxlbWRhdGFfR2V0RmFjZU9yaWVudChvYmosIGFucywgbnJvdywgbmNvbClcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKGluKSA6OiBvYmpcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKElOT1VUKSA6OiBhbnMoOiwgOilcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKE9VVCkgOjogbnJvdywgbmNvbFxcbkVORCBTVUJST1VUSU5FIEVsZW1kYXRhX0dldEZhY2VPcmllbnRcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZ2V0b3JpZW50YXRpb25cIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0dldE9yaWVudGF0aW9uXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIHN1YnJvdXRpbmUgcmV0dXJucyB0aGUgb3JpZW50YXRpb24gcmVsYXRlZCB2ZWN0b3JzIGluIHRoZSBlbGVtZW50LlwiXG4gICAgfSksIFwiXFxuXCIsIF9qc3goX2NvbXBvbmVudHMucHJlLCB7XG4gICAgICBjaGlsZHJlbjogX2pzeChfY29tcG9uZW50cy5jb2RlLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJsYW5ndWFnZS1mb3J0cmFuXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIlBVUkUgU1VCUk9VVElORSBFbGVtZGF0YV9HZXRPcmllbnRhdGlvbihvYmosIGNlbGxPcmllbnQsIGZhY2VPcmllbnQsICZcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZU9yaWVudCwgdENlbGxPcmllbnQsIHRGYWNlT3JpZW50LCB0RWRnZU9yaWVudClcXG4gIFRZUEUoRWxlbWRhdGFfKSwgSU5URU5UKElOKSA6OiBvYmpcXG4gICEhIGVsZW1lbnQgZGF0YWFcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKElOT1VUKSA6OiBjZWxsT3JpZW50KDopXFxuICAhISBjZWxsIGNvbm5lY3Rpdml0eSBvZiBlbGVtZW50XFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChJTk9VVCkgOjogZmFjZU9yaWVudCg6LCA6KVxcbiAgISEgZmFjZSBjb25uZWN0aXZpdHkgb2YgZWxlbWVudFxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU5PVVQpIDo6IGVkZ2VPcmllbnQoOilcXG4gICEhIGVkZ2UgY29ubmVjdGl2aXR5IG9mIGVsZW1lbnRcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKE9VVCkgOjogdENlbGxPcmllbnRcXG4gICEhIHNpemUgb2YgZGF0YSB3cml0dGVuIGluIGNlbGxDb25cXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKE9VVCkgOjogdEZhY2VPcmllbnQoMilcXG4gICEhIHNpemUgb2YgZGF0YSB3cml0dGVuIGluIGZhY2VDb25cXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKE9VVCkgOjogdEVkZ2VPcmllbnRcXG4gICEhIHNpemUgb2YgZGF0YSB3cml0dGVuIGluIGVkZ2Vjb25cXG5FTkQgU1VCUk9VVElORSBFbGVtZGF0YV9HZXRPcmllbnRhdGlvblxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9maW5kZmFjZVwiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfRmluZEZhY2VcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgc3Vicm91dGluZSBmaW5kcyB0aGUgbG9jYWwgZmFjZSBudW1iZXIgb2YgdGhlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgdGhlIGdpdmVuIGZhY2UuIFRoZSBnaXZlbiBmYWNlIGlzIGRlc2NyaWJlZCBieSBpdHMgY29ubmVjdGl2aXR5IG9mIHRoZSB2ZXJ0aWNlcy5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJTVUJST1VUSU5FIEVsZW1kYXRhX0ZpbmRGYWNlKG9iaiwgZmFjZUNvbiwgaXNGYWNlLCAmXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZhY2VOdW1iZXIsIG9ubHlCb3VuZGFyeUVsZW1lbnQpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICAgICEhIGFic3RyYWN0IG1lc2hcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKElOKSA6OiBmYWNlQ29uKDopXFxuICAgICEhIHZlcnRleCBjb25uZWN0aXZpdHkgb2YgZmFjZVxcbiAgTE9HSUNBTChMR1QpLCBJTlRFTlQoT1VUKSA6OiBpc0ZhY2VcXG4gICAgISEgaWYgZmFjZUNvbiBpcyBhIGZhY2Ugb2YgZ2xvYmFsRWxlbWVudCB0aGVuIGl0IGlzIHRydWUsIGVsc2UgZmFsc2VcXG4gIElOVEVHRVIoSTRCKSwgSU5URU5UKE9VVCkgOjogbG9jYWxGYWNlTnVtYmVyXFxuICAgICEhIGxvY2FsIGZhY2UgbnVtYmVyIGlmIGZvdW5kLCBlbHNlIDBcXG4gIExPR0lDQUwoTEdUKSwgSU5URU5UKElOKSA6OiBvbmx5Qm91bmRhcnlFbGVtZW50XFxuICAgICEhIGlmIHRydWUgdGhlbiB3ZSB3aWxsIHNlYXJjaCBpZiB0aGUgZWxlbWVudCBpcyBib3VuZGFyeSBlbGVtZW50XFxuRU5EIFNVQlJPVVRJTkUgRWxlbWRhdGFfRmluZEZhY2VcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfZmluZGVkZ2VcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0ZpbmRFZGdlXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIHN1YnJvdXRpbmUgZmluZHMgdGhlIGxvY2FsIGVkZ2UgbnVtYmVyIG9mIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHRoZSBnaXZlbiBlZGdlLiBUaGUgZ2l2ZW4gZWRnZSBpcyBkZXNjcmliZWQgYnkgaXRzIGNvbm5lY3Rpdml0eSBvZiB0aGUgdmVydGljZXMuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiU1VCUk9VVElORSBFbGVtZGF0YV9GaW5kRWRnZShvYmosIGVkZ2VDb24sIGlzRWRnZSwgbG9jYWxFZGdlTnVtYmVyLCAmXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmx5Qm91bmRhcnlFbGVtZW50KVxcbiAgVFlQRShFbGVtZGF0YV8pLCBJTlRFTlQoSU4pIDo6IG9ialxcbiAgISEgYWJzdHJhY3QgbWVzaFxcbiAgSU5URUdFUihJNEIpLCBJTlRFTlQoSU4pIDo6IGVkZ2VDb24oOilcXG4gICEhIHZlcnRleCBjb25uZWN0aXZpdHkgb2YgRWRnZVxcbiAgTE9HSUNBTChMR1QpLCBJTlRFTlQoT1VUKSA6OiBpc0VkZ2VcXG4gICEhIGlmIEVkZ2VDb24gaXMgYSBFZGdlIG9mIGdsb2JhbEVsZW1lbnQgdGhlbiBpdCBpcyB0cnVlLCBlbHNlIGZhbHNlXFxuICBJTlRFR0VSKEk0QiksIElOVEVOVChPVVQpIDo6IGxvY2FsRWRnZU51bWJlclxcbiAgISEgbG9jYWwgRWRnZSBudW1iZXIgaWYgZm91bmQsIGVsc2UgMFxcbiAgTE9HSUNBTChMR1QpLCBJTlRFTlQoSU4pIDo6IG9ubHlCb3VuZGFyeUVsZW1lbnRcXG4gICEhIGlmIHRydWUgdGhlbiB3ZSB3aWxsIHNlYXJjaCBpZiB0aGUgZWxlbWVudCBpcyBib3VuZGFyeSBlbGVtZW50XFxuRU5EIFNVQlJPVVRJTkUgRWxlbWRhdGFfRmluZEVkZ2VcXG5cIlxuICAgICAgfSlcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5oMiwge1xuICAgICAgaWQ6IFwiZWxlbWRhdGFfaXNib3VuZGFyeWVsZW1lbnRcIixcbiAgICAgIGNoaWxkcmVuOiBcIkVsZW1kYXRhX0lzQm91bmRhcnlFbGVtZW50XCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wLCB7XG4gICAgICBjaGlsZHJlbjogXCJUaGlzIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBhIGJvdW5kYXJ5IGVsZW1lbnQsIGZhbHNlIG90aGVyd2lzZS5cIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnByZSwge1xuICAgICAgY2hpbGRyZW46IF9qc3goX2NvbXBvbmVudHMuY29kZSwge1xuICAgICAgICBjbGFzc05hbWU6IFwibGFuZ3VhZ2UtZm9ydHJhblwiLFxuICAgICAgICBjaGlsZHJlbjogXCJGVU5DVElPTiBFbGVtZGF0YV9Jc0JvdW5kYXJ5RWxlbWVudChvYmopIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICBMT0dJQ0FMKExHVCkgOjogYW5zXFxuICBhbnMgPSAob2JqJWVsZW1lbnRUeXBlIC5FUS4gVHlwZUVsZW0lYm91bmRhcnkpIC5PUi4gJlxcbiAgICAgICAgKG9iaiVlbGVtZW50VHlwZSAuRVEuIFR5cGVFbGVtJWRvbWFpbkJvdW5kYXJ5KVxcbkVORCBGVU5DVElPTiBFbGVtZGF0YV9Jc0JvdW5kYXJ5RWxlbWVudFxcblwiXG4gICAgICB9KVxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLmgyLCB7XG4gICAgICBpZDogXCJlbGVtZGF0YV9vcmRlclwiLFxuICAgICAgY2hpbGRyZW46IFwiRWxlbWRhdGFfT3JkZXJcIlxuICAgIH0pLCBcIlxcblwiLCBfanN4KF9jb21wb25lbnRzLnAsIHtcbiAgICAgIGNoaWxkcmVuOiBcIlRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgb3JkZXIgb2YgdGhlIGVsZW1lbnQuXCJcbiAgICB9KSwgXCJcXG5cIiwgX2pzeChfY29tcG9uZW50cy5wcmUsIHtcbiAgICAgIGNoaWxkcmVuOiBfanN4KF9jb21wb25lbnRzLmNvZGUsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcImxhbmd1YWdlLWZvcnRyYW5cIixcbiAgICAgICAgY2hpbGRyZW46IFwiUFVSRSBGVU5DVElPTiBFbGVtZGF0YV9PcmRlcihvYmopIFJFU1VMVChhbnMpXFxuICBUWVBFKEVsZW1kYXRhXyksIElOVEVOVChJTikgOjogb2JqXFxuICBJTlRFR0VSKEk0QikgOjogYW5zXFxuICBhbnMgPSBFbGVtZW50T3JkZXIob2JqJW5hbWUpXFxuRU5EIEZVTkNUSU9OIEVsZW1kYXRhX09yZGVyXFxuXCJcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTURYQ29udGVudChwcm9wcyA9IHt9KSB7XG4gIGNvbnN0IHt3cmFwcGVyOiBNRFhMYXlvdXR9ID0ge1xuICAgIC4uLl9wcm92aWRlQ29tcG9uZW50cygpLFxuICAgIC4uLnByb3BzLmNvbXBvbmVudHNcbiAgfTtcbiAgcmV0dXJuIE1EWExheW91dCA/IF9qc3goTURYTGF5b3V0LCB7XG4gICAgLi4ucHJvcHMsXG4gICAgY2hpbGRyZW46IF9qc3goX2NyZWF0ZU1keENvbnRlbnQsIHtcbiAgICAgIC4uLnByb3BzXG4gICAgfSlcbiAgfSkgOiBfY3JlYXRlTWR4Q29udGVudChwcm9wcyk7XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./docs/docs-api/AbstractMesh/ElemData_.md\n");

/***/ }),

/***/ "./node_modules/@mdx-js/react/lib/index.js":
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MDXProvider: () => (/* binding */ MDXProvider),\n/* harmony export */   useMDXComponents: () => (/* binding */ useMDXComponents)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./node_modules/react/index.js\");\n/**\n * @import {MDXComponents} from 'mdx/types.js'\n * @import {Component, ReactElement, ReactNode} from 'react'\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\n\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nfunction useMDXComponents(components) {\n  const contextComponents = react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {ReactElement}\n *   Element.\n * @satisfies {Component}\n */\nfunction MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1keC1qcy9yZWFjdC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vhc2lmZW0tZG9jcy8uL25vZGVfbW9kdWxlcy9AbWR4LWpzL3JlYWN0L2xpYi9pbmRleC5qcz9hZjEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7TURYQ29tcG9uZW50c30gZnJvbSAnbWR4L3R5cGVzLmpzJ1xuICogQGltcG9ydCB7Q29tcG9uZW50LCBSZWFjdEVsZW1lbnQsIFJlYWN0Tm9kZX0gZnJvbSAncmVhY3QnXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgTWVyZ2VDb21wb25lbnRzXG4gKiAgIEN1c3RvbSBtZXJnZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7UmVhZG9ubHk8TURYQ29tcG9uZW50cz59IGN1cnJlbnRDb21wb25lbnRzXG4gKiAgIEN1cnJlbnQgY29tcG9uZW50cyBmcm9tIHRoZSBjb250ZXh0LlxuICogQHJldHVybnMge01EWENvbXBvbmVudHN9XG4gKiAgIEFkZGl0aW9uYWwgY29tcG9uZW50cy5cbiAqXG4gKiBAdHlwZWRlZiBQcm9wc1xuICogICBDb25maWd1cmF0aW9uIGZvciBgTURYUHJvdmlkZXJgLlxuICogQHByb3BlcnR5IHtSZWFjdE5vZGUgfCBudWxsIHwgdW5kZWZpbmVkfSBbY2hpbGRyZW5dXG4gKiAgIENoaWxkcmVuIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge1JlYWRvbmx5PE1EWENvbXBvbmVudHM+IHwgTWVyZ2VDb21wb25lbnRzIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2NvbXBvbmVudHNdXG4gKiAgIEFkZGl0aW9uYWwgY29tcG9uZW50cyB0byB1c2Ugb3IgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlbSAob3B0aW9uYWwpLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Rpc2FibGVQYXJlbnRDb250ZXh0PWZhbHNlXVxuICogICBUdXJuIG9mZiBvdXRlciBjb21wb25lbnQgY29udGV4dCAoZGVmYXVsdDogYGZhbHNlYCkuXG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG4vKiogQHR5cGUge1JlYWRvbmx5PE1EWENvbXBvbmVudHM+fSAqL1xuY29uc3QgZW1wdHlDb21wb25lbnRzID0ge31cblxuY29uc3QgTURYQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoZW1wdHlDb21wb25lbnRzKVxuXG4vKipcbiAqIEdldCBjdXJyZW50IGNvbXBvbmVudHMgZnJvbSB0aGUgTURYIENvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFkb25seTxNRFhDb21wb25lbnRzPiB8IE1lcmdlQ29tcG9uZW50cyB8IG51bGwgfCB1bmRlZmluZWR9IFtjb21wb25lbnRzXVxuICogICBBZGRpdGlvbmFsIGNvbXBvbmVudHMgdG8gdXNlIG9yIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZW0gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtNRFhDb21wb25lbnRzfVxuICogICBDdXJyZW50IGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNRFhDb21wb25lbnRzKGNvbXBvbmVudHMpIHtcbiAgY29uc3QgY29udGV4dENvbXBvbmVudHMgPSBSZWFjdC51c2VDb250ZXh0KE1EWENvbnRleHQpXG5cbiAgLy8gTWVtb2l6ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB0b3AtbGV2ZWwgY29udGV4dCBjaGFuZ2VzXG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEN1c3RvbSBtZXJnZSB2aWEgYSBmdW5jdGlvbiBwcm9wXG4gICAgICBpZiAodHlwZW9mIGNvbXBvbmVudHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHMoY29udGV4dENvbXBvbmVudHMpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7Li4uY29udGV4dENvbXBvbmVudHMsIC4uLmNvbXBvbmVudHN9XG4gICAgfSxcbiAgICBbY29udGV4dENvbXBvbmVudHMsIGNvbXBvbmVudHNdXG4gIClcbn1cblxuLyoqXG4gKiBQcm92aWRlciBmb3IgTURYIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFkb25seTxQcm9wcz59IHByb3BlcnRpZXNcbiAqICAgUHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtSZWFjdEVsZW1lbnR9XG4gKiAgIEVsZW1lbnQuXG4gKiBAc2F0aXNmaWVzIHtDb21wb25lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNRFhQcm92aWRlcihwcm9wZXJ0aWVzKSB7XG4gIC8qKiBAdHlwZSB7UmVhZG9ubHk8TURYQ29tcG9uZW50cz59ICovXG4gIGxldCBhbGxDb21wb25lbnRzXG5cbiAgaWYgKHByb3BlcnRpZXMuZGlzYWJsZVBhcmVudENvbnRleHQpIHtcbiAgICBhbGxDb21wb25lbnRzID1cbiAgICAgIHR5cGVvZiBwcm9wZXJ0aWVzLmNvbXBvbmVudHMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwcm9wZXJ0aWVzLmNvbXBvbmVudHMoZW1wdHlDb21wb25lbnRzKVxuICAgICAgICA6IHByb3BlcnRpZXMuY29tcG9uZW50cyB8fCBlbXB0eUNvbXBvbmVudHNcbiAgfSBlbHNlIHtcbiAgICBhbGxDb21wb25lbnRzID0gdXNlTURYQ29tcG9uZW50cyhwcm9wZXJ0aWVzLmNvbXBvbmVudHMpXG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBNRFhDb250ZXh0LlByb3ZpZGVyLFxuICAgIHt2YWx1ZTogYWxsQ29tcG9uZW50c30sXG4gICAgcHJvcGVydGllcy5jaGlsZHJlblxuICApXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@mdx-js/react/lib/index.js\n");

/***/ })

}]);